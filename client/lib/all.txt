```
// lib/themes.dart
import 'package:flutter/material.dart';

// Базовая цветовая схема для светлой темы
const ColorScheme _lightColorSchemeBase = ColorScheme.light(
  background: Color(0xFFF5F5F5), // Основной фон приложения
  onBackground: Color(0xFF1C1B1F), // Цвет текста и иконок на фоне background
  surface: Color(0xFFFFFFFF), // Цвет поверхностей компонентов (карточки, меню)
  onSurface: Color(0xFF1C1B1F), // Цвет текста и иконок на фоне surface
  surfaceVariant: Color(0xFFE7E0EC), // Альтернативный цвет поверхности, чуть темнее/светлее
  onSurfaceVariant: Color(0xFF49454F), // Цвет текста и иконок на surfaceVariant
  outline: Color(0xFF79747E), // Цвет границ, разделителей
  outlineVariant: Color(0xFFCAC4D0), // Более светлый/темный вариант outline
  shadow: Color(0xFF000000),
  inverseSurface: Color(0xFF313033), // Для элементов, которые должны контрастировать с surface
  onInverseSurface: Color(0xFFF4EFF4),
  inversePrimary: Color(0xFFD0BCFF), // Контрастный к primary (для текста на primary, если onPrimary не подходит)
  primaryContainer: Color(0xFFEADDFF), // Контейнер для primary-акцентных элементов
  onPrimaryContainer: Color(0xFF21005D),
  secondaryContainer: Color(0xFFE8DEF8), // Контейнер для secondary-акцентных элементов
  onSecondaryContainer: Color(0xFF1D192B),
  tertiary: Color(0xFF7D5260),
  onTertiary: Colors.white,
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF31111D),
  error: Color(0xFFB3261E),
  onError: Colors.white,
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF410E0B),
  surfaceTint: Colors.transparent, // Отключаем тонирование поверхности по умолчанию
  // primary, onPrimary, secondary, onSecondary будут добавлены
  brightness: Brightness.light,
  surfaceContainerHighest: Color(0xFFEAEAEA), // Для фона инпутов в светлой теме (специально)
  surfaceContainerLow: Color(0xFFF0F0F0), // Для фона DropdownButton в светлой теме (специально)
);

// Базовая цветовая схема для темной темы
const ColorScheme _darkColorSchemeBase = ColorScheme.dark(
  background: Color(0xFF252525),    // Основной фон приложения
  onBackground: Color(0xFFE6E1E5), // Цвет текста и иконок на фоне background
  surface: Color(0xFF161616),       // Цвет поверхностей компонентов (карточки, меню)
  onSurface: Color(0xFFE0E0E0),     // Цвет текста и иконок на фоне surface
  surfaceVariant: Color(0xFF49454F), // Альтернативный цвет поверхности
  onSurfaceVariant: Color(0xFFCAC4D0), // Цвет текста и иконок на surfaceVariant
  outline: Color(0xFF938F99),       // Цвет границ, разделителей
  outlineVariant: Color(0xFF49454F), // Более светлый/темный вариант outline
  shadow: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E1E5),
  onInverseSurface: Color(0xFF313033),
  inversePrimary: Color(0xFF6750A4),
  primaryContainer: Color(0xFF4A4458),
  onPrimaryContainer: Color(0xFFEADDFF),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  surfaceTint: Colors.transparent, // Отключаем тонирование поверхности по умолчанию
  // primary, onPrimary, secondary, onSecondary будут добавлены
  brightness: Brightness.dark,
  surfaceContainerHighest: Color(0xFF393939), // Для фона инпутов в темной теме (специально)
  surfaceContainerLow: Color(0xFF2C2C2C), // Для фона DropdownButton в темной теме (специально)
);

ThemeData getLightTheme(Color accentColor) {
  final baseScheme = _lightColorSchemeBase;
  final onPrimaryColor = ThemeData.estimateBrightnessForColor(accentColor) == Brightness.dark
      ? Colors.white
      : Colors.black;

  final colorScheme = baseScheme.copyWith(
    primary: accentColor,
    onPrimary: onPrimaryColor,
    secondary: accentColor, // Используем акцентный цвет и для secondary (можно изменить)
    onSecondary: onPrimaryColor, // Соответственно
    surfaceTint: accentColor, // Для Material 3 эффектов, если используются
  );
  return _buildThemeData(colorScheme, Brightness.light, accentColor);
}

ThemeData getDarkTheme(Color accentColor) {
  final baseScheme = _darkColorSchemeBase;
  final onPrimaryColor = ThemeData.estimateBrightnessForColor(accentColor) == Brightness.dark
      ? Colors.white
      : Colors.black;
  final colorScheme = baseScheme.copyWith(
    primary: accentColor,
    onPrimary: onPrimaryColor,
    secondary: accentColor, // Используем акцентный цвет и для secondary (можно изменить)
    onSecondary: onPrimaryColor, // Соответственно
    surfaceTint: accentColor, // Для Material 3 эффектов, если используются
  );
  return _buildThemeData(colorScheme, Brightness.dark, accentColor);
}

ThemeData _buildThemeData(ColorScheme colorScheme, Brightness brightness, Color accentColor) {
  return ThemeData(
    fontFamily: 'Inter',
    colorScheme: colorScheme,
    scaffoldBackgroundColor: colorScheme.background,
    canvasColor: colorScheme.surfaceContainerLow, // Фон для DropdownButton и подобных
    dividerColor: colorScheme.outlineVariant,
    textTheme: _buildTextTheme(colorScheme, accentColor),
    elevatedButtonTheme: _buildElevatedButtonTheme(accentColor, colorScheme.onPrimary, colorScheme),
    inputDecorationTheme: _buildInputDecorationTheme(colorScheme),
    brightness: brightness,
    appBarTheme: AppBarTheme(
      backgroundColor: colorScheme.surface, // Или surfaceContainer для другого эффекта
      foregroundColor: colorScheme.onSurface,
      elevation: 0,
      surfaceTintColor: colorScheme.surfaceTint, // Для M3 эффекта при прокрутке
    ),
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      backgroundColor: colorScheme.surface, // Или surfaceContainer
      selectedItemColor: colorScheme.primary,
      unselectedItemColor: colorScheme.onSurfaceVariant,
      elevation: 0, // Можно добавить, если нужен эффект поднятия
      type: BottomNavigationBarType.fixed,
      showSelectedLabels: true,
      showUnselectedLabels: true,
      selectedLabelStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500, fontFamily: 'Inter'),
      unselectedLabelStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500, fontFamily: 'Inter'),
    ),
    floatingActionButtonTheme: FloatingActionButtonThemeData(
      backgroundColor: colorScheme.primaryContainer,
      foregroundColor: colorScheme.onPrimaryContainer,
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
    ),
    dialogBackgroundColor: colorScheme.surfaceContainerLow,
    dialogTheme: DialogTheme(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      backgroundColor: colorScheme.surfaceContainerLow,
      titleTextStyle: TextStyle(color: colorScheme.onSurface, fontSize: 20, fontWeight: FontWeight.w600, fontFamily: 'Inter'),
      contentTextStyle: TextStyle(color: colorScheme.onSurfaceVariant, fontSize: 15, fontFamily: 'Inter'),
    ),
    snackBarTheme: SnackBarThemeData(
      backgroundColor: colorScheme.inverseSurface,
      contentTextStyle: TextStyle(color: colorScheme.onInverseSurface, fontFamily: 'Inter'),
      actionTextColor: colorScheme.inversePrimary,
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      elevation: 4,
    ),
    segmentedButtonTheme: SegmentedButtonThemeData(
      style: ButtonStyle(
        backgroundColor: MaterialStateProperty.resolveWith<Color?>((states) {
          if (states.contains(MaterialState.selected)) {
            return colorScheme.primary;
          }
          return colorScheme.surfaceContainerHighest;
        }),
        foregroundColor: MaterialStateProperty.resolveWith<Color?>((states) {
          if (states.contains(MaterialState.selected)) {
            return colorScheme.onPrimary;
          }
          return colorScheme.onSurface;
        }),
        side: MaterialStateProperty.all(BorderSide(color: colorScheme.outline.withOpacity(0.5))),
        padding: MaterialStateProperty.all(const EdgeInsets.symmetric(vertical: 8, horizontal: 12)),
        textStyle: MaterialStateProperty.all(const TextStyle(fontFamily: 'Inter', fontSize: 13)),
        shape: MaterialStateProperty.all(RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
      ),
    ),
    useMaterial3: true, // Включаем Material 3
  );
}

TextTheme _buildTextTheme(ColorScheme colorScheme, Color accentColor) {
  final typography = Typography.material2021(
    platform: TargetPlatform.android,
    colorScheme: colorScheme, // Передаем текущую colorScheme
  );

  // Используем базовые стили из типографии, которые уже учитывают цвет onSurface из colorScheme
  TextTheme baseTextTheme = colorScheme.brightness == Brightness.light ? typography.black : typography.white;

  return baseTextTheme.copyWith(
    headlineSmall: baseTextTheme.headlineSmall?.copyWith(
      fontSize: 24,
      fontWeight: FontWeight.bold,
      // color: colorScheme.onSurface, // Уже должно быть установлено
    ),
    bodyLarge: baseTextTheme.bodyLarge?.copyWith(
      color: colorScheme.onSurface.withOpacity(0.85),
    ),
    bodyMedium: baseTextTheme.bodyMedium?.copyWith(
      fontSize: 16,
      color: colorScheme.onSurface.withOpacity(0.75),
    ),
    titleLarge: baseTextTheme.titleLarge?.copyWith(
      // color: colorScheme.onSurface, // Уже должно быть установлено
      fontWeight: FontWeight.bold,
    ),
    titleMedium: baseTextTheme.titleMedium?.copyWith(
      color: colorScheme.onSurface.withOpacity(0.8),
      fontWeight: FontWeight.w400,
      fontSize: 14,
    ),
    labelLarge: baseTextTheme.labelLarge?.copyWith(
      fontWeight: FontWeight.w600,
      fontSize: 16,
      // color: colorScheme.onSurface, // Уже должно быть установлено для кнопок и т.д.
    ),
  ).apply(fontFamily: 'Inter');
}

ElevatedButtonThemeData _buildElevatedButtonTheme(Color backgroundColor, Color foregroundColor, ColorScheme colorScheme) {
  return ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: backgroundColor, // Это акцентный цвет
      foregroundColor: foregroundColor, // Цвет текста/иконки на акцентном цвете
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
      textStyle: const TextStyle(fontFamily: 'Inter', fontWeight: FontWeight.w600, fontSize: 16),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10), // Немного увеличил радиус для M3
      ),
      elevation: 2, // Небольшая тень для M3 стиля
      // minimumSize: const Size(64, 40), // M3 рекомендует мин. высоту 40
    ),
  );
}

InputDecorationTheme _buildInputDecorationTheme(ColorScheme colorScheme) {
  return InputDecorationTheme(
    filled: true,
    fillColor: colorScheme.surfaceContainerHighest,
    hintStyle: TextStyle(color: colorScheme.onSurfaceVariant.withOpacity(0.7), fontFamily: 'Inter'),
    labelStyle: TextStyle(color: colorScheme.onSurfaceVariant, fontFamily: 'Inter', fontWeight: FontWeight.w500),
    floatingLabelStyle: TextStyle(color: colorScheme.primary, fontFamily: 'Inter', fontWeight: FontWeight.w500), // Цвет метки при фокусе
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(10), // Немного увеличил радиус
      borderSide: BorderSide(color: colorScheme.outline, width: 1.0),
    ),
    enabledBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(10),
      borderSide: BorderSide(color: colorScheme.outline.withOpacity(0.7), width: 1.0),
    ),
    focusedBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(10),
      borderSide: BorderSide(color: colorScheme.primary, width: 2.0),
    ),
    errorBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(10),
      borderSide: BorderSide(color: colorScheme.error, width: 1.5),
    ),
    focusedErrorBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(10),
      borderSide: BorderSide(color: colorScheme.error, width: 2.0),
    ),
    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
  );
}
```

```
// lib/theme_provider.dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
// import 'dart:convert'; // Больше не нужен здесь
import 'themes.dart';
// import 'models/task_model.dart'; // Больше не нужен здесь

class ThemeProvider with ChangeNotifier {
  ThemeMode _themeMode = ThemeMode.system;
  Color _accentColor = const Color(0xFF5457FF);
  // List<TaskTag> _userTags = []; // УДАЛЕНО

  static const String _themeModeKey = 'app_theme_mode_v2';
  static const String _accentColorKey = 'app_accent_color_v2';
  // static const String _userTagsKey = 'app_user_tags_v1'; // УДАЛЕНО

  ThemeProvider() {
    _loadPreferences();
  }

  ThemeMode get themeMode => _themeMode;
  Color get accentColor => _accentColor;
  // List<TaskTag> get userTags => List.unmodifiable(_userTags); // УДАЛЕНО

  bool get isEffectivelyDark {
    if (_themeMode == ThemeMode.system) {
      return WidgetsBinding.instance.platformDispatcher.platformBrightness == Brightness.dark;
    }
    return _themeMode == ThemeMode.dark;
  }

  ThemeData get currentTheme {
    return isEffectivelyDark ? getDarkTheme(_accentColor) : getLightTheme(_accentColor);
  }

  Future<void> _loadPreferences() async {
    final prefs = await SharedPreferences.getInstance();

    final themeModeIndex = prefs.getInt(_themeModeKey);
    if (themeModeIndex != null && themeModeIndex >= 0 && themeModeIndex < ThemeMode.values.length) {
      _themeMode = ThemeMode.values[themeModeIndex];
    }

    final accentColorValue = prefs.getInt(_accentColorKey);
    if (accentColorValue != null) {
      _accentColor = Color(accentColorValue);
    }

    // Загрузка тегов УДАЛЕНА отсюда

    notifyListeners();
  }

  Future<void> _savePreferences() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_themeModeKey, _themeMode.index);
    await prefs.setInt(_accentColorKey, _accentColor.value);
    // Сохранение тегов УДАЛЕНО отсюда
  }

  void setThemeMode(ThemeMode mode) {
    if (_themeMode != mode) {
      _themeMode = mode;
      _savePreferences();
      notifyListeners();
    }
  }

  void setAccentColor(Color color) {
    if (_accentColor != color) {
      _accentColor = color;
      _savePreferences();
      notifyListeners();
    }
  }

// Методы для управления тегами УДАЛЕНЫ отсюда
}
```

```
// lib/task_provider.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'dart:collection'; // Для UnmodifiableListView
import 'models/task_model.dart';
import 'services/api_service.dart';
import 'auth_state.dart';

class TaskProvider with ChangeNotifier {
  final ApiService _apiService;
  final AuthState _authState;

  List<Task> _tasks = [];
  bool _isLoadingList = false;
  bool _isProcessingTask = false;
  String? _error;

  TaskProvider(this._apiService, this._authState) {
    _authState.addListener(_onAuthStateChanged);
    if (_authState.isLoggedIn) {
      debugPrint("TaskProvider: Initializing and fetching tasks as user is logged in.");
      fetchAllTasks();
    } else {
      debugPrint("TaskProvider: Initializing, user not logged in.");
    }
  }

  void _onAuthStateChanged() {
    if (_authState.isLoggedIn) {
      debugPrint("TaskProvider: AuthState changed to logged in. Fetching all tasks.");
      fetchAllTasks();
    } else {
      debugPrint("TaskProvider: AuthState changed to logged out. Clearing tasks.");
      _tasks = [];
      _error = null;
      _isLoadingList = false;
      _isProcessingTask = false;
      notifyListeners();
    }
  }

  List<Task> get allTasks => UnmodifiableListView(_tasks.where((task) => !task.isDeleted).toList());

  List<Task> get personalTasks {
    if (!_authState.isLoggedIn || _authState.currentUser == null) {
      return [];
    }
    final currentUserIdStr = _authState.currentUser!.userId.toString();
    final filteredTasks = _tasks.where((task) {
      bool isPersonal = !task.isDeleted &&
          !task.isTeamTask &&
          (task.createdByUserId == currentUserIdStr || task.assignedToUserId == currentUserIdStr);
      return isPersonal;
    }).toList();
    return UnmodifiableListView(filteredTasks);
  }

  bool get isLoadingList => _isLoadingList;
  bool get isProcessingTask => _isProcessingTask;
  String? get error => _error;

  Future<void> fetchAllTasks({Map<String, String>? queryParams}) async {
    if (!_authState.isLoggedIn) {
      _isLoadingList = false;
      notifyListeners();
      return;
    }
    _isLoadingList = true;
    _error = null;
    notifyListeners();
    try {
      _tasks = await _apiService.getTasks(queryParams: queryParams);
    } on ApiException catch (e) {
      _error = "Ошибка загрузки задач: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при загрузке задач: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при загрузке задач: $e";
    }
    _isLoadingList = false;
    notifyListeners();
  }

  Future<Task?> getTaskById(String taskId) async {
    if (!_authState.isLoggedIn) return null;
    final existingTaskIndex = _tasks.indexWhere((t) => t.taskId == taskId);
    if (existingTaskIndex != -1 && !_tasks[existingTaskIndex].isDeleted) {
      return _tasks[existingTaskIndex];
    }
    // Сохраняем предыдущую ошибку, если она была от списка
    String? prevError = _error;
    _error = null;
    // Не используем _isProcessingTask здесь, чтобы не блокировать другие операции
    // notifyListeners(); // Можно, если есть UI, зависящий от загрузки отдельной задачи

    try {
      final task = await _apiService.getTaskById(taskId);
      final newExistingTaskIndex = _tasks.indexWhere((t) => t.taskId == taskId); // Перепроверяем индекс
      if (newExistingTaskIndex != -1) {
        _tasks[newExistingTaskIndex] = task;
      } else {
        _tasks.add(task);
      }
      if (_error == null && prevError != null && _error != prevError) _error = prevError;
      notifyListeners();
      return task;
    } on ApiException catch (e) {
      _error = "Ошибка загрузки задачи $taskId: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при загрузке задачи $taskId: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при загрузке задачи $taskId: $e";
    }
    if (_error == null && prevError != null && _error != prevError) _error = prevError;
    notifyListeners();
    return null;
  }

  Future<bool> createTask(Task taskData) async {
    if (!_authState.isLoggedIn) return false;
    _isProcessingTask = true;
    _error = null;
    notifyListeners(); // Уведомляем UI о начале процесса

    bool success = false; // Объявляем здесь
    try {
      debugPrint("TaskProvider (createTask) - Sending to API: ${taskData.toJsonForCreate()}");
      final createdTask = await _apiService.createTask(taskData);
      debugPrint("TaskProvider (createTask) - Received from API: taskId=${createdTask.taskId}, title='${createdTask.title}', createdByUserId='${createdTask.createdByUserId}', assignedToUserId='${createdTask.assignedToUserId}', teamId='${createdTask.teamId}'");

      _tasks.insert(0, createdTask);
      _error = null;
      success = true; // Устанавливаем при успехе
    } on ApiException catch (e) {
      _error = "Ошибка создания задачи: ${e.message}";
      debugPrint("TaskProvider (createTask): ApiException: $_error");
      // success остается false
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при создании задачи: ${e.message}";
      debugPrint("TaskProvider (createTask): NetworkException: $_error");
      // success остается false
    } catch (e) {
      _error = "Неизвестная ошибка при создании задачи: $e";
      debugPrint("TaskProvider (createTask): Unknown error: $e");
      // success остается false
    } finally {
      _isProcessingTask = false;
      notifyListeners(); // Финальное уведомление после завершения операции
    }
    return success; // Возвращаем результат
  }

  Future<bool> updateTask(Task task) async {
    if (!_authState.isLoggedIn) return false;
    _isProcessingTask = true;
    _error = null;
    notifyListeners();

    try {
      final updatedTask = await _apiService.updateTask(task.taskId, task);
      final index = _tasks.indexWhere((t) => t.taskId == updatedTask.taskId);
      if (index != -1) {
        _tasks[index] = updatedTask;
        _error = null;
        return true;
      } else {
        _error = "Задача для обновления не найдена в локальном списке.";
        return false;
      }
    } on ApiException catch (e) {
      _error = "Ошибка обновления задачи: ${e.message}";
      return false;
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при обновлении задачи: ${e.message}";
      return false;
    } catch (e) {
      _error = "Неизвестная ошибка при обновлении задачи: $e";
      return false;
    } finally {
      _isProcessingTask = false;
      notifyListeners();
    }
  }

  Future<bool> patchTask(String taskId, Map<String, dynamic> patchData) async {
    if (!_authState.isLoggedIn) return false;
    // Для patchTask можно не устанавливать _isProcessingTask, если это фоновая операция,
    // или использовать отдельный флаг, если UI должен реагировать на процесс патча.
    // Пока оставим без _isProcessingTask, так как UI обновляется оптимистично.
    // _isProcessingTask = true;
    String? prevError = _error;
    _error = null;
    // notifyListeners(); // Если isProcessingTask используется

    try {
      final patchedTask = await _apiService.patchTask(taskId, patchData);
      final index = _tasks.indexWhere((t) => t.taskId == patchedTask.taskId);
      if (index != -1) {
        _tasks[index] = patchedTask;
      } else {
        _tasks.add(patchedTask);
      }
      if (_error == null && prevError != null && _error != prevError) _error = prevError;
      notifyListeners();
      return true;
    } on ApiException catch (e) {
      _error = "Ошибка частичного обновления задачи: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при частичном обновлении задачи: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при частичном обновлении задачи: $e";
    }
    // _isProcessingTask = false;
    if (_error == null && prevError != null && _error != prevError) _error = prevError;
    notifyListeners();
    return false;
  }

  Future<bool> deleteTask(String taskId) async {
    if (!_authState.isLoggedIn) return false;
    _isProcessingTask = true;
    _error = null;
    notifyListeners();

    final originalTaskIndex = _tasks.indexWhere((t) => t.taskId == taskId);
    Task? originalTask;

    if (originalTaskIndex != -1) {
      originalTask = _tasks[originalTaskIndex];
      _tasks.removeAt(originalTaskIndex); // Оптимистичное удаление из списка
      notifyListeners(); // Уведомляем об удалении из UI
    }

    try {
      await _apiService.deleteTask(taskId);
      _error = null; // Успех
      return true;
    } on ApiException catch (e) {
      _error = "Ошибка удаления задачи: ${e.message}";
      if (originalTask != null && originalTaskIndex != -1) {
        _tasks.insert(originalTaskIndex, originalTask); // Откат
      }
      return false;
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при удалении задачи: ${e.message}";
      if (originalTask != null && originalTaskIndex != -1) {
        _tasks.insert(originalTaskIndex, originalTask); // Откат
      }
      return false;
    } catch (e) {
      _error = "Неизвестная ошибка при удалении задачи: $e";
      if (originalTask != null && originalTaskIndex != -1) {
        _tasks.insert(originalTaskIndex, originalTask); // Откат
      }
      return false;
    } finally {
      _isProcessingTask = false;
      notifyListeners(); // Финальное уведомление
    }
  }

  void locallyUpdateTaskStatus(String taskId, KanbanColumnStatus newStatus) {
    final index = _tasks.indexWhere((t) => t.taskId == taskId);
    if (index != -1) {
      Task oldTask = _tasks[index];
      _tasks[index] = _tasks[index].copyWith(
        status: newStatus,
        updatedAt: DateTime.now(),
        completedAt: newStatus == KanbanColumnStatus.done ? DateTime.now() : (oldTask.status == KanbanColumnStatus.done ? null : oldTask.completedAt),
        completedAtIsNull: newStatus != KanbanColumnStatus.done,
      );
      notifyListeners();

      Map<String, dynamic> patchData = {'status': newStatus.toJson()};
      if (newStatus == KanbanColumnStatus.done) {
        patchData['completed_at'] = DateTime.now().toIso8601String();
      } else if (oldTask.status == KanbanColumnStatus.done) {
        patchData['completed_at'] = null;
      }

      patchTask(taskId, patchData).then((success) {
        if (!success) {
          debugPrint("Failed to update task status on backend for task $taskId. Error: $_error");
          final currentIndexAfterFail = _tasks.indexWhere((t) => t.taskId == taskId);
          if (currentIndexAfterFail != -1) {
            _tasks[currentIndexAfterFail] = oldTask; // Откат
            notifyListeners();
          }
        }
      });
    }
  }

  void clearError() {
    if (_error != null) {
      _error = null;
      notifyListeners();
    }
  }

  @override
  void dispose() {
    debugPrint("TaskProvider: Disposing.");
    _authState.removeListener(_onAuthStateChanged);
    super.dispose();
  }
}
```

```
// lib/tag_provider.dart
import 'package:flutter/material.dart';
import 'dart:collection'; // Для UnmodifiableListView
import 'models/task_model.dart'; // Для ApiTag
import 'services/api_service.dart'; // Для ApiService
import 'auth_state.dart'; // Для получения userID

class TagProvider with ChangeNotifier {
  final ApiService _apiService;
  final AuthState _authState; // Для получения ID текущего пользователя

  List<ApiTag> _userTags = [];
  Map<int, List<ApiTag>> _teamTagsByTeamId = {}; // Кэш тегов команд

  bool _isLoadingUserTags = false;
  bool _isLoadingTeamTags = false; // Общий флаг для загрузки тегов любой команды
  String? _error;

  TagProvider(this._apiService, this._authState) {
    // Слушаем изменения в AuthState, чтобы перезагрузить теги при логине/разлогине
    _authState.addListener(_onAuthStateChanged);
    if (_authState.isLoggedIn) {
      fetchUserTags();
    }
  }

  void _onAuthStateChanged() {
    if (_authState.isLoggedIn) {
      fetchUserTags();
      // Очищаем кэш командных тегов, так как они могут быть специфичны для пользователя (доступ)
      _teamTagsByTeamId.clear();
    } else {
      _userTags = [];
      _teamTagsByTeamId.clear();
      _error = null;
      notifyListeners();
    }
  }

  // --- Getters ---
  List<ApiTag> get userTags => UnmodifiableListView(_userTags);
  Map<int, List<ApiTag>> get teamTagsByTeamId => UnmodifiableMapView(_teamTagsByTeamId);
  bool get isLoadingUserTags => _isLoadingUserTags;
  bool get isLoadingTeamTags => _isLoadingTeamTags;
  String? get error => _error;

  // --- User Tags Methods ---
  Future<void> fetchUserTags() async {
    if (!_authState.isLoggedIn) return;
    _isLoadingUserTags = true;
    _error = null;
    notifyListeners();
    try {
      _userTags = await _apiService.getUserTags();
    } on ApiException catch (e) {
      _error = "Ошибка загрузки пользовательских тегов: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при загрузке тегов: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при загрузке тегов: $e";
    }
    _isLoadingUserTags = false;
    notifyListeners();
  }

  Future<bool> createUserTag({required String name, String? colorHex}) async {
    if (!_authState.isLoggedIn) return false;
    // Можно добавить isLoading флаг для конкретной операции, если нужно
    _error = null;
    notifyListeners();
    try {
      final newTag = await _apiService.createUserTag(name: name, colorHex: colorHex);
      _userTags.add(newTag);
      _userTags.sort((a,b) => a.name.compareTo(b.name)); // Опциональная сортировка
      notifyListeners();
      return true;
    } on ApiException catch (e) {
      _error = "Ошибка создания тега: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при создании тега: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при создании тега: $e";
    }
    notifyListeners();
    return false;
  }

  Future<bool> updateUserTag(int tagId, {String? name, String? colorHex}) async {
    if (!_authState.isLoggedIn) return false;
    _error = null;
    // notifyListeners(); // Можно не уведомлять до результата
    try {
      final updatedTag = await _apiService.updateUserTag(tagId, name: name, colorHex: colorHex);
      final index = _userTags.indexWhere((tag) => tag.id == tagId);
      if (index != -1) {
        _userTags[index] = updatedTag;
        _userTags.sort((a,b) => a.name.compareTo(b.name)); // Опциональная сортировка
        notifyListeners();
        return true;
      }
    } on ApiException catch (e) {
      _error = "Ошибка обновления тега: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при обновлении тега: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при обновлении тега: $e";
    }
    notifyListeners(); // Уведомить об ошибке
    return false;
  }

  Future<bool> deleteUserTag(int tagId) async {
    if (!_authState.isLoggedIn) return false;
    _error = null;
    // notifyListeners();
    try {
      await _apiService.deleteUserTag(tagId);
      _userTags.removeWhere((tag) => tag.id == tagId);
      notifyListeners();
      return true;
    } on ApiException catch (e) {
      _error = "Ошибка удаления тега: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при удалении тега: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при удалении тега: $e";
    }
    notifyListeners();
    return false;
  }

  // --- Team Tags Methods (базовая загрузка, CRUD будет на этапе команд) ---
  Future<void> fetchTeamTags(int teamId, {bool forceRefresh = false}) async {
    if (!_authState.isLoggedIn) return;
    if (_teamTagsByTeamId.containsKey(teamId) && !forceRefresh) {
      // Теги для этой команды уже загружены
      return;
    }
    _isLoadingTeamTags = true; // Используем общий флаг
    _error = null;
    notifyListeners();
    try {
      final tags = await _apiService.getTeamTags(teamId);
      _teamTagsByTeamId[teamId] = tags;
      _teamTagsByTeamId[teamId]?.sort((a,b) => a.name.compareTo(b.name));
    } on ApiException catch (e) {
      _error = "Ошибка загрузки тегов команды $teamId: ${e.message}";
    } on NetworkException catch (e) {
      _error = "Сетевая ошибка при загрузке тегов команды $teamId: ${e.message}";
    } catch (e) {
      _error = "Неизвестная ошибка при загрузке тегов команды $teamId: $e";
    }
    _isLoadingTeamTags = false;
    notifyListeners();
  }

  // Методы для create/update/delete TeamTag будут похожи на UserTag,
  // но будут принимать teamId и вызывать соответствующие методы _apiService.
  // Их можно добавить позже.

  // --- Helper Methods ---
  ApiTag? getTagById(int id, {int? teamIdContext}) {
    // Сначала ищем среди пользовательских тегов
    try {
      return _userTags.firstWhere((tag) => tag.id == id && tag.type == 'user');
    } catch (e) {
      // Не найдено среди пользовательских
    }
    // Затем ищем среди тегов команд, если указан контекст команды
    if (teamIdContext != null && _teamTagsByTeamId.containsKey(teamIdContext)) {
      try {
        return _teamTagsByTeamId[teamIdContext]!.firstWhere((tag) => tag.id == id && tag.type == 'team');
      } catch (e) {
        // Не найдено и среди тегов этой команды
      }
    }
    return null;
  }

  List<ApiTag> getTagsForTaskContext({String? teamIdStr}) {
    List<ApiTag> availableTags = List.from(_userTags);
    if (teamIdStr != null) {
      final teamId = int.tryParse(teamIdStr);
      if (teamId != null && _teamTagsByTeamId.containsKey(teamId)) {
        availableTags.addAll(_teamTagsByTeamId[teamId]!);
      }
    }
    availableTags.sort((a,b) => a.name.compareTo(b.name));
    return availableTags;
  }


  void clearError() {
    if (_error != null) {
      _error = null;
      notifyListeners();
    }
  }

  @override
  void dispose() {
    _authState.removeListener(_onAuthStateChanged);
    super.dispose();
  }
}
```

```
// lib/sidebar_state_provider.dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SidebarStateProvider with ChangeNotifier {
  bool _isCollapsed = false;
  static const String _sidebarCollapsedKey = 'sidebar_collapsed_state_v1';

  SidebarStateProvider() {
    _loadState();
  }

  bool get isCollapsed => _isCollapsed;

  Future<void> _loadState() async {
    final prefs = await SharedPreferences.getInstance();
    _isCollapsed = prefs.getBool(_sidebarCollapsedKey) ?? false; // По умолчанию развернут
    notifyListeners(); // Уведомить слушателей после загрузки
  }

  Future<void> _saveState() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_sidebarCollapsedKey, _isCollapsed);
  }

  void toggleCollapse() {
    _isCollapsed = !_isCollapsed;
    _saveState();
    notifyListeners();
  }

  // Если нужно установить состояние извне (редко, но возможно)
  void setCollapsedState(bool collapsed) {
    if (_isCollapsed != collapsed) {
      _isCollapsed = collapsed;
      _saveState();
      notifyListeners();
    }
  }
}
```

```
// lib/main.dart
import 'dart:io';
import 'package:flutter/foundation.dart' show kDebugMode, kIsWeb, defaultTargetPlatform;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'core/routing/app_route_path.dart';
import 'theme_provider.dart';
import 'tag_provider.dart';
import 'task_provider.dart';
import 'sidebar_state_provider.dart';
import 'core/routing/app_route_information_parser.dart';
import 'core/routing/app_router_delegate.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'auth_state.dart';
import 'deleted_tasks_provider.dart';
import 'dart:async';

import 'services/api_service.dart';
import 'html_stub.dart' if (dart.library.html) 'dart:html' as html_lib;

// --- ДОБАВЛЕНО: Импорты для локализации ---
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/date_symbol_data_local.dart';
// --- КОНЕЦ ДОБАВЛЕННЫХ ИМПОРТОВ ---

class MyHttpOverrides extends HttpOverrides {
  @override
  HttpClient createHttpClient(SecurityContext? context) {
    return super.createHttpClient(context)
      ..badCertificateCallback =
          (X509Certificate cert, String host, int port) {
        final allowedHosts = ['localhost', '10.0.2.2'];
        return allowedHosts.contains(host) && port == 8080;
      };
  }
}

void main() async { // Убедитесь, что main - async
  WidgetsFlutterBinding.ensureInitialized();

  // --- ДОБАВЛЕНО: Инициализация данных для форматирования дат ПЕРЕД runApp ---
  await initializeDateFormatting('ru_RU', null);
  // --- КОНЕЦ ДОБАВЛЕННОЙ ИНИЦИАЛИЗАЦИИ ---

  if (kDebugMode && !kIsWeb) {
    HttpOverrides.global = MyHttpOverrides();
    debugPrint("HttpOverrides for self-signed certs enabled for debug mode on non-web platforms.");
  }

  usePathUrlStrategy();

  if (!kIsWeb) {
    if (defaultTargetPlatform == TargetPlatform.android || defaultTargetPlatform == TargetPlatform.iOS) {
      try {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.portraitUp,
          DeviceOrientation.portraitDown,
        ]);
      } catch (e) {
        // ignore: avoid_print
        print("Could not set preferred orientations: $e");
      }
    }
  }

  final ApiService apiService = ApiService();
  final AuthState authState = AuthState(apiService: apiService);
  final AppRouterDelegate routerDelegate = AppRouterDelegate(authState: authState);

  runApp(
    MultiProvider(
      providers: [
        Provider.value(value: apiService),
        ChangeNotifierProvider.value(value: authState),
        ChangeNotifierProvider.value(value: routerDelegate),
        ChangeNotifierProvider(create: (_) => ThemeProvider()),
        ChangeNotifierProvider(
          create: (context) => TagProvider(
            Provider.of<ApiService>(context, listen: false),
            Provider.of<AuthState>(context, listen: false),
          ),
        ),
        ChangeNotifierProvider(
          create: (context) => TaskProvider(
            Provider.of<ApiService>(context, listen: false),
            Provider.of<AuthState>(context, listen: false),
          ),
        ),
        ChangeNotifierProvider(create: (_) => SidebarStateProvider()),
        ChangeNotifierProvider(create: (_) => DeletedTasksProvider()),
      ],
      child: MyApp(routerDelegate: routerDelegate),
    ),
  );
}

class MyApp extends StatefulWidget {
  final AppRouterDelegate routerDelegate;

  const MyApp({super.key, required this.routerDelegate});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final AppRouteInformationParser _routeInformationParser = AppRouteInformationParser();
  StreamSubscription? _uriLinkSubscription;

  @override
  void initState() {
    super.initState();

    if (kIsWeb) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          _handleInitialWebUri();
        }
      });
      _uriLinkSubscription = html_lib.window.onPopState.listen((event) {
        if (mounted) {
          _handleWebUri(Uri.tryParse(html_lib.window.location.href));
        }
      });
    }
  }

  void _handleInitialWebUri() {
    if (!kIsWeb || !mounted) return;
    try {
      final initialUri = Uri.tryParse(html_lib.window.location.href);
      _handleWebUri(initialUri);
    } catch (e) {
      debugPrint("_MyAppState: Error processing initial web URI: $e");
    }
  }

  void _handleWebUri(Uri? uri) {
    if (uri == null || !kIsWeb || !mounted) return;

    debugPrint("_MyAppState: Handling WEB URI: $uri");
    final authState = widget.routerDelegate.authState;
    bool handledOAuthRedirect = false;

    const String frontendSuccessPathSuffix = 'oauth-callback-success';
    const String frontendErrorPathSuffix = 'oauth-callback-error';

    if (uri.pathSegments.isNotEmpty && uri.pathSegments.last == frontendSuccessPathSuffix) {
      debugPrint("_MyAppState: OAuth success redirect detected: $uri");
      authState.handleOAuthCallback(uri);
      handledOAuthRedirect = true;
    } else if (uri.pathSegments.isNotEmpty && uri.pathSegments.last == frontendErrorPathSuffix) {
      final errorParam = uri.queryParameters['error_description'] ?? uri.queryParameters['error'] ?? 'unknown_oauth_error';
      final providerParam = uri.queryParameters['provider'] ?? 'unknown_provider';
      debugPrint("_MyAppState: OAuth error redirect detected: $uri, error: $errorParam, provider: $providerParam");
      authState.setOAuthError("Ошибка аутентификации через $providerParam: $errorParam");
      handledOAuthRedirect = true;
    }

    if (handledOAuthRedirect) {
      try {
        html_lib.window.history.replaceState(null, '', '/');
        debugPrint("_MyAppState: Cleared OAuth params from URL, effectively navigating to '/' for router to re-evaluate.");
      } catch (e) {
        debugPrint("_MyAppState: Error clearing/replacing URI after OAuth: $e");
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          widget.routerDelegate.setNewRoutePath(const AuthPath());
          widget.routerDelegate.notifyListeners();
        }
      });
    }
  }

  @override
  void dispose() {
    _uriLinkSubscription?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<ThemeProvider>(
      builder: (context, themeProvider, _) {
        final ThemeData currentTheme = themeProvider.currentTheme;
        final ColorScheme colorScheme = currentTheme.colorScheme;

        SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
          statusBarColor: currentTheme.appBarTheme.backgroundColor ?? colorScheme.surface,
          statusBarIconBrightness: colorScheme.brightness == Brightness.dark ? Brightness.light : Brightness.dark,
          statusBarBrightness: colorScheme.brightness,
          systemNavigationBarColor: currentTheme.bottomNavigationBarTheme.backgroundColor ?? colorScheme.surface,
          systemNavigationBarDividerColor: currentTheme.dividerColor,
          systemNavigationBarIconBrightness: colorScheme.brightness == Brightness.dark ? Brightness.light : Brightness.dark,
        ));

        return MaterialApp.router(
          title: 'Todo App',
          theme: currentTheme,
          routerDelegate: widget.routerDelegate,
          routeInformationParser: _routeInformationParser,
          debugShowCheckedModeBanner: false,
          // --- ДОБАВЛЕНО: Настройки локализации ---
          localizationsDelegates: const [
            GlobalMaterialLocalizations.delegate,
            GlobalWidgetsLocalizations.delegate,
            GlobalCupertinoLocalizations.delegate,
          ],
          supportedLocales: const [
            Locale('ru', 'RU'), // Русский
            Locale('en', ''),    // Английский (как fallback)
          ],
          locale: const Locale('ru', 'RU'), // Установка русской локали по умолчанию
          // --- КОНЕЦ ДОБАВЛЕННЫХ НАСТРОЕК ---
        );
      },
    );
  }
}
```

```
// lib/html_stub.dart

// Этот файл-заглушка используется, когда dart:html недоступен (например, на мобильных платформах).
// Он должен экспортировать те же имена, что и dart:html, которые используются в вашем коде,
// но с реализацией, которая не вызывает ошибок.

// Заглушка для html.window
// Нам нужны поля history, onPopState, location
// В реальных не-веб сценариях эти методы не будут вызываться благодаря проверке kIsWeb.
// Но для компиляции они должны существовать.

import 'dart:async';

class _LocationStub {
  String get href => ''; // Пустая строка или осмысленное значение по умолчанию
}

class _HistoryStub {
  void replaceState(dynamic data, String title, String? url) {
    // Ничего не делаем
  }
}

class _WindowStub {
  StreamController<dynamic> _onPopStateController = StreamController.broadcast();
  Stream<dynamic> get onPopState => _onPopStateController.stream;

  final _LocationStub location = _LocationStub();
  final _HistoryStub history = _HistoryStub();

  // Можно добавить другие методы/поля, если они используются, например:
  // void open(String url, String name, [String? options]) { /* ... */ }

  void close() { // Метод для закрытия StreamController, если он больше не нужен
    _onPopStateController.close();
  }
}

// Экспортируем экземпляр заглушки как 'window'
final _WindowStub window = _WindowStub();

// Если ты используешь другие части dart:html, их тоже нужно будет здесь "заглушить".
// Например, если бы ты использовал html.document:
// class _DocumentStub { ... }
// final _DocumentStub document = _DocumentStub();
```

```
// lib/deleted_tasks_provider.dart
import 'package:flutter/foundation.dart';
import 'models/task_model.dart';
// import 'package:shared_preferences/shared_preferences.dart'; // Для сохранения в будущем
// import 'dart:convert'; // Для сохранения в будущем

class DeletedTasksProvider extends ChangeNotifier {
  List<Task> _deletedTasks = [];

  // TODO: В будущем загружать из SharedPreferences
  // DeletedTasksProvider() {
  //   _loadDeletedTasks();
  // }

  List<Task> get deletedTasks {
    // Сортировка по дате удаления (новые вверху)
    _deletedTasks.sort((a, b) => (b.deletedAt ?? DateTime(0)).compareTo(a.deletedAt ?? DateTime(0)));
    return List.unmodifiable(_deletedTasks);
  }

  void moveToTrash(Task task, {String? deletedByUserId}) {
    // Убедимся, что задача еще не в корзине
    if (_deletedTasks.any((t) => t.taskId == task.taskId)) return;

    final taskForTrash = task.copyWith(
      deletedAt: DateTime.now(),
      deletedByUserId: deletedByUserId,
    );
    _deletedTasks.add(taskForTrash);
    // _saveDeletedTasks(); // TODO: Сохранять в SharedPreferences
    notifyListeners();
  }

  void restoreFromTrash(String taskId) {
    final taskToRestore = _deletedTasks.firstWhere((t) => t.taskId == taskId, orElse: () => throw Exception("Task not found in trash"));
    _deletedTasks.removeWhere((t) => t.taskId == taskId);

    // Здесь в реальном приложении нужно будет уведомить другой провайдер (например, TaskProvider)
    // чтобы он добавил задачу обратно в активные списки.
    // Пока что задача просто удаляется из корзины.
    // Для восстановления в UI, экран, который отображает активные задачи,
    // должен будет ее снова добавить (например, если TaskProvider будет управлять всеми задачами).

    // _saveDeletedTasks(); // TODO: Сохранять в SharedPreferences
    notifyListeners();

    // Возвращаем восстановленную задачу, чтобы ее можно было обработать дальше
    // (например, добавить обратно в список активных задач в UI, если нет центрального TaskProvider)
    // return taskToRestore.copyWith(deletedAtIsNull: true, deletedByUserIdIsNull: true);
  }

  Task getTaskById(String taskId) {
    return _deletedTasks.firstWhere((t) => t.taskId == taskId, orElse: () => throw Exception("Task not found in trash with ID: $taskId"));
  }

  void deletePermanently(String taskId) {
    _deletedTasks.removeWhere((t) => t.taskId == taskId);
    // _saveDeletedTasks(); // TODO: Сохранять в SharedPreferences
    notifyListeners();
  }

// Примерные методы для сохранения/загрузки (нужно доработать Task.toJson/fromJson)
/*
  Future<void> _saveDeletedTasks() async {
    final prefs = await SharedPreferences.getInstance();
    List<String> tasksJson = _deletedTasks.map((task) => jsonEncode(task.toJson())).toList(); // Предполагая, что есть toJson()
    await prefs.setStringList('deleted_tasks', tasksJson);
  }

  Future<void> _loadDeletedTasks() async {
    final prefs = await SharedPreferences.getInstance();
    List<String>? tasksJson = prefs.getStringList('deleted_tasks');
    if (tasksJson != null) {
      _deletedTasks = tasksJson.map((json) => Task.fromJson(jsonDecode(json))).toList(); // Предполагая, что есть fromJson()
      notifyListeners();
    }
  }
  */
}
```

```
// lib/auth_state.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io' show HttpServer, Platform;

import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:shelf/shelf.dart' as shelf;
import 'package:shelf/shelf_io.dart' as shelf_io;
import 'package:shelf_router/shelf_router.dart' as shelf_router;

import 'services/api_service.dart';

class AuthState extends ChangeNotifier {
  final ApiService _apiService;
  final FlutterSecureStorage _secureStorage = const FlutterSecureStorage();

  static const String _refreshTokenKeySecure = 'app_refresh_token_secure_v1';

  bool _isLoggedIn = false;
  bool _isLoading = false;
  String? _errorMessage;
  UserProfile? _currentUser;
  String? _emailPendingConfirmation;
  String? _oauthErrorMessage;

  StreamController<String?> _oauthRedirectControllerWeb = StreamController.broadcast();
  Stream<String?> get oauthRedirectStreamWeb => _oauthRedirectControllerWeb.stream;

  HttpServer? _nativeOAuthHttpServer;
  static const int _nativeOAuthPort = 8989;
  String get nativeClientLandingUri => 'http://127.0.0.1:$_nativeOAuthPort/native-oauth-landing';
  Completer<bool>? _nativeOAuthCompleter;

  bool get isLoggedIn => _isLoggedIn;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  UserProfile? get currentUser => _currentUser;
  String? get emailPendingConfirmation => _emailPendingConfirmation;
  String? get oauthErrorMessage => _oauthErrorMessage;

  AuthState({required ApiService apiService}) : _apiService = apiService {
    _checkInitialAuthStatus();
  }

  Future<void> _checkInitialAuthStatus() async {
    _isLoading = true;
    _emailPendingConfirmation = null;
    _oauthErrorMessage = null;

    bool loginAttempted = false;
    bool finalLoginSuccess = false;

    try {
      debugPrint("AuthState (_checkInitialAuthStatus): Attempting to get user profile with existing access token (if any).");
      final user = await _apiService.getUserProfile();
      _currentUser = user;
      _isLoggedIn = true;
      _errorMessage = null;
      loginAttempted = true;
      finalLoginSuccess = true;
      debugPrint("AuthState (_checkInitialAuthStatus): Success with existing access token. User: ${_currentUser?.toJson()}");
    } on ApiException catch (e) {
      loginAttempted = true;
      if (e.statusCode == 401) {
        debugPrint("AuthState (_checkInitialAuthStatus): Access token invalid/missing (401). Attempting refresh.");
        bool refreshed = false;
        if (kIsWeb) {
          refreshed = await _apiService.tryRefreshTokenForWeb();
        } else {
          final storedRefreshToken = await _secureStorage.read(key: _refreshTokenKeySecure);
          if (storedRefreshToken != null) {
            debugPrint("AuthState (_checkInitialAuthStatus): Found native refresh token, trying to refresh.");
            final Map<String, String?>? newTokens = await _apiService.tryRefreshTokenForNative(storedRefreshToken);
            if (newTokens != null && newTokens['access_token'] != null) {
              await _apiService.saveAccessTokenForNative(newTokens['access_token']!);
              if (newTokens['refresh_token'] != null && newTokens['refresh_token']!.isNotEmpty) {
                await _secureStorage.write(key: _refreshTokenKeySecure, value: newTokens['refresh_token']!);
                debugPrint("AuthState (_checkInitialAuthStatus): Native refresh token updated.");
              } else {
                debugPrint("AuthState (_checkInitialAuthStatus): Native access token refreshed, existing RT remains (or was not returned).");
              }
              refreshed = true;
            } else {
              debugPrint("AuthState (_checkInitialAuthStatus): Native refresh token failed. Clearing stored invalid RT.");
              await _secureStorage.delete(key: _refreshTokenKeySecure);
            }
          } else {
            debugPrint("AuthState (_checkInitialAuthStatus): No native refresh token found for refresh attempt.");
          }
        }

        if (refreshed) {
          try {
            debugPrint("AuthState (_checkInitialAuthStatus): Tokens refreshed, re-attempting get user profile.");
            final user = await _apiService.getUserProfile();
            _currentUser = user;
            _isLoggedIn = true;
            _errorMessage = null;
            finalLoginSuccess = true;
            debugPrint("AuthState (_checkInitialAuthStatus): Success after token refresh. User: ${_currentUser?.toJson()}");
          } catch (profileError) {
            _errorMessage = "Ошибка загрузки профиля после обновления токена: $profileError";
            debugPrint("AuthState (_checkInitialAuthStatus): Failed to get profile after token refresh: $profileError");
          }
        } else {
          debugPrint("AuthState (_checkInitialAuthStatus): Token refresh failed or not attempted (e.g. no RT).");
        }
      } else {
        _errorMessage = "Не удалось проверить сессию: ${e.message}";
        debugPrint("AuthState (_checkInitialAuthStatus): API Exception ${e.statusCode}: ${e.message}");
      }
    } on NetworkException catch (e) {
      loginAttempted = true;
      _errorMessage = e.message;
      debugPrint("AuthState (_checkInitialAuthStatus): Network Exception: ${e.message}");
    } catch (e) {
      loginAttempted = true;
      _errorMessage = "Неизвестная ошибка при проверке сессии: $e";
      debugPrint("AuthState (_checkInitialAuthStatus): Unknown error: $e");
    }

    if (!finalLoginSuccess) {
      _isLoggedIn = false;
      _currentUser = null;
      await _apiService.clearLocalAccessToken();
      if (loginAttempted) {
        debugPrint("AuthState (_checkInitialAuthStatus): Login attempt failed. User is logged out.");
      } else {
        debugPrint("AuthState (_checkInitialAuthStatus): No login attempt made (e.g. first launch without tokens). User is logged out.");
      }
    }

    if (_isLoggedIn && _currentUser != null) {
      _applyProfileUISettings(_currentUser!);
    }

    _isLoading = false;
    // >>> DEBUG PRINT
    debugPrint("AuthState (_checkInitialAuthStatus) FINISHING: isLoggedIn: $_isLoggedIn, currentUser: ${_currentUser?.toJson()}, error: $_errorMessage");
    notifyListeners();
  }

  Future<void> checkInitialAuthStatusAgain() async {
    debugPrint("AuthState: Manually re-checking initial auth status via checkInitialAuthStatusAgain().");
    await _checkInitialAuthStatus();
  }

  void _applyProfileUISettings(UserProfile profile) {
    debugPrint("AuthState (_applyProfileUISettings): Applying UI settings from profile (login: ${profile.login}, email: ${profile.email}). UserID: ${profile.userId}");
  }

  Future<bool> signUp({
    required String email, String? login, required String password,
  }) async {
    _isLoading = true; _errorMessage = null; _oauthErrorMessage = null; _emailPendingConfirmation = null; notifyListeners();
    try {
      await _apiService.signUp(email: email, login: login, password: password);
      _emailPendingConfirmation = email;
      _isLoading = false;
      debugPrint("AuthState (signUp) FINISHING: emailPendingConfirmation: $_emailPendingConfirmation");
      notifyListeners();
      return true;
    } on ApiException catch (e) { _errorMessage = e.message;
    } on NetworkException catch (e) { _errorMessage = e.message;
    } catch (e) { _errorMessage = 'Неизвестная ошибка при регистрации: ${e.toString()}'; }
    _isLoading = false;
    debugPrint("AuthState (signUp) FAILED: error: $_errorMessage");
    notifyListeners();
    return false;
  }

  Future<bool> signIn({
    required String password, String? emailOrLogin,
  }) async {
    _isLoading = true; _errorMessage = null; _oauthErrorMessage = null; _emailPendingConfirmation = null; notifyListeners();
    String? emailValue; String? loginStr;
    if (emailOrLogin != null && emailOrLogin.isNotEmpty) {
      if (emailOrLogin.contains('@')) emailValue = emailOrLogin; else loginStr = emailOrLogin;
    }

    try {
      final authResponse = await _apiService.signIn(email: emailValue, login: loginStr, password: password);

      if (!kIsWeb && authResponse.refreshToken != null && authResponse.refreshToken!.isNotEmpty) {
        await _secureStorage.write(key: _refreshTokenKeySecure, value: authResponse.refreshToken!);
        debugPrint("AuthState (signIn): Native refresh token saved from signIn API response.");
      }

      final user = await _apiService.getUserProfile();
      _currentUser = user;
      _isLoggedIn = true;
      _errorMessage = null;
      _emailPendingConfirmation = null;

      if (_isLoggedIn && _currentUser != null) {
        _applyProfileUISettings(_currentUser!);
      } else {
        _isLoggedIn = false;
        _currentUser = null;
        _errorMessage = "Не удалось получить данные пользователя после входа.";
      }
    } on EmailNotConfirmedException catch (e) {
      _errorMessage = e.message;
      _emailPendingConfirmation = emailValue ?? ( (emailOrLogin!=null && emailOrLogin.contains("@")) ? emailOrLogin : null);
      _isLoggedIn = false; _currentUser = null;
    } on ApiException catch (e) {
      _errorMessage = e.message;
      _isLoggedIn = false; _currentUser = null;
    } on NetworkException catch (e) {
      _errorMessage = e.message;
      _isLoggedIn = false; _currentUser = null;
    } catch (e) {
      _errorMessage = 'Неизвестная ошибка при входе: ${e.toString()}';
      _isLoggedIn = false; _currentUser = null;
    }

    _isLoading = false;
    // >>> DEBUG PRINT
    debugPrint("AuthState (signIn) FINISHING: isLoggedIn: $_isLoggedIn, currentUser: ${_currentUser?.toJson()}, error: $_errorMessage, emailPending: $_emailPendingConfirmation");
    notifyListeners();
    return _isLoggedIn;
  }

  Future<void> logout() async {
    _isLoading = true;
    _errorMessage = null;
    _oauthErrorMessage = null;
    _emailPendingConfirmation = null;
    notifyListeners();

    try {
      await _apiService.logout();
    } catch (e) {
      debugPrint("AuthState (logout): Error calling API logout (ignored): $e");
    } finally {
      _isLoggedIn = false;
      _currentUser = null;
      _isLoading = false;
      debugPrint("AuthState (logout): User logged out. Local state cleared.");
      notifyListeners();
    }
  }

  Future<void> initiateOAuth(String provider) async {
    _isLoading = true; _oauthErrorMessage = null; _errorMessage = null; _emailPendingConfirmation = null; notifyListeners();
    String backendInitiationUrl = _apiService.getOAuthUrl(provider);

    if (kIsWeb) {
      debugPrint('AuthState (initiateOAuth): Web. URL: $backendInitiationUrl');
      _oauthRedirectControllerWeb.add(backendInitiationUrl);
    } else {
      backendInitiationUrl += '?native_final_redirect_uri=${Uri.encodeComponent(nativeClientLandingUri)}';
      debugPrint('AuthState (initiateOAuth): Native. Backend URL: $backendInitiationUrl. Landing: $nativeClientLandingUri');
      _nativeOAuthCompleter = Completer<bool>();
      try {
        await _startNativeOAuthHttpServer();
        final uri = Uri.parse(backendInitiationUrl);
        if (await canLaunchUrl(uri)) {
          await launchUrl(uri, mode: LaunchMode.externalApplication);
        } else {
          throw Exception('Could not launch $uri for provider $provider');
        }
        bool success = await _nativeOAuthCompleter!.future;
        if (!success && _oauthErrorMessage == null) {
          _oauthErrorMessage = "Авторизация через $provider не была завершена или была ошибка.";
        }
      } catch (e) {
        _oauthErrorMessage = "Ошибка запуска OAuth $provider: $e";
        if (!(_nativeOAuthCompleter?.isCompleted == true)) _nativeOAuthCompleter?.complete(false);
      } finally {
        await _stopNativeOAuthHttpServer();
        _nativeOAuthCompleter = null;
        _isLoading = false;
        notifyListeners();
      }
    }
  }

  Future<void> _startNativeOAuthHttpServer() async {
    if (_nativeOAuthHttpServer != null) await _stopNativeOAuthHttpServer();
    try {
      final router = shelf_router.Router();
      router.get('/native-oauth-landing', _nativeOAuthLandingHandler);
      final handler = const shelf.Pipeline().addHandler(router.call);
      _nativeOAuthHttpServer = await shelf_io.serve(handler, '127.0.0.1', _nativeOAuthPort);
      debugPrint('AuthState (_startNativeOAuthHttpServer): Server started on 127.0.0.1:${_nativeOAuthHttpServer?.port}');
    } catch (e) {
      _oauthErrorMessage = "Не удалось запустить сервер для OAuth: $e";
      if (!(_nativeOAuthCompleter?.isCompleted == true)) _nativeOAuthCompleter?.complete(false);
      rethrow;
    }
  }

  Future<void> _stopNativeOAuthHttpServer() async {
    if (_nativeOAuthHttpServer != null) {
      await _nativeOAuthHttpServer!.close(force: true);
      _nativeOAuthHttpServer = null;
      debugPrint('AuthState (_stopNativeOAuthHttpServer): Server stopped.');
    }
    if (_nativeOAuthCompleter != null && !_nativeOAuthCompleter!.isCompleted) {
      _nativeOAuthCompleter!.complete(false);
    }
  }

  Future<shelf.Response> _nativeOAuthLandingHandler(shelf.Request request) async {
    debugPrint('AuthState (_nativeOAuthLandingHandler): Received: ${request.requestedUri}');
    bool success = false;
    String responseMessage = "Ошибка авторизации. Пожалуйста, попробуйте снова. Можете закрыть эту вкладку.";

    try {
      final accessToken = request.requestedUri.queryParameters['access_token'];
      final refreshToken = request.requestedUri.queryParameters['refresh_token'];
      final providerFromQuery = request.requestedUri.queryParameters['provider'] ?? "неизвестного провайдера";
      final errorParam = request.requestedUri.queryParameters['error'];
      final errorDescriptionParam = request.requestedUri.queryParameters['error_description'];

      if (errorParam != null || errorDescriptionParam != null) {
        _oauthErrorMessage = "Ошибка OAuth от $providerFromQuery: ${errorDescriptionParam ?? errorParam}";
        responseMessage = 'Ошибка авторизации: ${errorDescriptionParam ?? errorParam}. Можете закрыть эту вкладку.';
      } else if (accessToken != null && accessToken.isNotEmpty) {
        await _apiService.saveAccessTokenForNative(accessToken);
        debugPrint('AuthState (_nativeOAuthLandingHandler): Access token saved.');
        if (refreshToken != null && refreshToken.isNotEmpty) {
          await _secureStorage.write(key: _refreshTokenKeySecure, value: refreshToken);
          debugPrint('AuthState (_nativeOAuthLandingHandler): Native refresh token saved to secure storage.');
        } else {
          debugPrint('AuthState (_nativeOAuthLandingHandler): Refresh token not found/empty in callback for native client.');
        }
        await _checkInitialAuthStatus();

        if (_isLoggedIn) {
          _oauthErrorMessage = null;
          success = true;
          responseMessage = 'Авторизация успешна! Можете вернуться в приложение.';
        } else {
          _oauthErrorMessage = _errorMessage ?? "Не удалось войти после OAuth через $providerFromQuery.";
          responseMessage = _oauthErrorMessage ?? 'Ошибка входа после OAuth. Можете закрыть эту вкладку.';
        }
      } else {
        _oauthErrorMessage = "Токены не найдены в URL после OAuth через $providerFromQuery.";
        responseMessage = 'Ошибка авторизации: токены не предоставлены. Можете закрыть эту вкладку.';
      }
    } catch (e) {
      _oauthErrorMessage = "Внутренняя ошибка обработки OAuth: $e";
      responseMessage = 'Внутренняя ошибка сервера. Можете закрыть эту вкладку.';
    } finally {
      if (!(_nativeOAuthCompleter?.isCompleted == true)) {
        _nativeOAuthCompleter?.complete(success);
      }
    }
    return shelf.Response.ok(responseMessage, headers: {'content-type': 'text/html; charset=utf-8'});
  }

  Future<void> handleOAuthCallback(Uri uri) async {
    debugPrint("AuthState (handleOAuthCallback Web): URI: $uri. Calling _checkInitialAuthStatus to finalize login.");
    await _checkInitialAuthStatus();
  }

  Future<bool> sendConfirmationEmail(String email) async {
    _isLoading = true; _errorMessage = null; _oauthErrorMessage = null; notifyListeners();
    try {
      await _apiService.sendConfirmationEmail(email);
      _isLoading = false; notifyListeners(); return true;
    } on ApiException catch (e) { _errorMessage = e.message;
    } on NetworkException catch (e) { _errorMessage = e.message;
    } catch (e) { _errorMessage = 'Ошибка отправки кода: ${e.toString()}'; }
    _isLoading = false; notifyListeners(); return false;
  }

  Future<bool> confirmEmail(String email, String code) async {
    _isLoading = true; _errorMessage = null; _oauthErrorMessage = null; notifyListeners();
    try {
      await _apiService.confirmEmail(email, code);
      _emailPendingConfirmation = null;
      _isLoading = false; notifyListeners(); return true;
    } on ApiException catch (e) { _errorMessage = e.message;
    } on NetworkException catch (e) { _errorMessage = e.message;
    } catch (e) { _errorMessage = 'Ошибка подтверждения email: ${e.toString()}'; }
    _isLoading = false; notifyListeners(); return false;
  }

  Future<bool> updateUserProfile({
    String? login, String? theme, String? accentColor,
    bool? isSidebarCollapsed, bool? resetAvatar, Map<String, dynamic>? avatarFile
  }) async {
    if (!_isLoggedIn || _currentUser == null) {
      _errorMessage = "Пользователь не авторизован для обновления профиля.";
      notifyListeners();
      return false;
    }
    // bool operationLoading = true; // Заменено на глобальный _isLoading для простоты, можно вернуть если нужно
    _isLoading = true;
    String? operationError; // Переименовал, чтобы не конфликтовать с _errorMessage
    _errorMessage = null; // Сбрасываем основную ошибку перед операцией
    notifyListeners();

    try {
      final updatedProfile = await _apiService.updateUserProfile(
          login: login, theme: theme, accentColor: accentColor,
          isSidebarCollapsed: isSidebarCollapsed, resetAvatar: resetAvatar, avatarFile: avatarFile
      );
      _currentUser = updatedProfile;
      _applyProfileUISettings(updatedProfile);
      // _errorMessage = null; // Уже сброшено выше
      _isLoading = false; // operationLoading = false;
      debugPrint("AuthState (updateUserProfile) SUCCESS: currentUser: ${_currentUser?.toJson()}");
      notifyListeners();
      return true;
    } on ApiException catch (e) { operationError = e.message;
    } on NetworkException catch (e) { operationError = e.message;
    } catch (e) { operationError = 'Ошибка обновления профиля: ${e.toString()}'; }

    _errorMessage = operationError;
    _isLoading = false; // operationLoading = false;
    debugPrint("AuthState (updateUserProfile) FAILED: error: $_errorMessage");
    notifyListeners();
    return false;
  }

  Future<bool> deleteUserAccount() async {
    if (!_isLoggedIn) return false;
    _isLoading = true; _errorMessage = null; _oauthErrorMessage = null; notifyListeners();
    try {
      await _apiService.deleteUserAccount();
      _isLoggedIn = false;
      _currentUser = null;
      _emailPendingConfirmation = null;
      _isLoading = false;
      notifyListeners();
      return true;
    } on ApiException catch (e) { _errorMessage = e.message;
    } on NetworkException catch (e) { _errorMessage = e.message;
    } catch (e) { _errorMessage = 'Ошибка удаления аккаунта: ${e.toString()}'; }
    _isLoading = false; notifyListeners(); return false;
  }

  void clearErrorMessage() { if (_errorMessage != null) { _errorMessage = null; notifyListeners(); } }
  void clearOAuthError() { if (_oauthErrorMessage != null) { _oauthErrorMessage = null; notifyListeners(); } }
  void setOAuthError(String error) { _oauthErrorMessage = error; _errorMessage = null; _emailPendingConfirmation = null; _isLoading = false; notifyListeners(); }
  void clearEmailPendingConfirmation() { if (_emailPendingConfirmation != null) { _emailPendingConfirmation = null; notifyListeners(); } }
  void setEmailPendingConfirmation(String? email) { if (_emailPendingConfirmation != email) { _emailPendingConfirmation = email; notifyListeners(); } }

  @override
  void dispose() {
    _oauthRedirectControllerWeb.close();
    _stopNativeOAuthHttpServer();
    super.dispose();
  }
}
```

```
// lib/widgets/PrimaryButton.dart  (Убедись, что имя файла именно такое)
import 'package:flutter/material.dart';
import '../core/utils/responsive_utils.dart';

class PrimaryButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed; // Может быть null, если isLoading = true
  final double desktopHeight;
  final bool isLoading;
  final ButtonStyle? style; // Возможность передать кастомный стиль поверх темы

  const PrimaryButton({
    super.key,
    required this.text,
    this.onPressed, // Изменено: onPressed теперь может быть null напрямую
    this.desktopHeight = 43,
    this.isLoading = false,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final elevButtonStyle = theme.elevatedButtonTheme.style;

    final double currentHeight = ResponsiveUtil.isMobile(context) ? 48 : desktopHeight;

    final Color effectiveForegroundColor = isLoading
        ? elevButtonStyle?.foregroundColor?.resolve({MaterialState.disabled}) ?? colorScheme.onSurface.withOpacity(0.38)
        : elevButtonStyle?.foregroundColor?.resolve({}) ?? colorScheme.onPrimary;

    final ButtonStyle finalButtonStyle = (elevButtonStyle ?? const ButtonStyle())
        .merge(style)
        .copyWith(
      minimumSize: MaterialStateProperty.all(Size.fromHeight(currentHeight)),
    );

    return SizedBox(
      height: currentHeight,
      width: double.infinity,
      child: ElevatedButton(
        style: finalButtonStyle,
        onPressed: onPressed, // Передаем onPressed напрямую
        child: isLoading
            ? SizedBox(
          width: 20,
          height: 20,
          child: CircularProgressIndicator(
            strokeWidth: 2.5,
            valueColor: AlwaysStoppedAnimation<Color>(effectiveForegroundColor),
          ),
        )
            : Text(text),
      ),
    );
  }
}
```

```
// lib/widgets/CustomInputField.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class CustomInputField extends StatefulWidget {
  final String label;
  final bool isPassword;
  final String? Function(String?)? validator;
  final TextEditingController? controller;
  final String? initialValue; // <<< ДОБАВЛЕНО
  final TextInputAction? textInputAction;
  final FocusNode? focusNode;
  final ValueChanged<String>? onFieldSubmitted;
  final AutovalidateMode autovalidateMode;
  final String? hintText;
  final TextInputType? keyboardType;
  final List<TextInputFormatter>? inputFormatters;
  final Widget? prefixIcon;
  final bool readOnly; // <<< ДОБАВЛЕНО
  final bool? enabled; // <<< ДОБАВЛЕНО (может быть bool?, чтобы не переопределять дефолтное поведение TextFormField)
  final bool autofocus; // <<< ДОБАВЛЕНО

  const CustomInputField({
    super.key,
    required this.label,
    this.isPassword = false,
    this.validator,
    this.controller,
    this.initialValue, // <<< ДОБАВЛЕНО
    this.textInputAction,
    this.focusNode,
    this.onFieldSubmitted,
    this.autovalidateMode = AutovalidateMode.onUserInteraction,
    this.hintText,
    this.keyboardType,
    this.inputFormatters,
    this.prefixIcon,
    this.readOnly = false, // <<< ДОБАВЛЕНО (значение по умолчанию)
    this.enabled,         // <<< ДОБАВЛЕНО
    this.autofocus = false, // <<< ДОБАВЛЕНО (значение по умолчанию)
  });

  @override
  State<CustomInputField> createState() => _CustomInputFieldState();
}

class _CustomInputFieldState extends State<CustomInputField> {
  late FocusNode _focusNode;
  late TextEditingController _controller;
  bool _obscureText = false;

  @override
  void initState() {
    super.initState();
    _controller = widget.controller ?? TextEditingController(text: widget.initialValue); // <<< УЧИТЫВАЕМ initialValue
    _focusNode = widget.focusNode ?? FocusNode();
    if (widget.isPassword) {
      _obscureText = true;
    }
  }

  @override
  void didUpdateWidget(CustomInputField oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Если контроллер не предоставлен извне и initialValue изменился, обновляем текст
    if (widget.controller == null && widget.initialValue != oldWidget.initialValue) {
      // Проверяем, что текущее значение в контроллере отличается от нового initialValue,
      // чтобы не перезаписывать то, что пользователь мог уже ввести, если initialValue
      // меняется по другим причинам (хотя это редкий кейс для initialValue).
      // Более безопасный подход - избегать изменения initialValue после первого рендера,
      // а управлять значением через controller.
      if (_controller.text != widget.initialValue) {
        _controller.text = widget.initialValue ?? '';
      }
    }
    // Если используется внешний контроллер, его обновление - ответственность родительского виджета.
  }


  @override
  void dispose() {
    if (widget.focusNode == null) {
      _focusNode.dispose();
    }
    if (widget.controller == null) {
      _controller.dispose();
    }
    super.dispose();
  }

  void _togglePasswordVisibility() {
    setState(() {
      _obscureText = !_obscureText;
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return TextFormField(
      controller: _controller,
      focusNode: _focusNode,
      obscureText: _obscureText,
      keyboardType: widget.keyboardType,
      textInputAction: widget.textInputAction,
      onFieldSubmitted: widget.onFieldSubmitted,
      validator: widget.validator,
      autovalidateMode: widget.autovalidateMode,
      inputFormatters: widget.inputFormatters,
      readOnly: widget.readOnly, // <<< ИСПОЛЬЗУЕМ
      enabled: widget.enabled,   // <<< ИСПОЛЬЗУЕМ
      autofocus: widget.autofocus, // <<< ИСПОЛЬЗУЕМ
      style: TextStyle(
        fontFamily: 'Inter',
        fontWeight: FontWeight.w500,
        fontSize: 15,
        color: widget.enabled == false // Если поле отключено, делаем текст менее заметным
            ? theme.colorScheme.onSurface.withOpacity(0.6)
            : theme.colorScheme.onSurface,
      ),
      decoration: InputDecoration(
        labelText: widget.label,
        hintText: widget.hintText,
        prefixIcon: widget.prefixIcon,
        suffixIcon: widget.isPassword
            ? IconButton(
          icon: Icon(
            _obscureText ? Icons.visibility_off_outlined : Icons.visibility_outlined,
            color: theme.colorScheme.onSurfaceVariant,
            size: 22,
          ),
          onPressed: _togglePasswordVisibility,
        )
            : null,
        // Стиль для отключенного состояния
        disabledBorder: theme.inputDecorationTheme.disabledBorder ??
            theme.inputDecorationTheme.enabledBorder?.copyWith(
              borderSide: BorderSide(
                color: theme.colorScheme.onSurface.withOpacity(0.38), // Стандартный цвет для disabled
              ),
            ),
        fillColor: widget.enabled == false
            ? theme.colorScheme.onSurface.withOpacity(0.04) // Другой fillColor для disabled
            : theme.inputDecorationTheme.fillColor,
      ),
    );
  }
}
```

```
// lib/widgets/trash/deleted_task_card_widget.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../../models/task_model.dart';
import '../../deleted_tasks_provider.dart';
// import '../../tag_provider.dart'; // Раскомментируй, если будешь использовать tagProvider

class DeletedTaskCardWidget extends StatelessWidget {
  final Task task;

  const DeletedTaskCardWidget({
    Key? key,
    required this.task,
  }) : super(key: key);

  String _formatDateTime(DateTime? dateTime) {
    if (dateTime == null) return 'Не указано';
    return DateFormat('dd.MM.yyyy HH:mm').format(dateTime);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;
    final deletedTasksProvider = Provider.of<DeletedTasksProvider>(context, listen: false);

    return Card(
      elevation: 1.0,
      // Убрал vertical: 6.0 из margin, так как GridView уже дает mainAxisSpacing
      margin: const EdgeInsets.symmetric(horizontal: 0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10.0),
        side: BorderSide(color: colorScheme.outlineVariant.withOpacity(0.4), width: 0.8),
      ),
      // Оборачиваем Padding в IntrinsicHeight, чтобы Column мог корректно использовать Spacer
      // и при этом карточка не пыталась занять бесконечную высоту, если GridView этого не ограничивает.
      // Однако, GridView с childAspectRatio уже должен давать ограничения по высоте.
      // Попробуем сначала без IntrinsicHeight, так как GridView обычно сам управляет размерами дочерних элементов.
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          // mainAxisSize: MainAxisSize.min, // Убираем, чтобы Spacer работал
          children: [
            // --- Начало основного контента ---
            Text(
              task.title,
              style: textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: colorScheme.onSurface,
                decoration: TextDecoration.lineThrough,
                decorationColor: colorScheme.onSurfaceVariant.withOpacity(0.7),
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            if (task.description != null && task.description!.isNotEmpty) ...[
              const SizedBox(height: 6.0),
              // Оборачиваем описание в Flexible, если оно может быть длинным,
              // чтобы оно не выталкивало кнопки за пределы карточки.
              // Но это имеет смысл, если высота карточки фиксирована или ограничена.
              // В GridView с childAspectRatio высота элемента уже определяется.
              // Если описание будет слишком длинным для maxLines: 3, оно все равно обрежется.
              Text(
                task.description!,
                style: textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                  height: 1.3,
                  decoration: TextDecoration.lineThrough,
                  decorationColor: colorScheme.onSurfaceVariant.withOpacity(0.7),
                ),
                maxLines: 3, // Ограничиваем количество строк для описания
                overflow: TextOverflow.ellipsis,
              ),
            ],
            const SizedBox(height: 8.0),
            if (task.isTeamTask && task.teamName != null)
              Padding(
                padding: const EdgeInsets.only(bottom: 6.0),
                child: Row(
                  children: [
                    Icon(Icons.group_work_outlined, size: 15, color: colorScheme.onSurfaceVariant),
                    const SizedBox(width: 6),
                    Flexible( // Добавляем Flexible на случай длинного имени команды
                      child: Text(
                        "Команда: ${task.teamName}",
                        style: textTheme.bodySmall?.copyWith(color: colorScheme.onSurfaceVariant),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ),
            Text(
              'Удалено: ${_formatDateTime(task.deletedAt)}',
              style: textTheme.labelSmall?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.8)),
            ),
            if (task.deletedByUserId != null)
              Text(
                'Кем: ${task.deletedByUserId}',
                style: textTheme.labelSmall?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.6)),
              ),
            // --- Конец основного контента ---

            const Spacer(), // <<< ЭТОТ ВИДЖЕТ ПРИЖМЕТ ВСЕ, ЧТО НИЖЕ, К НИЗУ КАРТОЧКИ

            // const SizedBox(height: 10.0), // Можно убрать или уменьшить, Spacer даст отступ
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton.icon(
                  icon: Icon(Icons.restore_from_trash_outlined, size: 18, color: colorScheme.primary),
                  label: Text('Восстановить', style: TextStyle(color: colorScheme.primary, fontSize: 13)),
                  onPressed: () {
                    deletedTasksProvider.restoreFromTrash(task.taskId);
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Задача "${task.title}" восстановлена (из корзины)')),
                    );
                  },
                  style: TextButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    tapTargetSize: MaterialTapTargetSize.shrinkWrap, // Уменьшает область тапа до размеров кнопки
                  ),
                ),
                const SizedBox(width: 8),
                TextButton.icon(
                  icon: Icon(Icons.delete_forever_outlined, size: 18, color: colorScheme.error),
                  label: Text('Удалить навсегда', style: TextStyle(color: colorScheme.error, fontSize: 13)),
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (BuildContext dialogContext) {
                        return AlertDialog(
                          title: const Text('Удалить задачу навсегда?'),
                          content: Text('Задача "${task.title}" будет удалена без возможности восстановления.'),
                          actions: <Widget>[
                            TextButton(
                              child: const Text('Отмена'),
                              onPressed: () => Navigator.of(dialogContext).pop(),
                            ),
                            TextButton(
                              child: Text('Удалить', style: TextStyle(color: colorScheme.error, fontWeight: FontWeight.bold)),
                              onPressed: () {
                                deletedTasksProvider.deletePermanently(task.taskId);
                                Navigator.of(dialogContext).pop();
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(content: Text('Задача "${task.title}" удалена навсегда.')),
                                );
                              },
                            ),
                          ],
                        );
                      },
                    );
                  },
                  style: TextButton.styleFrom(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

```
// lib/widgets/teams/team_card_widget.dart
import 'package:flutter/material.dart';
import '../../models/team_model.dart';

class TeamCardWidget extends StatelessWidget {
  final TeamModel team;
  final VoidCallback? onTap;

  const TeamCardWidget({
    Key? key,
    required this.team,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;

    final bool hasDescription = team.description != null && team.description!.isNotEmpty;

    // Виджет для аватара/инициалов команды
    Widget avatarWidget;
    if (team.imageUrl != null && team.imageUrl!.isNotEmpty) {
      avatarWidget = CircleAvatar(
        radius: 16,
        backgroundColor: team.color.withOpacity(0.2), // Фон на случай ошибки загрузки изображения
        backgroundImage: NetworkImage(team.imageUrl!),
        // onBackgroundImageError не всегда надежно перерисовывает child немедленно.
        // CircleAvatar должен автоматически показать child, если backgroundImage не загрузится.
        child: Text( // Этот текст будет виден, если NetworkImage не загрузится
          team.name.isNotEmpty ? team.name[0].toUpperCase() : "?",
          style: TextStyle(
            color: team.color,
            fontWeight: FontWeight.bold,
            fontSize: 14,
          ),
        ),
      );
    } else {
      // Если imageUrl нет, сразу показываем инициалы
      avatarWidget = CircleAvatar(
        radius: 16,
        backgroundColor: team.color.withOpacity(0.3),
        child: Text(
          team.name.isNotEmpty ? team.name[0].toUpperCase() : "?",
          style: TextStyle(
            color: team.color,
            fontWeight: FontWeight.bold,
            fontSize: 14,
          ),
        ),
      );
    }


    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(10.0),
      hoverColor: team.color.withOpacity(0.08),
      splashColor: team.color.withOpacity(0.12),
      highlightColor: team.color.withOpacity(0.1),
      child: Container(
        padding: const EdgeInsets.all(12.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHigh,
          borderRadius: BorderRadius.circular(10.0),
          border: Border.all(color: team.color.withOpacity(0.6), width: 1.0),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.08),
              blurRadius: 6.0,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.only(top: 4.0),
                  child: Container(
                    width: 8,
                    height: 8,
                    decoration: BoxDecoration(
                      color: team.color,
                      shape: BoxShape.circle,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    team.name,
                    style: textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: colorScheme.onSurface,
                      height: 1.2,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.only(left: 8.0),
                  child: avatarWidget,
                ),
              ],
            ),
            if (hasDescription) ...[
              const SizedBox(height: 6.0),
              Text(
                team.description!,
                style: textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant.withOpacity(0.85),
                  height: 1.25,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
            const Spacer(),
            Padding(
              padding: EdgeInsets.only(top: hasDescription ? 8.0 : 4.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Row(
                    children: [
                      Icon(Icons.group_outlined, size: 16, color: colorScheme.onSurfaceVariant),
                      const SizedBox(width: 4),
                      Text(
                        '${team.memberCount} участ.',
                        style: textTheme.labelSmall?.copyWith(color: colorScheme.onSurfaceVariant),
                      ),
                    ],
                  ),
                  Text(
                    MaterialLocalizations.of(context).formatShortDate(team.createdAt),
                    style: textTheme.labelSmall?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.7)),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

```
// lib/widgets/tasks/task_edit_dialog.dart
import 'package:client/models/task_model.dart';
import 'package:client/tag_provider.dart';
import 'package:client/task_provider.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart'; // Для DateFormat
import 'package:provider/provider.dart';

import '../../auth_state.dart';

class TaskEditDialog extends StatefulWidget {
  final Task? taskToEdit;

  const TaskEditDialog({Key? key, this.taskToEdit}) : super(key: key);

  @override
  State<TaskEditDialog> createState() => _TaskEditDialogState();
}

class _TaskEditDialogState extends State<TaskEditDialog> {
  final _formKey = GlobalKey<FormState>();

  late TextEditingController _titleController;
  late TextEditingController _descriptionController;

  KanbanColumnStatus _selectedStatus = KanbanColumnStatus.todo;
  TaskPriority _selectedPriority = TaskPriority.medium;
  DateTime? _selectedDeadline;
  List<ApiTag> _selectedUserTags = [];
  List<ApiTag> _selectedTeamTags = [];

  @override
  void initState() {
    super.initState();
    _titleController = TextEditingController(text: widget.taskToEdit?.title ?? '');
    _descriptionController = TextEditingController(text: widget.taskToEdit?.description ?? '');
    _selectedStatus = widget.taskToEdit?.status ?? KanbanColumnStatus.todo;
    _selectedPriority = widget.taskToEdit?.priority ?? TaskPriority.medium;
    _selectedDeadline = widget.taskToEdit?.deadline;

    if (widget.taskToEdit != null) {
      _selectedUserTags = List<ApiTag>.from(widget.taskToEdit!.tags.where((t) => t.type == 'user'));
      _selectedTeamTags = List<ApiTag>.from(widget.taskToEdit!.tags.where((t) => t.type == 'team'));
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      final tagProvider = Provider.of<TagProvider>(context, listen: false);
      if (tagProvider.userTags.isEmpty && !tagProvider.isLoadingUserTags && tagProvider.error == null) {
        tagProvider.fetchUserTags();
      }
    });
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  Future<void> _pickDeadline(BuildContext pickerContext) async {
    final initialPickerDate = _selectedDeadline ?? DateTime.now();
    final initialPickerTime = TimeOfDay.fromDateTime(_selectedDeadline ?? DateTime(initialPickerDate.year, initialPickerDate.month, initialPickerDate.day, 12, 00));

    final DateTime? pickedDate = await showDatePicker(
      context: pickerContext,
      initialDate: initialPickerDate,
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 5)),
      locale: const Locale('ru', 'RU'),
    );

    if (!mounted) return;

    if (pickedDate != null) {
      final TimeOfDay? pickedTime = await showTimePicker(
        context: pickerContext,
        initialTime: initialPickerTime,
      );

      if (!mounted) return;

      if (pickedTime != null) {
        setState(() {
          _selectedDeadline = DateTime(
            pickedDate.year,
            pickedDate.month,
            pickedDate.day,
            pickedTime.hour,
            pickedTime.minute,
          );
        });
      } else {
        setState(() {
          _selectedDeadline = DateTime(pickedDate.year, pickedDate.month, pickedDate.day, 23, 59);
        });
      }
    }
  }

  Future<void> _saveTask() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    final taskProvider = Provider.of<TaskProvider>(context, listen: false);
    final authState = Provider.of<AuthState>(context, listen: false);

    if (authState.currentUser == null) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Ошибка: пользователь не авторизован.'), backgroundColor: Colors.red),
        );
      }
      return;
    }

    final allSelectedTags = [..._selectedUserTags, ..._selectedTeamTags];
    String? createdById = widget.taskToEdit?.createdByUserId ?? authState.currentUser!.userId.toString();

    final taskData = Task(
      taskId: widget.taskToEdit?.taskId ?? '',
      title: _titleController.text.trim(),
      description: _descriptionController.text.trim().isNotEmpty ? _descriptionController.text.trim() : null,
      status: _selectedStatus,
      priority: _selectedPriority,
      deadline: _selectedDeadline,
      tags: allSelectedTags,
      createdByUserId: createdById,
      createdAt: widget.taskToEdit?.createdAt ?? DateTime.now(),
      updatedAt: DateTime.now(),
    );

    bool success;
    String actionType = "";
    if (widget.taskToEdit == null) {
      actionType = "создана";
      success = await taskProvider.createTask(taskData);
    } else {
      actionType = "обновлена";
      success = await taskProvider.updateTask(taskData);
    }

    if (mounted) {
      if (success) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Задача "$actionType" успешно!')),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(taskProvider.error ?? 'Не удалось сохранить задачу'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final tagProvider = Provider.of<TagProvider>(context);
    final taskProvider = Provider.of<TaskProvider>(context, listen: true);

    double dialogMaxWidth = 600;
    double currentDialogWidth = MediaQuery.of(context).size.width * 0.9 < dialogMaxWidth
        ? MediaQuery.of(context).size.width * 0.9
        : dialogMaxWidth;

    bool currentIsLoading = taskProvider.isProcessingTask;

    return Builder(
        builder: (dialogBuilderContext) { // Этот context будет передан в _pickDeadline
          return AlertDialog(
            title: Text(widget.taskToEdit == null ? 'Новая задача' : 'Редактировать задачу'),
            titlePadding: const EdgeInsets.fromLTRB(24, 20, 24, 10),
            contentPadding: EdgeInsets.zero,
            actionsPadding: const EdgeInsets.fromLTRB(24, 12, 24, 16),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
            content: SizedBox(
              width: currentDialogWidth,
              height: MediaQuery.of(context).size.height * 0.75,
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Expanded(
                      child: SingleChildScrollView(
                        padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 12.0),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: <Widget>[
                            TextFormField(
                              controller: _titleController,
                              decoration: const InputDecoration(
                                labelText: 'Название задачи *',
                                border: OutlineInputBorder(),
                                hintText: 'Например, "Разработать новый модуль"',
                              ),
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'Название не может быть пустым';
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 16),
                            TextFormField(
                              controller: _descriptionController,
                              decoration: const InputDecoration(
                                labelText: 'Описание (Markdown)',
                                border: OutlineInputBorder(),
                                alignLabelWithHint: true,
                                hintText: 'Детали задачи, можно использовать **Markdown**...',
                              ),
                              maxLines: 5,
                              minLines: 3,
                            ),
                            const SizedBox(height: 16),
                            Row(
                              children: [
                                Expanded(
                                  child: DropdownButtonFormField<KanbanColumnStatus>(
                                    decoration: const InputDecoration(labelText: 'Статус', border: OutlineInputBorder()),
                                    value: _selectedStatus,
                                    items: KanbanColumnStatus.values.map((status) {
                                      return DropdownMenuItem(value: status, child: Text(status.title));
                                    }).toList(),
                                    onChanged: currentIsLoading ? null : (value) {
                                      if (value != null) setState(() => _selectedStatus = value);
                                    },
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: DropdownButtonFormField<TaskPriority>(
                                    decoration: const InputDecoration(labelText: 'Приоритет', border: OutlineInputBorder()),
                                    value: _selectedPriority,
                                    items: TaskPriority.values.map((priority) {
                                      return DropdownMenuItem(
                                        value: priority,
                                        child: Row(
                                          children: [
                                            Icon(priority.icon, size: 18,
                                              color: priority == TaskPriority.high ? colorScheme.error :
                                              priority == TaskPriority.medium ? Colors.orange.shade700 :
                                              Colors.green.shade700,
                                            ),
                                            const SizedBox(width: 8),
                                            Text(priority.name),
                                          ],
                                        ),
                                      );
                                    }).toList(),
                                    onChanged: currentIsLoading ? null : (value) {
                                      if (value != null) setState(() => _selectedPriority = value);
                                    },
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 16),
                            ListTile(
                              contentPadding: EdgeInsets.zero,
                              title: Text(_selectedDeadline == null
                                  ? 'Установить дедлайн'
                                  : 'Дедлайн: ${DateFormat('dd MMMM yyyy, HH:mm', 'ru_RU').format(_selectedDeadline!)}'),
                              trailing: Icon(Icons.calendar_today_rounded, color: colorScheme.primary),
                              onTap: currentIsLoading ? null : () => _pickDeadline(dialogBuilderContext), // Используем context от Builder
                              leading: _selectedDeadline != null
                                  ? IconButton(
                                icon: Icon(Icons.clear_rounded, color: colorScheme.onSurfaceVariant.withOpacity(0.7)),
                                tooltip: "Убрать дедлайн",
                                onPressed: currentIsLoading ? null : () => setState(() => _selectedDeadline = null),
                                padding: EdgeInsets.zero,
                                constraints: const BoxConstraints(),
                              )
                                  : const SizedBox(width: 40),
                            ),
                            const SizedBox(height: 8),
                            Divider(color: theme.dividerColor.withOpacity(0.5)),
                            const SizedBox(height: 12),
                            Text('Личные теги:', style: theme.textTheme.titleSmall),
                            const SizedBox(height: 8),
                            if (tagProvider.isLoadingUserTags && tagProvider.userTags.isEmpty)
                              const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator(strokeWidth: 2)))
                            else if (tagProvider.userTags.isEmpty)
                              const Padding(
                                padding: EdgeInsets.symmetric(vertical: 8.0),
                                child: Text('Нет доступных личных тегов. Создайте их в Настройках.', style: TextStyle(fontStyle: FontStyle.italic)),
                              )
                            else
                              AbsorbPointer(
                                absorbing: currentIsLoading,
                                child: Opacity(
                                  opacity: currentIsLoading ? 0.5 : 1.0,
                                  child: Wrap(
                                    spacing: 8.0,
                                    runSpacing: 4.0,
                                    children: tagProvider.userTags.map((tag) {
                                      final isSelected = _selectedUserTags.any((selected) => selected.id == tag.id);
                                      return FilterChip(
                                        label: Text(tag.name, style: TextStyle(
                                            color: isSelected ? (tag.displayColor.computeLuminance() > 0.5 ? Colors.black87 : Colors.white)
                                                : tag.textColorPreview
                                        )),
                                        selected: isSelected,
                                        onSelected: (bool selected) {
                                          setState(() {
                                            if (selected) {
                                              if (!_selectedUserTags.any((t) => t.id == tag.id)) {
                                                _selectedUserTags.add(tag);
                                              }
                                            } else {
                                              _selectedUserTags.removeWhere((t) => t.id == tag.id);
                                            }
                                          });
                                        },
                                        backgroundColor: tag.backgroundColorPreview.withOpacity(0.7),
                                        selectedColor: tag.displayColor,
                                        checkmarkColor: tag.displayColor.computeLuminance() > 0.5 ? Colors.black87 : Colors.white,
                                        shape: StadiumBorder(side: BorderSide(color: tag.borderColorPreview.withOpacity(isSelected ? 1 : 0.5))),
                                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
                                      );
                                    }).toList(),
                                  ),
                                ),
                              ),
                            const SizedBox(height: 24),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('Отмена'),
                onPressed: currentIsLoading ? null : () => Navigator.of(dialogBuilderContext).pop(), // Используем context от Builder
              ),
              ElevatedButton.icon(
                icon: currentIsLoading
                    ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                    : Icon(widget.taskToEdit == null ? Icons.add_task_outlined : Icons.save_alt_outlined, size: 20),
                label: Text(widget.taskToEdit == null ? 'Создать задачу' : 'Сохранить'),
                onPressed: currentIsLoading ? null : _saveTask,
                style: ElevatedButton.styleFrom(
                  backgroundColor: colorScheme.primary,
                  foregroundColor: colorScheme.onPrimary,
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                ),
              ),
            ],
          );
        }
    );
  }
}
```

```
// lib/widgets/tasks/mobile_task_list_widget.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../../models/task_model.dart';
import '../../theme_provider.dart'; // Для доступа к теме

// --- MobileTaskListItemWidget (код выше без изменений) ---
class MobileTaskListItemWidget extends StatelessWidget {
  final Task task;
  final VoidCallback? onTap;
  final Function(KanbanColumnStatus newStatus)? onStatusChanged;
  final VoidCallback? onDelete;

  const MobileTaskListItemWidget({
    Key? key,
    required this.task,
    this.onTap,
    this.onStatusChanged,
    this.onDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;
    final themeProvider = Provider.of<ThemeProvider>(context, listen: false);

    Color priorityColor;
    IconData priorityIcon;

    switch (task.priority) {
      case TaskPriority.high:
        priorityColor = colorScheme.error;
        priorityIcon = Icons.keyboard_double_arrow_up_rounded;
        break;
      case TaskPriority.medium:
        priorityColor = themeProvider.isEffectivelyDark ? Colors.orange.shade300 : Colors.orange.shade800;
        priorityIcon = Icons.drag_handle_rounded;
        break;
      case TaskPriority.low:
        priorityColor = themeProvider.isEffectivelyDark ? Colors.green.shade300 : Colors.green.shade700;
        priorityIcon = Icons.keyboard_double_arrow_down_rounded;
        break;
    }

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(10.0),
      splashColor: colorScheme.primary.withOpacity(0.08),
      highlightColor: colorScheme.primary.withOpacity(0.05),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 10.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHigh,
          borderRadius: BorderRadius.circular(10.0),
          border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.05),
              blurRadius: 4.0,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            _buildLeadingIndicator(context, priorityColor, priorityIcon),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    task.title,
                    style: textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w500,
                      color: colorScheme.onSurface,
                      decoration: task.status == KanbanColumnStatus.done ? TextDecoration.lineThrough : null,
                      decorationColor: colorScheme.onSurfaceVariant.withOpacity(0.7),
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (task.description != null && task.description!.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 2.0),
                      child: Text(
                        task.description!,
                        style: textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant.withOpacity(0.9),
                          height: 1.2,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  if (task.isTeamTask && task.teamName != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 4.0),
                      child: Container( // Для выделения командной задачи
                        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                        decoration: BoxDecoration(
                          color: colorScheme.secondaryContainer.withOpacity(0.6),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.group_work_outlined, size: 12, color: colorScheme.onSecondaryContainer),
                            const SizedBox(width: 4),
                            Flexible(
                              child: Text(
                                task.teamName!,
                                style: textTheme.labelSmall?.copyWith(
                                    color: colorScheme.onSecondaryContainer, fontWeight: FontWeight.w500, fontSize: 11),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  _buildFooterRow(context, colorScheme, textTheme),
                ],
              ),
            ),
            if (onStatusChanged != null || onDelete != null)
              _buildActionsMenuButton(context, colorScheme),
          ],
        ),
      ),
    );
  }

  Widget _buildLeadingIndicator(BuildContext context, Color priorityColor, IconData priorityIcon) {
    final colorScheme = Theme.of(context).colorScheme;
    bool isDone = task.status == KanbanColumnStatus.done;

    return Column(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(priorityIcon, color: isDone ? priorityColor.withOpacity(0.5) : priorityColor, size: 18),
        const SizedBox(height: 6),
        SizedBox(
          width: 20,
          height: 20,
          child: Checkbox(
            value: isDone,
            onChanged: onStatusChanged != null ? (bool? newValue) {
              if (newValue != null) {
                onStatusChanged!(newValue ? KanbanColumnStatus.done : KanbanColumnStatus.todo);
              }
            } : null,
            activeColor: colorScheme.primary,
            side: BorderSide(color: colorScheme.outline.withOpacity(0.8), width: 1.5),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
          ),
        ),
      ],
    );
  }

  Widget _buildFooterRow(BuildContext context, ColorScheme colorScheme, TextTheme textTheme) {
    final List<Widget> footerItems = [];

    if (task.deadline != null) {
      final now = DateTime.now();
      final bool isOverdue = task.deadline!.isBefore(now) && task.status != KanbanColumnStatus.done;
      final deadlineColor = isOverdue ? colorScheme.error : colorScheme.onSurfaceVariant;
      footerItems.add(
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.alarm_outlined, size: 14, color: deadlineColor.withOpacity(0.8)),
            const SizedBox(width: 4),
            Text(
              DateFormat('dd MMM', 'ru_RU').format(task.deadline!),
              style: textTheme.labelSmall?.copyWith(color: deadlineColor, fontWeight: isOverdue ? FontWeight.bold : FontWeight.normal, fontSize: 11),
            ),
          ],
        ),
      );
    }

    if (task.tags.isNotEmpty) {
      final firstTag = task.tags.first;
      if (footerItems.isNotEmpty) footerItems.add(const SizedBox(width: 8));
      footerItems.add(
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 1.5),
          decoration: BoxDecoration(
              color: firstTag.backgroundColorPreview,
              borderRadius: BorderRadius.circular(4.0),
              border: Border.all(color: firstTag.borderColorPreview.withOpacity(0.5), width: 0.5)
          ),
          child: Text(
            firstTag.name,
            style: TextStyle(
              fontFamily: 'Inter',
              fontWeight: FontWeight.w500,
              fontSize: 10,
              color: firstTag.textColorPreview,
            ),
          ),
        ),
      );
      if (task.tags.length > 1) {
        footerItems.add(
            Padding(
              padding: const EdgeInsets.only(left: 2.0),
              child: Text(
                "+${task.tags.length - 1}",
                style: textTheme.labelSmall?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.7), fontSize: 10),
              ),
            )
        );
      }
    }
    if (footerItems.isEmpty) return const SizedBox(height: 10); // Небольшой отступ если футера нет

    return Padding(
      padding: const EdgeInsets.only(top: 8.0),
      child: Wrap(
        spacing: 6.0,
        runSpacing: 4.0,
        crossAxisAlignment: WrapCrossAlignment.center,
        children: footerItems,
      ),
    );
  }


  Widget _buildActionsMenuButton(BuildContext context, ColorScheme colorScheme) {
    final theme = Theme.of(context);
    return PopupMenuButton<String>(
      icon: Icon(Icons.more_vert_rounded, color: colorScheme.onSurfaceVariant.withOpacity(0.8)),
      tooltip: "Действия",
      offset: const Offset(0, 30), // Смещаем меню чуть ниже кнопки
      itemBuilder: (BuildContext context) {
        List<PopupMenuEntry<String>> items = [];
        if (onStatusChanged != null) {
          items.add(PopupMenuItem<String>(
            padding: EdgeInsets.zero, // Убираем внутренний padding
            child: Column( // Используем Column для заголовка и элементов
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                  child: Text("Изменить статус:", style: theme.textTheme.labelMedium?.copyWith(color: colorScheme.onSurfaceVariant)),
                ),
                ...KanbanColumnStatus.values.map((status) {
                  return PopupMenuItem<String>(
                    value: 'status_${status.name}',
                    height: 36, // Уменьшаем высоту
                    child: Row(
                      children: [
                        Icon(
                          task.status == status ? Icons.check_circle_outline_rounded : Icons.radio_button_unchecked_rounded,
                          size: 20,
                          color: task.status == status ? colorScheme.primary : colorScheme.onSurfaceVariant,
                        ),
                        const SizedBox(width: 10),
                        Text(
                          status.title,
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: task.status == status ? colorScheme.primary : colorScheme.onSurface,
                            fontWeight: task.status == status ? FontWeight.w600 : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                  );
                }).toList(),
              ],
            ),
          ));
        }
        if (onDelete != null) {
          if (items.isNotEmpty) items.add(const PopupMenuDivider(height: 1));
          items.add(
            PopupMenuItem<String>(
              value: 'delete',
              height: 38,
              child: Row(
                children: [
                  Icon(Icons.delete_outline_rounded, color: colorScheme.error, size: 20),
                  const SizedBox(width: 10),
                  Text('В корзину', style: TextStyle(color: colorScheme.error)),
                ],
              ),
            ),
          );
        }
        return items;
      },
      onSelected: (String value) {
        if (value.startsWith('status_')) {
          final statusName = value.substring('status_'.length);
          final newStatus = KanbanColumnStatus.values.firstWhere((s) => s.name == statusName);
          onStatusChanged?.call(newStatus);
        } else if (value == 'delete') {
          onDelete?.call();
        }
      },
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      color: theme.canvasColor, // или colorScheme.surfaceContainerHigh
      elevation: 3,
    );
  }
}
// --- Конец MobileTaskListItemWidget ---


// Виджет для отображения списка задач с группировкой по статусу
class MobileTaskListWidget extends StatelessWidget {
  final List<Task> tasks;
  final Function(Task, KanbanColumnStatus) onTaskStatusChanged;
  final Function(Task) onTaskTap;
  final Function(Task) onTaskDelete;
  final String currentUserId; // Для фильтрации или других нужд
  final ScrollController? scrollController; // Для внешнего управления скроллом

  const MobileTaskListWidget({
    Key? key,
    required this.tasks,
    required this.onTaskStatusChanged,
    required this.onTaskTap,
    required this.onTaskDelete,
    required this.currentUserId,
    this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final Map<KanbanColumnStatus, List<Task>> groupedTasks = {};
    for (var status in KanbanColumnStatus.values) {
      groupedTasks[status] = tasks.where((task) => task.status == status && !task.isDeleted).toList();
      groupedTasks[status]?.sort((a, b) {
        int priorityCompare = b.priority.index.compareTo(a.priority.index); // Сначала более высокий приоритет
        if (priorityCompare != 0) return priorityCompare;
        return (a.deadline ?? DateTime(9999)).compareTo(b.deadline ?? DateTime(9999)); // Затем по дедлайну
      });
    }

    final orderedStatuses = [ // Порядок отображения групп
      KanbanColumnStatus.in_progress,
      KanbanColumnStatus.todo,
      KanbanColumnStatus.deferred,
      KanbanColumnStatus.done,
    ];

    if (tasks.where((t) => !t.isDeleted).isEmpty) {
      return Center(
        child: Opacity(
          opacity: 0.7,
          child: Padding(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.check_circle_outline_rounded, size: 56, color: colorScheme.onSurfaceVariant),
                const SizedBox(height: 16),
                Text(
                  "Задач пока нет",
                  style: theme.textTheme.headlineSmall?.copyWith(color: colorScheme.onSurfaceVariant),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  "Самое время добавить новые или отдохнуть!",
                  style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.8)),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      );
    }

    // Используем CustomScrollView для лучшего контроля над секциями
    return CustomScrollView(
      controller: scrollController,
      slivers: [
        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
                  (context, index) {
                final status = orderedStatuses[index];
                final tasksInGroup = groupedTasks[status] ?? [];

                if (tasksInGroup.isEmpty && status != KanbanColumnStatus.done) { // Секцию "Выполнено" показываем даже если пустая, для консистентности
                  return const SizedBox.shrink();
                }

                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Padding(
                      padding: const EdgeInsets.only(top: 16.0, bottom: 8.0, left: 4.0, right: 4.0),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            status.title.toUpperCase(),
                            style: theme.textTheme.labelLarge?.copyWith( // Был titleSmall
                              color: colorScheme.primary.withOpacity(0.9),
                              fontWeight: FontWeight.w600, // Был bold
                              letterSpacing: 0.8, // Немного увеличил
                            ),
                          ),
                          Text(
                            "${tasksInGroup.length} задач",
                            style: theme.textTheme.labelSmall?.copyWith(
                              color: colorScheme.onSurfaceVariant.withOpacity(0.7),
                            ),
                          ),
                        ],
                      ),
                    ),
                    if (tasksInGroup.isEmpty && status == KanbanColumnStatus.done)
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Center(
                          child: Text(
                            "Нет выполненных задач",
                            style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.6)),
                          ),
                        ),
                      )
                    else
                      ListView.separated(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        itemCount: tasksInGroup.length,
                        itemBuilder: (context, taskIndex) {
                          final task = tasksInGroup[taskIndex];
                          return MobileTaskListItemWidget(
                            key: ValueKey(task.taskId), // Ключ для корректного обновления
                            task: task,
                            onTap: () => onTaskTap(task),
                            onStatusChanged: (newStatus) => onTaskStatusChanged(task, newStatus),
                            onDelete: () => onTaskDelete(task),
                          );
                        },
                        separatorBuilder: (context, _) => const SizedBox(height: 8),
                      ),
                    if (index < orderedStatuses.length - 1)
                      Divider(
                        height: 24,
                        thickness: 0.8,
                        color: colorScheme.outlineVariant.withOpacity(0.3),
                      )
                    else
                      const SizedBox(height: 16), // Отступ после последней группы
                  ],
                );
              },
              childCount: orderedStatuses.length,
            ),
          ),
        ),
      ],
    );
  }
}
```

```
// lib/widgets/tasks/mobile_task_list_item_widget.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../../models/task_model.dart';
import '../../theme_provider.dart'; // Для доступа к теме

// --- MobileTaskListItemWidget (остальной код виджета выше без изменений) ---
class MobileTaskListItemWidget extends StatelessWidget {
  final Task task;
  final VoidCallback? onTap;
  final Function(KanbanColumnStatus newStatus)? onStatusChanged; // Для быстрой смены статуса через меню
  final VoidCallback? onDelete;

  const MobileTaskListItemWidget({
    Key? key,
    required this.task,
    this.onTap,
    this.onStatusChanged,
    this.onDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;
    final themeProvider = Provider.of<ThemeProvider>(context, listen: false); // Для isEffectivelyDark

    Color priorityColor;
    IconData priorityIcon;

    switch (task.priority) {
      case TaskPriority.high:
        priorityColor = colorScheme.error;
        priorityIcon = Icons.keyboard_double_arrow_up_rounded;
        break;
      case TaskPriority.medium:
        priorityColor = themeProvider.isEffectivelyDark ? Colors.orange.shade300 : Colors.orange.shade800;
        priorityIcon = Icons.drag_handle_rounded; // Или Icons.arrow_forward_rounded
        break;
      case TaskPriority.low:
        priorityColor = themeProvider.isEffectivelyDark ? Colors.green.shade300 : Colors.green.shade700;
        priorityIcon = Icons.keyboard_double_arrow_down_rounded;
        break;
    }

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(10.0),
      splashColor: colorScheme.primary.withOpacity(0.08),
      highlightColor: colorScheme.primary.withOpacity(0.05),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 10.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHigh, // Используем фон чуть отличный от основного
          borderRadius: BorderRadius.circular(10.0),
          border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.05),
              blurRadius: 4.0,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            // Индикатор приоритета и чекбокс (если задача выполнена)
            _buildLeadingIndicator(context, priorityColor, priorityIcon),
            const SizedBox(width: 12),
            // Основная информация о задаче
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min, // Чтобы Column не растягивался без надобности
                children: [
                  Text(
                    task.title,
                    style: textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w500, // Чуть менее жирный, чем в канбан-карте
                      color: colorScheme.onSurface,
                      decoration: task.status == KanbanColumnStatus.done ? TextDecoration.lineThrough : null,
                      decorationColor: colorScheme.onSurfaceVariant.withOpacity(0.7),
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (task.description != null && task.description!.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 2.0),
                      child: Text(
                        task.description!,
                        style: textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant.withOpacity(0.9),
                          height: 1.2,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  if (task.isTeamTask && task.teamName != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 4.0),
                      child: Container( // Для выделения командной задачи
                        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                        decoration: BoxDecoration(
                          color: colorScheme.secondaryContainer.withOpacity(0.6),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.group_work_outlined, size: 12, color: colorScheme.onSecondaryContainer),
                            const SizedBox(width: 4),
                            Flexible(
                              child: Text(
                                task.teamName!,
                                style: textTheme.labelSmall?.copyWith(
                                    color: colorScheme.onSecondaryContainer, fontWeight: FontWeight.w500, fontSize: 11),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  _buildFooterRow(context, colorScheme, textTheme),
                ],
              ),
            ),
            // Меню действий (смена статуса, удаление)
            if (onStatusChanged != null || onDelete != null)
              _buildActionsMenuButton(context, colorScheme),
          ],
        ),
      ),
    );
  }

  Widget _buildLeadingIndicator(BuildContext context, Color priorityColor, IconData priorityIcon) {
    final colorScheme = Theme.of(context).colorScheme;
    bool isDone = task.status == KanbanColumnStatus.done;

    return Column(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(priorityIcon, color: isDone ? priorityColor.withOpacity(0.5) : priorityColor, size: 18),
        const SizedBox(height: 6),
        SizedBox(
          width: 20,
          height: 20,
          child: Checkbox(
            value: isDone,
            onChanged: onStatusChanged != null ? (bool? newValue) {
              if (newValue != null) {
                onStatusChanged!(newValue ? KanbanColumnStatus.done : KanbanColumnStatus.todo);
              }
            } : null,
            activeColor: colorScheme.primary,
            side: BorderSide(color: colorScheme.outline.withOpacity(0.8), width: 1.5),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
          ),
        ),
      ],
    );
  }

  Widget _buildFooterRow(BuildContext context, ColorScheme colorScheme, TextTheme textTheme) {
    final List<Widget> footerItems = [];

    if (task.deadline != null) {
      final now = DateTime.now();
      final bool isOverdue = task.deadline!.isBefore(now) && task.status != KanbanColumnStatus.done;
      final deadlineColor = isOverdue ? colorScheme.error : colorScheme.onSurfaceVariant;
      footerItems.add(
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.alarm_outlined, size: 14, color: deadlineColor.withOpacity(0.8)),
            const SizedBox(width: 4),
            Text(
              DateFormat('dd MMM', 'ru_RU').format(task.deadline!),
              style: textTheme.labelSmall?.copyWith(color: deadlineColor, fontWeight: isOverdue ? FontWeight.bold : FontWeight.normal, fontSize: 11),
            ),
          ],
        ),
      );
    }

    if (task.tags.isNotEmpty) {
      final firstTag = task.tags.first;
      if (footerItems.isNotEmpty) footerItems.add(const SizedBox(width: 8));
      footerItems.add(
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 1.5),
          decoration: BoxDecoration(
              color: firstTag.backgroundColorPreview,
              borderRadius: BorderRadius.circular(4.0),
              border: Border.all(color: firstTag.borderColorPreview.withOpacity(0.5), width: 0.5)
          ),
          child: Text(
            firstTag.name,
            style: TextStyle(
              fontFamily: 'Inter',
              fontWeight: FontWeight.w500,
              fontSize: 10,
              color: firstTag.textColorPreview,
            ),
          ),
        ),
      );
      if (task.tags.length > 1) {
        footerItems.add(
            Padding(
              padding: const EdgeInsets.only(left: 2.0),
              child: Text(
                "+${task.tags.length - 1}",
                style: textTheme.labelSmall?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.7), fontSize: 10),
              ),
            )
        );
      }
    }
    if (footerItems.isEmpty) return const SizedBox(height: 10); // Небольшой отступ если футера нет

    return Padding(
      padding: const EdgeInsets.only(top: 8.0),
      child: Wrap(
        spacing: 6.0,
        runSpacing: 4.0,
        crossAxisAlignment: WrapCrossAlignment.center,
        children: footerItems,
      ),
    );
  }


  Widget _buildActionsMenuButton(BuildContext context, ColorScheme colorScheme) {
    final theme = Theme.of(context);
    return PopupMenuButton<String>(
      icon: Icon(Icons.more_vert_rounded, color: colorScheme.onSurfaceVariant.withOpacity(0.8)),
      tooltip: "Действия",
      offset: const Offset(0, 30), // Смещаем меню чуть ниже кнопки
      itemBuilder: (BuildContext context) {
        List<PopupMenuEntry<String>> items = [];

        if (onStatusChanged != null) {
          // ----- ИЗМЕНЕНИЕ ЗДЕСЬ: Заголовок как часть некликабельного PopupMenuItem -----
          items.add(
            PopupMenuItem<String>(
              value: 'header_status', // Уникальное значение, чтобы отличить от других
              enabled: false, // Делаем этот пункт некликабельным
              height: 30, // Можно настроить высоту заголовка
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 0), // Убираем вертикальный паддинг
              child: Text(
                "Изменить статус:",
                style: theme.textTheme.labelMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant.withOpacity(0.8),
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          );
          // -------------------------------------------------------------------------

          KanbanColumnStatus.values.forEach((status) {
            items.add(
              PopupMenuItem<String>(
                value: 'status_${status.name}',
                height: 36,
                child: Row(
                  children: [
                    Icon(
                      task.status == status ? Icons.check_circle_outline_rounded : Icons.radio_button_unchecked_rounded,
                      size: 20,
                      color: task.status == status ? colorScheme.primary : colorScheme.onSurfaceVariant,
                    ),
                    const SizedBox(width: 10),
                    Text(
                      status.title,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: task.status == status ? colorScheme.primary : colorScheme.onSurface,
                        fontWeight: task.status == status ? FontWeight.w600 : FontWeight.normal,
                      ),
                    ),
                  ],
                ),
              ),
            );
          });
        }

        if (onDelete != null) {
          if (onStatusChanged != null) { // Добавляем разделитель только если были пункты статуса
            items.add(const PopupMenuDivider(height: 1));
          }
          items.add(
            PopupMenuItem<String>(
              value: 'delete',
              height: 38,
              child: Row(
                children: [
                  Icon(Icons.delete_outline_rounded, color: colorScheme.error, size: 20),
                  const SizedBox(width: 10),
                  Text('В корзину', style: TextStyle(color: colorScheme.error)),
                ],
              ),
            ),
          );
        }
        return items;
      },
      onSelected: (String value) {
        if (value.startsWith('status_')) {
          final statusName = value.substring('status_'.length);
          final newStatus = KanbanColumnStatus.values.firstWhere((s) => s.name == statusName);
          onStatusChanged?.call(newStatus);
        } else if (value == 'delete') {
          onDelete?.call();
        }
        // Игнорируем 'header_status'
      },
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      color: theme.canvasColor,
      elevation: 3,
    );
  }
}


// --- MobileTaskListWidget (код ниже без изменений) ---
// Виджет для отображения списка задач с группировкой по статусу
class MobileTaskListWidget extends StatelessWidget {
  final List<Task> tasks;
  final Function(Task, KanbanColumnStatus) onTaskStatusChanged;
  final Function(Task) onTaskTap;
  final Function(Task) onTaskDelete;
  final String currentUserId; // Для фильтрации или других нужд
  final ScrollController? scrollController; // Для внешнего управления скроллом

  const MobileTaskListWidget({
    Key? key,
    required this.tasks,
    required this.onTaskStatusChanged,
    required this.onTaskTap,
    required this.onTaskDelete,
    required this.currentUserId,
    this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final Map<KanbanColumnStatus, List<Task>> groupedTasks = {};
    for (var status in KanbanColumnStatus.values) {
      groupedTasks[status] = tasks.where((task) => task.status == status && !task.isDeleted).toList();
      groupedTasks[status]?.sort((a, b) {
        int priorityCompare = b.priority.index.compareTo(a.priority.index); // Сначала более высокий приоритет
        if (priorityCompare != 0) return priorityCompare;
        return (a.deadline ?? DateTime(9999)).compareTo(b.deadline ?? DateTime(9999)); // Затем по дедлайну
      });
    }

    final orderedStatuses = [ // Порядок отображения групп
      KanbanColumnStatus.in_progress,
      KanbanColumnStatus.todo,
      KanbanColumnStatus.deferred,
      KanbanColumnStatus.done,
    ];

    if (tasks.where((t) => !t.isDeleted).isEmpty) {
      return Center(
        child: Opacity(
          opacity: 0.7,
          child: Padding(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.check_circle_outline_rounded, size: 56, color: colorScheme.onSurfaceVariant),
                const SizedBox(height: 16),
                Text(
                  "Задач пока нет",
                  style: theme.textTheme.headlineSmall?.copyWith(color: colorScheme.onSurfaceVariant),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  "Самое время добавить новые или отдохнуть!",
                  style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.8)),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      );
    }

    // Используем CustomScrollView для лучшего контроля над секциями
    return CustomScrollView(
      controller: scrollController,
      slivers: [
        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
                  (context, index) {
                final status = orderedStatuses[index];
                final tasksInGroup = groupedTasks[status] ?? [];

                if (tasksInGroup.isEmpty && status != KanbanColumnStatus.done) { // Секцию "Выполнено" показываем даже если пустая, для консистентности
                  return const SizedBox.shrink();
                }

                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Padding(
                      padding: const EdgeInsets.only(top: 16.0, bottom: 8.0, left: 4.0, right: 4.0),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            status.title.toUpperCase(),
                            style: theme.textTheme.labelLarge?.copyWith( // Был titleSmall
                              color: colorScheme.primary.withOpacity(0.9),
                              fontWeight: FontWeight.w600, // Был bold
                              letterSpacing: 0.8, // Немного увеличил
                            ),
                          ),
                          Text(
                            "${tasksInGroup.length} задач",
                            style: theme.textTheme.labelSmall?.copyWith(
                              color: colorScheme.onSurfaceVariant.withOpacity(0.7),
                            ),
                          ),
                        ],
                      ),
                    ),
                    if (tasksInGroup.isEmpty && status == KanbanColumnStatus.done)
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 16.0),
                        child: Center(
                          child: Text(
                            "Нет выполненных задач",
                            style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant.withOpacity(0.6)),
                          ),
                        ),
                      )
                    else
                      ListView.separated(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(),
                        itemCount: tasksInGroup.length,
                        itemBuilder: (context, taskIndex) {
                          final task = tasksInGroup[taskIndex];
                          return MobileTaskListItemWidget(
                            key: ValueKey(task.taskId), // Ключ для корректного обновления
                            task: task,
                            onTap: () => onTaskTap(task),
                            onStatusChanged: (newStatus) => onTaskStatusChanged(task, newStatus),
                            onDelete: () => onTaskDelete(task),
                          );
                        },
                        separatorBuilder: (context, _) => const SizedBox(height: 8),
                      ),
                    if (index < orderedStatuses.length - 1)
                      Divider(
                        height: 24,
                        thickness: 0.8,
                        color: colorScheme.outlineVariant.withOpacity(0.3),
                      )
                    else
                      const SizedBox(height: 16), // Отступ после последней группы
                  ],
                );
              },
              childCount: orderedStatuses.length,
            ),
          ),
        ),
      ],
    );
  }
}
```

```
// lib/widgets/sidebar/sidebar_constants.dart
const double kCollapsedSidebarWidth = 72.0;
const double kExpandedSidebarWidthMobile = 220.0; // Используется для адаптивной ширины
const double kExpandedSidebarWidthTablet = 250.0; // Используется для адаптивной ширины
const double kExpandedSidebarWidthDesktop = 280.0; // Используется для адаптивной ширины

// Дополнительные константы, которые могут быть полезны для MenuItem и Sidebar
const double kSidebarItemIconSize = 24.0;
const double kSidebarHorizontalPaddingExpanded = 16.0;
const double kSidebarHorizontalPaddingCollapsed = 8.0; // Можно использовать (kCollapsedSidebarWidth - kSidebarItemIconSize) / 2
const double kSidebarItemVerticalPadding = 12.0;
const double kSidebarItemHorizontalPadding = 12.0; // Внутренний отступ MenuItem
const double kSidebarItemGap = 16.0; // Отступ между иконкой и текстом в MenuItem
```

```
// lib/widgets/sidebar/sidebar.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../core/routing/app_router_delegate.dart';
import '../../core/routing/app_route_path.dart';
import '../../core/routing/app_pages.dart';
import '../../sidebar_state_provider.dart'; // <<< ИМПОРТ
import './menu_item.dart';
import './sidebar_constants.dart';
import 'app_logo.dart';

class Sidebar extends StatefulWidget {
  final int activeMenuIndex;

  const Sidebar({
    Key? key,
    required this.activeMenuIndex,
  }) : super(key: key);

  @override
  State<Sidebar> createState() => _SidebarState();
}

class _SidebarState extends State<Sidebar> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _sidebarWidthAnimation;
  late Animation<double> _logoSizeAnimation;
  final Duration _animationDuration = const Duration(milliseconds: 250);
  final double _minWidthForExpandedHeader = 170.0;

  late final List<_SidebarItemData> _menuItems;
  late final List<_SidebarItemData> _bottomMenuItems;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: _animationDuration,
    );

    _menuItems = [
      _SidebarItemData(title: "Все задачи", icon: Icons.list_alt_rounded, routeSegment: AppRouteSegments.allTasks),
      _SidebarItemData(title: "Личные задачи", icon: Icons.person_outline_rounded, routeSegment: AppRouteSegments.personalTasks),
      _SidebarItemData(title: "Календарь", icon: Icons.calendar_today_outlined, routeSegment: AppRouteSegments.calendar, showRightSidebar: false), // <<< НОВЫЙ ПУНКТ
      _SidebarItemData(title: "Команды", icon: Icons.group_outlined, routeSegment: AppRouteSegments.teams),
    ];
    _bottomMenuItems = [
      _SidebarItemData(title: "Настройки", icon: Icons.settings_outlined, routeSegment: AppRouteSegments.settings, showRightSidebar: false),
      _SidebarItemData(title: "Корзина", icon: Icons.delete_outline_rounded, routeSegment: AppRouteSegments.trash, showRightSidebar: false), // Тоже без правого сайдбара
    ];

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        final sidebarProvider = Provider.of<SidebarStateProvider>(context, listen: false);
        if (!sidebarProvider.isCollapsed) {
          _animationController.value = 1.0;
        } else {
          _animationController.value = 0.0;
        }
      }
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _updateAnimations();

    final sidebarProvider = Provider.of<SidebarStateProvider>(context);
    if (sidebarProvider.isCollapsed) {
      if (_animationController.status != AnimationStatus.dismissed && _animationController.value != 0.0) {
        _animationController.reverse();
      }
    } else {
      if (_animationController.status != AnimationStatus.completed && _animationController.value != 1.0) {
        _animationController.forward();
      }
    }
  }


  void _updateAnimations() {
    double targetExpandedSidebarWidth;
    final mediaQueryData = MediaQuery.maybeOf(context);
    if (mediaQueryData != null) {
      final screenWidth = mediaQueryData.size.width;
      if (screenWidth < 600) targetExpandedSidebarWidth = kExpandedSidebarWidthMobile;
      else if (screenWidth < 1000) targetExpandedSidebarWidth = kExpandedSidebarWidthTablet;
      else targetExpandedSidebarWidth = kExpandedSidebarWidthDesktop;
    } else {
      targetExpandedSidebarWidth = kExpandedSidebarWidthDesktop;
    }

    _sidebarWidthAnimation = Tween<double>(
      begin: kCollapsedSidebarWidth,
      end: targetExpandedSidebarWidth,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOutCubic,
    ));

    _logoSizeAnimation = Tween<double>(
      begin: AppLogo.collapsedLogoSize,
      end: AppLogo.expandedLogoSize,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOutCubic,
    ));
  }

  Widget _buildHeaderSection(
      ThemeData theme,
      double currentAnimatingSidebarWidth,
      double currentAnimatingLogoSize,
      bool isActuallyCollapsed,
      VoidCallback onToggleCollapse
      ) {
    final colorScheme = theme.colorScheme;
    Widget toggleButton = IconButton(
      icon: Icon(
        isActuallyCollapsed ? Icons.menu_open_rounded : Icons.menu_rounded,
        semanticLabel: isActuallyCollapsed ? "Развернуть меню" : "Свернуть меню",
      ),
      tooltip: isActuallyCollapsed ? "Развернуть" : "Свернуть",
      onPressed: onToggleCollapse,
      color: colorScheme.onSurfaceVariant,
      splashRadius: 20,
      padding: EdgeInsets.zero,
      constraints: const BoxConstraints(),
    );

    final bool logoShouldUseCollapsedStyle = isActuallyCollapsed || currentAnimatingSidebarWidth < _minWidthForExpandedHeader;

    Widget logoWidget = AppLogo(
      key: ValueKey('app_logo_style_$logoShouldUseCollapsedStyle'),
      currentSize: currentAnimatingLogoSize,
      isActuallyCollapsedState: logoShouldUseCollapsedStyle,
    );

    if (logoShouldUseCollapsedStyle) {
      return Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          logoWidget,
          const SizedBox(height: 12),
          toggleButton,
        ],
      );
    } else {
      return Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          logoWidget,
          toggleButton,
        ],
      );
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final routerDelegate = Provider.of<AppRouterDelegate>(context, listen: false);
    final sidebarProvider = Provider.of<SidebarStateProvider>(context);

    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, _) {
        final currentAnimatingSidebarWidth = _sidebarWidthAnimation.value;
        final currentAnimatingLogoSize = _logoSizeAnimation.value;

        final bool useExpandedHorizontalPadding = currentAnimatingSidebarWidth >
            (kCollapsedSidebarWidth + (kSidebarHorizontalPaddingExpanded - kSidebarHorizontalPaddingCollapsed) / 2);
        final double currentHorizontalPadding = useExpandedHorizontalPadding
            ? kSidebarHorizontalPaddingExpanded
            : kSidebarHorizontalPaddingCollapsed;

        return Container(
          width: currentAnimatingSidebarWidth,
          height: double.infinity,
          padding: EdgeInsets.symmetric(
            vertical: 16.0,
            horizontal: currentHorizontalPadding,
          ),
          decoration: BoxDecoration(
            color: theme.colorScheme.background,
          ),
          child: Column(
            key: ValueKey<bool>(sidebarProvider.isCollapsed),
            crossAxisAlignment: (sidebarProvider.isCollapsed || !useExpandedHorizontalPadding)
                ? CrossAxisAlignment.center
                : CrossAxisAlignment.start,
            children: [
              _buildHeaderSection(
                  theme,
                  currentAnimatingSidebarWidth,
                  currentAnimatingLogoSize,
                  sidebarProvider.isCollapsed,
                  sidebarProvider.toggleCollapse
              ),
              const SizedBox(height: 24.0),
              Expanded(
                child: ListView.builder(
                  itemCount: _menuItems.length,
                  itemBuilder: (context, index) {
                    final item = _menuItems[index];
                    return Padding(
                      padding: const EdgeInsets.symmetric(vertical: 4.0),
                      child: MenuItem(
                        title: item.title,
                        icon: item.icon,
                        isActive: widget.activeMenuIndex == index,
                        isCollapsed: sidebarProvider.isCollapsed,
                        currentContentWidthForMenuItem: currentAnimatingSidebarWidth - (2 * currentHorizontalPadding),
                        onTap: () {
                          routerDelegate.navigateTo(HomeSubPath(item.routeSegment, showRightSidebar: item.showRightSidebar));
                        },
                      ),
                    );
                  },
                ),
              ),
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: _bottomMenuItems.length,
                itemBuilder: (context, index) {
                  final item = _bottomMenuItems[index];
                  final overallIndex = _menuItems.length + index; // <<< ИЗМЕНЕН РАСЧЕТ ИНДЕКСА
                  return Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4.0),
                    child: MenuItem(
                      title: item.title,
                      icon: item.icon,
                      isActive: widget.activeMenuIndex == overallIndex,
                      isCollapsed: sidebarProvider.isCollapsed,
                      currentContentWidthForMenuItem: currentAnimatingSidebarWidth - (2 * currentHorizontalPadding),
                      onTap: () {
                        routerDelegate.navigateTo(HomeSubPath(item.routeSegment, showRightSidebar: item.showRightSidebar));
                      },
                    ),
                  );
                },
              ),
            ],
          ),
        );
      },
    );
  }
}

class _SidebarItemData {
  final String title;
  final IconData icon;
  final String routeSegment;
  final bool showRightSidebar;

  _SidebarItemData({
    required this.title,
    required this.icon,
    required this.routeSegment,
    this.showRightSidebar = true,
  });
}
```

```
// lib/widgets/sidebar/right_sidebar.dart
import 'package:flutter/material.dart';

import '../tasks/task_edit_dialog.dart';

class RightSidebar extends StatelessWidget {
  const RightSidebar({Key? key}) : super(key: key);

  // Размеры и отступы вынесены для легкой настройки
  static const double _sidebarWidth = 96.0;
  static const double _itemSpacing = 16.0;
  static const double _dividerThickness = 1.5; // Немного тоньше
  static const double _dividerWidth = 48.0;
  static const double _standardButtonSize = 60.0; // Немного меньше для компактности
  // static const double _largeButtonSize = 72.0; // Если понадобится большая кнопка

  Widget _buildDivider(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      width: _dividerWidth,
      height: _dividerThickness,
      decoration: BoxDecoration(
        color: theme.colorScheme.outlineVariant, // Используем цвет из темы
        borderRadius: BorderRadius.circular(_dividerThickness / 2),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Container(
      width: _sidebarWidth,
      height: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: _itemSpacing, horizontal: (_sidebarWidth - _standardButtonSize) / 2), // Центрируем кнопки
      decoration: BoxDecoration(
        color: colorScheme.background, // Фон из темы
        // Можно добавить границу слева, если нужно отделить
        // border: Border(left: BorderSide(color: theme.dividerColor, width: 1.0)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          ActionButton(
            icon: Icons.tune_outlined,
            tooltip: "Фильтрация",
            onPressed: () { /* TODO: Implement filter action */ },
          ),
          const SizedBox(height: _itemSpacing),
          ActionButton(
            icon: Icons.swap_vert,
            tooltip: "Сортировка",
            onPressed: () { /* TODO: Implement sort action */ },
          ),
          const SizedBox(height: _itemSpacing),
          ActionButton(
            icon: Icons.group_outlined,
            tooltip: "Члены команды",
            onPressed: () { /* TODO: Implement team members action */ },
          ),
          const SizedBox(height: _itemSpacing),
          ActionButton(
            icon: Icons.chat_bubble_outline,
            tooltip: "Чат команды",
            onPressed: () { /* TODO: Implement team chat action */ },
          ),
          const Spacer(), // Занимает все доступное пространство, толкая кнопку "Добавить" вниз
          ActionButton(
            icon: Icons.add_task_outlined,
            tooltip: "Добавить задачу",
            onPressed: () {
            // <<< ИЗМЕНЕНИЕ ЗДЕСЬ
              showDialog<bool>( // bool для отслеживания, была ли задача создана/сохранена
                context: context,
                builder: (BuildContext dialogContext) {
            // Передаем провайдеры, если они нужны внутри диалога напрямую,
            // но TaskEditDialog сам получит их через Provider.of(context)
               return const TaskEditDialog(); // Для создания новой задачи taskToEdit: null
              },
            ).then((success) {
              if (success == true) {
                // Можно показать SnackBar или обновить список задач, если это не делается автоматически
                ScaffoldMessenger.of(context).showSnackBar(
                   const SnackBar(content: Text('Задача добавлена/обновлена!')),
                );
              }
            },
          );})
        ],
      ),
    );
  }
}

class ActionButton extends StatelessWidget {
  final IconData icon;
  final double size;
  final Color? iconColor; // Сделал nullable, чтобы можно было брать из темы по умолчанию
  final Color? borderColor; // Сделал nullable
  final Color? backgroundColor; // Добавил фон
  final double borderWidth;
  final VoidCallback? onPressed;
  final String? tooltip;

  const ActionButton({
    Key? key,
    required this.icon,
    this.size = RightSidebar._standardButtonSize, // Используем константу из RightSidebar
    this.iconColor,
    this.borderColor,
    this.backgroundColor,
    this.borderWidth = 1.5, // Немного тоньше
    this.onPressed,
    this.tooltip,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Определяем цвета, если они не переданы явно
    final effectiveBorderColor = borderColor ?? colorScheme.outline;
    final effectiveIconColor = iconColor ?? colorScheme.primary; // Иконки по умолчанию акцентные
    final effectiveBackgroundColor = backgroundColor ?? Colors.transparent; // По умолчанию прозрачный фон

    // Размер иконки внутри кнопки
    final double iconWidgetSize = size * 0.45;

    Widget buttonContent = Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: effectiveBackgroundColor,
        shape: BoxShape.circle,
        border: Border.all(
          color: effectiveBorderColor,
          width: borderWidth,
        ),
      ),
      child: Icon(icon, color: effectiveIconColor, size: iconWidgetSize),
    );

    // Оборачиваем в Material для InkWell эффектов и Tooltip
    Widget interactiveButton = Material(
      color: Colors.transparent, // Material сам прозрачный, цвет от Container выше
      shape: const CircleBorder(), // Для круглого InkWell
      clipBehavior: Clip.antiAlias, // Обрезка по кругу
      child: InkWell(
        onTap: onPressed,
        splashColor: effectiveIconColor.withOpacity(0.12),
        highlightColor: effectiveIconColor.withOpacity(0.1),
        child: buttonContent,
      ),
    );

    if (tooltip != null && tooltip!.isNotEmpty) {
      interactiveButton = Tooltip(
        message: tooltip!,
        child: interactiveButton,
        preferBelow: true, // Чтобы тултип не перекрывал верхние элементы
      );
    }

    return interactiveButton;
  }
}
```

```
// lib/widgets/sidebar/menu_item.dart
import 'package:flutter/material.dart';
import './sidebar_constants.dart'; // Путь к константам

class MenuItem extends StatelessWidget {
  final String title;
  final IconData icon;
  final bool isActive;
  final bool isCollapsed; // Финальное состояние схлопывания сайдбара
  final double currentContentWidthForMenuItem; // Текущая доступная ширина для контента MenuItem
  final VoidCallback onTap;

  const MenuItem({
    Key? key,
    required this.title,
    required this.icon,
    required this.isActive,
    required this.isCollapsed,
    required this.currentContentWidthForMenuItem,
    required this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Цвета для активного и неактивного состояния
    final Color activeIconColor = colorScheme.primary;
    final Color activeTextColor = colorScheme.primary;
    final Color inactiveIconColor = colorScheme.onSurfaceVariant;
    final Color inactiveTextColor = colorScheme.onSurface; // Или onSurfaceVariant для меньшего контраста

    final Color currentIconColor = isActive ? activeIconColor : inactiveIconColor;
    final Color currentTextColor = isActive ? activeTextColor : inactiveTextColor;

    // Фон для активного элемента
    final Color? itemBackgroundColor = isActive
        ? activeIconColor.withOpacity(0.08) // Легкий фон для активного элемента
        : null;

    // Минимальная ширина КОНТЕНТА MenuItem (после вычета его собственных паддингов),
    // необходимая для отображения текста.
    // Иконка (kSidebarItemIconSize) + отступ (kSidebarItemGap) + минимальный текст (например, 30-50)
    // Паддинги самого MenuItem: kSidebarItemHorizontalPadding * 2
    final double minInternalContentWidthForTextToShowText = kSidebarItemIconSize + kSidebarItemGap + 30.0;

    // Решаем, показывать ли текст, на основе isCollapsed И текущей доступной ширины для КОНТЕНТА MenuItem
    // Контент MenuItem = currentContentWidthForMenuItem - (2 * kSidebarItemHorizontalPadding)
    final bool showText = !isCollapsed &&
        (currentContentWidthForMenuItem - (2 * kSidebarItemHorizontalPadding)) > minInternalContentWidthForTextToShowText;

    // Определяем, как рендерить: полностью свернуто (только иконка), или пытаться развернуть (иконка + текст, если помещается)
    // Если isCollapsed = true, всегда рендерим как свернутый.
    // Если isCollapsed = false, но текст не помещается (showText = false), также рендерим как свернутый (только иконка, но центрированная в доступном пространстве).
    bool renderAsIconOnly = isCollapsed || (!isCollapsed && !showText);

    return Material(
      key: ValueKey('$title-$isActive-$renderAsIconOnly'), // Ключ для корректной анимации
      color: itemBackgroundColor ?? Colors.transparent,
      borderRadius: BorderRadius.circular(10.0), // Стандартный радиус для M3
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(10.0),
        splashColor: activeIconColor.withOpacity(0.12),
        highlightColor: activeIconColor.withOpacity(0.1),
        child: Padding(
          // Внутренние отступы самого MenuItem
          padding: EdgeInsets.symmetric(
            horizontal: kSidebarItemHorizontalPadding,
            vertical: kSidebarItemVerticalPadding,
          ),
          child: renderAsIconOnly
              ? SizedBox( // Если только иконка, центрируем ее в доступном пространстве
            width: currentContentWidthForMenuItem - (2 * kSidebarItemHorizontalPadding), // Ширина для центрирования иконки
            child: Icon(
              icon,
              color: currentIconColor,
              size: kSidebarItemIconSize,
              semanticLabel: title, // Для доступности
            ),
          )
              : Row( // Иконка и текст
            children: <Widget>[
              Icon(
                icon,
                color: currentIconColor,
                size: kSidebarItemIconSize,
                semanticLabel: title, // Для доступности, даже если текст виден
              ),
              // Текст и отступ показываем только если showText (определено выше)
              // Это условие уже учтено в renderAsIconOnly, но для ясности можно оставить
              // if (showText) ...[ // showText уже true, если мы здесь
              const SizedBox(width: kSidebarItemGap), // Отступ между иконкой и текстом
              Expanded(
                child: Text(
                  title,
                  style: theme.textTheme.titleMedium?.copyWith( // Используем подходящий стиль из темы
                    color: currentTextColor,
                    fontWeight: isActive ? FontWeight.w600 : FontWeight.normal, // Активный текст жирнее
                    fontSize: 14, // Явный размер, если нужно
                  ),
                  overflow: TextOverflow.ellipsis, // Обрезка длинного текста
                  maxLines: 1,
                  softWrap: false,
                ),
              ),
              // ]
              // else if (!isCollapsed) ...[ // Это случай, когда !isCollapsed, но !showText. Этот случай обрабатывается в renderAsIconOnly.
              //   // Если текст не показываем, но мы в "развернутом" режиме Row (т.е. isCollapsed=false),
              //   // то Row должен иметь Expanded, чтобы корректно работать.
              //   const Expanded(child: SizedBox.shrink()),
              // ],
            ],
          ),
        ),
      ),
    );
  }
}
```

```
// lib/widgets/app_logo.dart
import 'dart:ui'; // Для ImageFilter.blur
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../../core/constants/app_assets.dart'; // Путь к ассетам

class AppLogo extends StatelessWidget {
  final double currentSize; // Анимированный текущий размер логотипа
  final bool isActuallyCollapsedState; // Флаг для определения стиля блюра и радиуса

  // Статические константы для размеров логотипа
  static const double expandedLogoSize = 96.0;
  static const double collapsedLogoSize = 50.0; // Минимальный размер для свернутого состояния

  // Константы для визуальных эффектов
  static const double _blurSigmaBase = 8.0;
  static const double _borderRadiusBase = 12.0;

  const AppLogo({
    Key? key,
    required this.currentSize,
    required this.isActuallyCollapsedState,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Радиус и сила блюра зависят от ФИНАЛЬНОГО состояния коллапса (isActuallyCollapsedState),
    // а не от промежуточного анимированного размера (currentSize).
    // Это позволяет блюру и радиусу изменяться скачком при достижении порогового значения,
    // в то время как сам размер (currentSize) анимируется плавно.

    // Пропорциональный радиус для свернутого состояния
    final double currentBorderRadius = isActuallyCollapsedState
        ? _borderRadiusBase * (collapsedLogoSize / expandedLogoSize)
        : _borderRadiusBase;

    // Уменьшаем блюр в свернутом состоянии для лучшей читаемости маленького лого
    final double currentBlurSigma = isActuallyCollapsedState ? _blurSigmaBase / 2.0 : _blurSigmaBase;

    // Основной SVG логотип
    Widget mainLogoSvg = SizedBox(
      width: currentSize,
      height: currentSize,
      child: SvgPicture.asset(
        AppAssets.logo,
        fit: BoxFit.contain,
        // Если SVG поддерживает изменение цвета через colorFilter, можно его использовать
        // colorFilter: ColorFilter.mode(colorScheme.primary, BlendMode.srcIn),
      ),
    );

    // Размытый фон для логотипа
    Widget blurredBackground = ClipRRect(
      borderRadius: BorderRadius.circular(currentBorderRadius),
      child: SizedBox(
        width: currentSize,
        height: currentSize,
        child: ImageFiltered(
          imageFilter: ImageFilter.blur(sigmaX: currentBlurSigma, sigmaY: currentBlurSigma),
          child: SvgPicture.asset(
            AppAssets.logo,
            fit: BoxFit.contain,
            colorFilter: ColorFilter.mode(
              colorScheme.onSurface.withOpacity(0.05), // Цвет для блюра из темы
              BlendMode.srcATop,
            ),
          ),
        ),
      ),
    );

    // Собираем логотип: размытый фон и основной SVG поверх
    Widget logoContent = Stack(
      alignment: Alignment.center,
      children: [
        blurredBackground,
        mainLogoSvg,
      ],
    );

    // Оборачиваем в SizedBox с анимированным currentSize, чтобы сам виджет логотипа
    // корректно занимал анимированное пространство.
    return SizedBox(
      width: currentSize,
      height: currentSize,
      child: logoContent,
    );
  }
}
```

```
// lib/widgets/settings/profile_settings_tab.dart
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import '../../auth_state.dart';
import '../../services/api_service.dart'; // UserProfile используется AuthState
import '../../theme_provider.dart';
import '../../sidebar_state_provider.dart';
import '../CustomInputField.dart';
import '../PrimaryButton.dart';
import '../../core/utils/responsive_utils.dart';

class ProfileSettingsTab extends StatefulWidget {
  const ProfileSettingsTab({super.key});

  @override
  State<ProfileSettingsTab> createState() => _ProfileSettingsTabState();
}

class _ProfileSettingsTabState extends State<ProfileSettingsTab> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _loginController;

  XFile? _pickedImageFile;
  Uint8List? _pickedImageBytes;
  bool _resetAvatar = false;

  // Эти поля будут инициализированы в build на основе AuthState,
  // чтобы гарантировать, что они всегда актуальны при первом построении
  // или когда пользователь меняется.
  String? _initialLoginOnLoadFromAuthState;
  String? _currentAvatarUrlFromAuthState;

  bool _isLoading = false;
  String? _errorMessage;

  // Для безопасного использования context в асинхронных операциях
  BuildContext? _scaffoldMessengerContext;

  @override
  void initState() {
    super.initState();
    // Инициализируем контроллер пустым, он заполнится в первом build
    _loginController = TextEditingController();
    // Не добавляем слушателя на authState здесь, Consumer сделает свою работу.
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Сохраняем контекст, который точно будет валидным для ScaffoldMessenger
    // Это полезно, если виджет может быть удален из дерева во время асинхронной операции
    if (mounted) {
      _scaffoldMessengerContext = context;
    }
  }

  @override
  void dispose() {
    _loginController.dispose();
    super.dispose();
  }

  Future<void> _pickImage() async {
    final ImagePicker picker = ImagePicker();
    if (!mounted) return; // Проверка перед использованием context
    final currentContext = _scaffoldMessengerContext ?? context;

    try {
      final XFile? image = await picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 1024, maxHeight: 1024);
      if (image != null) {
        final bytes = await image.readAsBytes();
        if (bytes.lengthInBytes > 2 * 1024 * 1024) { // 2MB limit
          if (!mounted) return;
          ScaffoldMessenger.of(currentContext).showSnackBar(
            const SnackBar(content: Text('Файл слишком большой. Максимум 2MB.'), backgroundColor: Colors.red),
          );
          return;
        }
        if (!mounted) return;
        setState(() {
          _pickedImageFile = image;
          _pickedImageBytes = bytes;
          _resetAvatar = false;
        });
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(currentContext).showSnackBar(
        SnackBar(content: Text('Ошибка выбора изображения: $e'), backgroundColor: Colors.red),
      );
    }
  }

  void _prepareResetAvatar() {
    if (!mounted) return;
    setState(() {
      _pickedImageFile = null;
      _pickedImageBytes = null;
      _resetAvatar = true;
    });
  }

  Future<void> _saveProfile() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    final currentContext = _scaffoldMessengerContext ?? context;
    final authState = Provider.of<AuthState>(currentContext, listen: false);
    final themeProvider = Provider.of<ThemeProvider>(currentContext, listen: false);
    final sidebarProvider = Provider.of<SidebarStateProvider>(currentContext, listen: false);

    Map<String, dynamic>? avatarFileMap;
    if (_pickedImageFile != null && _pickedImageBytes != null) {
      avatarFileMap = {
        'bytes': _pickedImageBytes!,
        'filename': _pickedImageFile!.name,
      };
    }

    final newLogin = _loginController.text.trim();
    // Используем _initialLoginOnLoadFromAuthState для сравнения, т.к. он отражает состояние на момент загрузки/последнего сохранения
    bool loginChanged = newLogin != (_initialLoginOnLoadFromAuthState ?? '');
    bool avatarChanged = _pickedImageFile != null || _resetAvatar;

    final currentUser = authState.currentUser; // Это актуальный UserProfile из AuthState
    bool themeSettingsChanged = false;

    if (currentUser != null) {
      final currentThemeFromServer = ThemeMode.values.firstWhere(
              (e) => e.name == currentUser.theme,
          orElse: () => ThemeMode.system
      );

      Color? currentAccentFromServer;
      if (currentUser.accentColor != null && currentUser.accentColor!.isNotEmpty) {
        try {
          currentAccentFromServer = Color(int.parse(currentUser.accentColor!.replaceFirst('#', '0xff')));
        } catch (_) { /* ignore parse error */ }
      }
      final currentAccentProvider = themeProvider.accentColor;

      if (themeProvider.themeMode != currentThemeFromServer ||
          (currentAccentFromServer != null && currentAccentProvider.value != currentAccentFromServer.value) ||
          (currentAccentFromServer == null && currentAccentProvider.value != Provider.of<ThemeProvider>(currentContext, listen:false).accentColor.value) ||
          sidebarProvider.isCollapsed != (currentUser.isSidebarCollapsed ?? false) ) {
        themeSettingsChanged = true;
      }
    } else {
      // Если currentUser почему-то null (не должно быть здесь, если пользователь залогинен),
      // но на всякий случай считаем, что настройки могли измениться, если они не дефолтные.
      if (themeProvider.themeMode != ThemeMode.system ||
          themeProvider.accentColor != const Color(0xFF5457FF) || // Сравнение с дефолтным акцентом
          sidebarProvider.isCollapsed != false ) { // Сравнение с дефолтным состоянием сайдбара
        themeSettingsChanged = true;
      }
    }

    if (!loginChanged && !avatarChanged && !themeSettingsChanged) {
      if (mounted) {
        ScaffoldMessenger.of(currentContext).showSnackBar(
          const SnackBar(content: Text('Нет изменений для сохранения.')),
        );
        setState(() { _isLoading = false; });
      }
      return;
    }

    final success = await authState.updateUserProfile(
      login: loginChanged ? newLogin : null,
      theme: themeSettingsChanged ? themeProvider.themeMode.name : null,
      accentColor: themeSettingsChanged ? '#${themeProvider.accentColor.value.toRadixString(16).padLeft(8, '0').substring(2)}' : null,
      isSidebarCollapsed: themeSettingsChanged ? sidebarProvider.isCollapsed : null,
      resetAvatar: _resetAvatar,
      avatarFile: avatarFileMap,
    );

    if (!mounted) return;

    setState(() { _isLoading = false; });
    if (success) {
      ScaffoldMessenger.of(currentContext).showSnackBar(
        const SnackBar(content: Text('Профиль успешно обновлен!'), backgroundColor: Colors.green),
      );
      // После успешного сохранения, AuthState.currentUser будет обновлен.
      // _initialLoginOnLoadFromAuthState и _currentAvatarUrlFromAuthState обновятся в следующем build.
      setState(() {
        _pickedImageFile = null;
        _pickedImageBytes = null;
        _resetAvatar = false;
        // Контроллер и URL аватара обновятся в build на основе свежих данных из AuthState
      });
    } else {
      setState(() { _errorMessage = authState.errorMessage ?? 'Не удалось обновить профиль.'; });
    }
  }

  Future<void> _deleteAccount() async {
    if (!mounted) return;
    final currentContext = _scaffoldMessengerContext ?? context;
    final authState = Provider.of<AuthState>(currentContext, listen: false);

    final confirm = await showDialog<bool>(
      context: currentContext,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Удалить аккаунт?'),
          content: const Text('Это действие нельзя будет отменить. Все ваши данные будут удалены.'),
          actions: <Widget>[
            TextButton(
              child: const Text('Отмена'),
              onPressed: () => Navigator.of(dialogContext).pop(false),
            ),
            TextButton(
              child: Text('Удалить', style: TextStyle(color: Theme.of(currentContext).colorScheme.error, fontWeight: FontWeight.bold)),
              onPressed: () => Navigator.of(dialogContext).pop(true),
            ),
          ],
        );
      },
    );

    if (confirm == true) {
      if (!mounted) return;
      setState(() { _isLoading = true; _errorMessage = null; });

      final success = await authState.deleteUserAccount();

      // После deleteUserAccount AuthState вызовет logout, что приведет к перестроению
      // и навигации на экран логина. Поэтому проверки !mounted здесь могут быть излишни,
      // так как виджет будет удален из дерева.
      if (!mounted) return;

      if (!success) {
        setState(() {
          _isLoading = false;
          _errorMessage = authState.errorMessage ?? 'Не удалось удалить аккаунт.';
        });
      }
    }
  }

  Widget _buildInitialsAvatar(BuildContext context, UserProfile user, double radius) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    String initials = "";
    String nameSource = user.login;

    if (nameSource.isNotEmpty) {
      final names = nameSource.split(RegExp(r'\s+')).where((s) => s.isNotEmpty).toList(); // Разделяем по пробелам и убираем пустые
      if (names.isNotEmpty) {
        initials = names[0][0];
        if (names.length > 1 && names[1].isNotEmpty) {
          initials += names[1][0];
        } else if (names[0].length > 1) {
          initials = names[0].substring(0, initials.length == 1 ? 2 : 1).trim(); // Берем 2 если одна буква, или 1 если уже есть 2
          if (initials.length > 2) initials = initials.substring(0,2);
        }
      }
    }

    initials = initials.toUpperCase();
    if (initials.isEmpty && user.email.isNotEmpty) {
      initials = user.email[0].toUpperCase();
    }
    if (initials.isEmpty) {
      initials = "?";
    }


    Color avatarBackgroundColor = colorScheme.primaryContainer;
    Color avatarTextColor = colorScheme.onPrimaryContainer;

    if (user.accentColor != null && user.accentColor!.isNotEmpty) {
      try {
        final userAccent = Color(int.parse(user.accentColor!.replaceFirst('#', '0xff')));
        // Определяем контрастный цвет для текста на фоне акцентного цвета
        avatarTextColor = ThemeData.estimateBrightnessForColor(userAccent) == Brightness.dark
            ? Colors.white.withOpacity(0.95)
            : Colors.black.withOpacity(0.8);
        avatarBackgroundColor = userAccent;
      } catch (_) { /* Используем дефолтные цвета */ }
    }

    return CircleAvatar(
      radius: radius,
      backgroundColor: avatarBackgroundColor,
      child: Text(
        initials,
        style: TextStyle(
          fontSize: radius * (initials.length == 1 ? 0.8 : 0.6), // Адаптируем размер шрифта
          fontWeight: FontWeight.bold,
          color: avatarTextColor,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (mounted) { // Обновляем контекст, если виджет все еще в дереве
      _scaffoldMessengerContext = context;
    }
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final bool isMobile = ResponsiveUtil.isMobile(context);

    return Consumer<AuthState>(
      builder: (context, authState, child) {
        final UserProfile? currentUser = authState.currentUser;
        final double avatarRadius = isMobile ? 48 : 60;

        if (authState.isLoading && currentUser == null) {
          return const Center(child: CircularProgressIndicator());
        }
        if (currentUser == null && !authState.isLoading) {
          return Center(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.error_outline, color: Colors.red, size: 48),
                    const SizedBox(height: 16),
                    Text('Не удалось загрузить данные профиля.', style: theme.textTheme.titleMedium, textAlign: TextAlign.center),
                    const SizedBox(height: 10),
                    ElevatedButton(onPressed: () => authState.checkInitialAuthStatusAgain(), child: const Text("Повторить"))
                  ],
                ),
              )
          );
        }

        // currentUser здесь точно не null

        // Обновление локальных переменных состояния на основе AuthState
        // Это нужно делать здесь, чтобы UI корректно отражал изменения
        // после загрузки или обновления профиля.
        if (_initialLoginOnLoadFromAuthState != currentUser!.login) {
          _initialLoginOnLoadFromAuthState = currentUser.login;
          // Обновляем текст в контроллере, только если он не совпадает
          // и поле не в фокусе (чтобы не сбросить ввод пользователя).
          // Это лучше делать через key для TextFormField или более сложную логику,
          // но для простоты пока так.
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted && _loginController.text != (_initialLoginOnLoadFromAuthState ?? '')) {
              final currentFocus = FocusScope.of(context).focusedChild;
              bool isLoginFieldFocused = currentFocus != null &&
                  currentFocus.context?.widget is EditableText &&
                  (currentFocus.context!.widget as EditableText).controller == _loginController;
              if(!isLoginFieldFocused) _loginController.text = _initialLoginOnLoadFromAuthState ?? '';
            }
          });
        }
        if (_currentAvatarUrlFromAuthState != currentUser.avatarUrl) {
          _currentAvatarUrlFromAuthState = currentUser.avatarUrl;
          // Если есть _pickedImageFile, он имеет приоритет, поэтому не сбрасываем его,
          // просто обновляем _currentAvatarUrlFromAuthState для следующего рендера, если _pickedImageFile будет сброшен.
        }

        Widget avatarDisplayWidget;
        String? displayableAvatarUrl = _currentAvatarUrlFromAuthState;

        if (_pickedImageBytes != null) {
          avatarDisplayWidget = CircleAvatar(
            radius: avatarRadius,
            backgroundImage: MemoryImage(_pickedImageBytes!),
          );
        } else if (_resetAvatar) {
          avatarDisplayWidget = _buildInitialsAvatar(context, currentUser, avatarRadius);
        } else if (displayableAvatarUrl != null && displayableAvatarUrl.isNotEmpty) {
          avatarDisplayWidget = CircleAvatar(
            radius: avatarRadius,
            backgroundImage: NetworkImage(displayableAvatarUrl),
            onBackgroundImageError: (exception, stackTrace) {
              if (mounted) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  if(mounted) {
                    setState(() {
                      // Если URL не загрузился, сбрасываем его, чтобы показать инициалы
                      _currentAvatarUrlFromAuthState = null;
                    });
                  }
                });
              }
            },
            backgroundColor: Colors.transparent,
          );
        } else {
          avatarDisplayWidget = _buildInitialsAvatar(context, currentUser, avatarRadius);
        }

        return SingleChildScrollView(
          padding: EdgeInsets.all(isMobile ? 16.0 : 24.0).copyWith(top: isMobile ? 20 : 28),
          child: Center(
            child: ConstrainedBox(
              constraints: BoxConstraints(maxWidth: isMobile ? 400 : 480),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Center(
                      child: Stack(
                        alignment: Alignment.bottomRight,
                        children: [
                          Padding(
                            padding: const EdgeInsets.all(8.0),
                            child: avatarDisplayWidget,
                          ),
                          Positioned(
                            right: 0,
                            bottom: 0,
                            child: Material(
                              color: colorScheme.secondaryContainer,
                              shape: const CircleBorder(),
                              elevation: 2,
                              child: InkWell(
                                onTap: _isLoading ? null : _pickImage,
                                customBorder: const CircleBorder(),
                                child: Padding(
                                  padding: const EdgeInsets.all(8.0),
                                  child: Icon(
                                    Icons.edit_outlined,
                                    size: isMobile ? 20 : 22,
                                    color: colorScheme.onSecondaryContainer,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                    if ((displayableAvatarUrl != null && displayableAvatarUrl.isNotEmpty) || _pickedImageFile != null)
                      Center(
                        child: TextButton(
                          onPressed: _isLoading ? null : _prepareResetAvatar,
                          child: Text('Удалить аватар', style: TextStyle(color: colorScheme.error, fontSize: 13)),
                        ),
                      ),
                    SizedBox(height: (displayableAvatarUrl != null && displayableAvatarUrl.isNotEmpty || _pickedImageFile != null) ? 12 : 28),

                    CustomInputField(
                      key: ValueKey('login_field_${currentUser.userId}_${_initialLoginOnLoadFromAuthState}'),
                      label: "Логин (никнейм)",
                      controller: _loginController,
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Логин не может быть пустым';
                        }
                        if (value.trim().length < 3) {
                          return 'Минимум 3 символа';
                        }
                        return null;
                      },
                      textInputAction: TextInputAction.done,
                      onFieldSubmitted: (_) => _isLoading ? null : _saveProfile(),
                    ),
                    const SizedBox(height: 16),
                    CustomInputField(
                      label: "Email",
                      initialValue: currentUser.email,
                      readOnly: true,
                      enabled: false,
                    ),
                    const SizedBox(height: 28),

                    if (_errorMessage != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16.0),
                        child: Text(
                          _errorMessage!,
                          style: TextStyle(color: colorScheme.error, fontSize: 14),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    PrimaryButton(
                      text: "Сохранить изменения",
                      onPressed: _isLoading ? null : _saveProfile,
                      isLoading: _isLoading,
                    ),
                    const SizedBox(height: 20),

                    const Divider(height: 32),
                    Row(
                      children: [
                        Expanded(
                          child: OutlinedButton.icon(
                            icon: Icon(Icons.logout_rounded, size: 20, color: colorScheme.onSurfaceVariant),
                            label: Text("Выйти", style: TextStyle(color: colorScheme.onSurfaceVariant)),
                            onPressed: _isLoading ? null : () {
                              final currentContextForDialog = _scaffoldMessengerContext ?? context;
                              showDialog(
                                context: currentContextForDialog,
                                builder: (BuildContext dialogContext) {
                                  return AlertDialog(
                                    title: const Text('Выход из аккаунта'),
                                    content: const Text('Вы уверены, что хотите выйти?'),
                                    actions: <Widget>[
                                      TextButton(
                                        child: const Text('Отмена'),
                                        onPressed: () => Navigator.of(dialogContext).pop(),
                                      ),
                                      TextButton(
                                        child: Text('Выйти', style: TextStyle(color: Theme.of(currentContextForDialog).colorScheme.error, fontWeight: FontWeight.bold)),
                                        onPressed: () {
                                          Navigator.of(dialogContext).pop();
                                          Provider.of<AuthState>(currentContextForDialog, listen: false).logout();
                                        },
                                      ),
                                    ],
                                  );
                                },
                              );
                            },
                            style: OutlinedButton.styleFrom(
                              foregroundColor: colorScheme.onSurfaceVariant,
                              side: BorderSide(color: colorScheme.outline.withOpacity(0.5)),
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: OutlinedButton.icon(
                            icon: Icon(Icons.delete_forever_outlined, color: colorScheme.error, size: 20),
                            label: Text("Удалить", style: TextStyle(color: colorScheme.error)),
                            onPressed: _isLoading ? null : _deleteAccount,
                            style: OutlinedButton.styleFrom(
                              foregroundColor: colorScheme.error,
                              side: BorderSide(color: colorScheme.error.withOpacity(0.7)),
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}
```

```
// lib/widgets/kanban_board/task_card_widget.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../../models/task_model.dart';
// import '../../core/routing/app_router_delegate.dart'; // Не используется напрямую здесь
// import '../../core/routing/app_route_path.dart'; // Не используется напрямую здесь

abstract class BaseTaskCard extends StatelessWidget {
  final Task task;
  final ValueChanged<KanbanColumnStatus> onStatusChanged;
  final VoidCallback? onCardTap;
  final VoidCallback? onTaskDelete; // <<< ДОБАВЛЕНО: Коллбэк для удаления задачи

  const BaseTaskCard({
    Key? key,
    required this.task,
    required this.onStatusChanged,
    this.onCardTap,
    this.onTaskDelete, // <<< ДОБАВЛЕНО
  }) : super(key: key);

  Widget _buildTitle(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Text(
      task.title,
      style: theme.textTheme.titleMedium?.copyWith(
        fontWeight: FontWeight.bold,
        color: colorScheme.onSurface,
        height: 1.2,
      ),
      maxLines: 2,
      overflow: TextOverflow.ellipsis,
    );
  }

  Widget _buildDescription(BuildContext context) {
    if (task.description == null || task.description!.isEmpty) {
      return const SizedBox.shrink();
    }
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    return Text(
      task.description!,
      style: theme.textTheme.bodyMedium?.copyWith(
        color: colorScheme.onSurfaceVariant,
        height: 1.3,
      ),
      maxLines: 3,
      overflow: TextOverflow.ellipsis,
    );
  }

  Widget _buildTags(BuildContext context) {
    if (task.tags.isEmpty) {
      return const SizedBox.shrink();
    }
    return Wrap(
      spacing: 8.0,
      runSpacing: 4.0,
      children: task.tags.map((tag) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: tag.backgroundColorPreview,
            borderRadius: BorderRadius.circular(6.0),
            border: Border.all(color: tag.borderColorPreview, width: 1.0),
          ),
          child: Text(
            tag.name,
            style: TextStyle(
              fontFamily: 'Inter',
              fontWeight: FontWeight.w500,
              fontSize: 12,
              color: tag.textColorPreview,
              height: 1.2,
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildFooter(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    Widget deadlineWidget = const SizedBox.shrink();
    if (task.deadline != null) {
      deadlineWidget = Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: colorScheme.tertiaryContainer.withOpacity(0.7),
          borderRadius: BorderRadius.circular(6.0),
        ),
        child: Text(
          DateFormat('dd.MM').format(task.deadline!),
          style: theme.textTheme.labelSmall?.copyWith(
            fontFamily: 'JetBrainsMono',
            fontWeight: FontWeight.w600,
            color: colorScheme.onTertiaryContainer,
          ),
        ),
      );
    }

    Widget statusChanger = DropdownButtonHideUnderline(
      child: DropdownButton<KanbanColumnStatus>(
        value: task.status,
        icon: Icon(Icons.keyboard_arrow_down_rounded, size: 20, color: colorScheme.onSurfaceVariant.withOpacity(0.7)),
        style: theme.textTheme.bodySmall?.copyWith(color: colorScheme.onSurface),
        dropdownColor: theme.canvasColor,
        borderRadius: BorderRadius.circular(10),
        items: KanbanColumnStatus.values.map((KanbanColumnStatus status) {
          return DropdownMenuItem<KanbanColumnStatus>(
            value: status,
            child: Text(status.title, style: theme.textTheme.bodySmall),
          );
        }).toList(),
        onChanged: (KanbanColumnStatus? newValue) {
          if (newValue != null) {
            onStatusChanged(newValue);
          }
        },
        isDense: true,
        selectedItemBuilder: (BuildContext context) {
          return KanbanColumnStatus.values.map<Widget>((KanbanColumnStatus item) {
            return Align(
              alignment: Alignment.centerLeft,
              child: Text(
                task.status.title,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurface,
                  fontWeight: FontWeight.w500,
                ),
              ),
            );
          }).toList();
        },
      ),
    );

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Flexible(child: statusChanger),
        const SizedBox(width: 4),
        if (task.deadline != null) Flexible(child: deadlineWidget),
        const SizedBox(width: 4),
        if (onTaskDelete != null) // <<< ДОБАВЛЕНА КНОПКА УДАЛЕНИЯ
          IconButton(
            icon: Icon(Icons.delete_outline_rounded, color: colorScheme.error.withOpacity(0.9)),
            iconSize: 20,
            padding: const EdgeInsets.all(4), // Небольшой отступ для лучшего тапа
            constraints: const BoxConstraints(),
            splashRadius: 18,
            tooltip: 'Переместить в корзину',
            onPressed: () => onTaskDelete!(), // Вызов коллбэка
          ),
      ],
    );
  }

  Widget _buildSpecificInfo(BuildContext context);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    Widget cardContent = Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      mainAxisSize: MainAxisSize.min,
      children: [
        _buildTitle(context),
        const SizedBox(height: 6.0),
        _buildSpecificInfo(context),
        if (_buildSpecificInfo(context) is! SizedBox) const SizedBox(height: 6.0),
        Flexible(child: _buildDescription(context)),
        if (task.description != null && task.description!.isNotEmpty) const SizedBox(height: 8.0),
        _buildTags(context),
        if (task.tags.isNotEmpty) const SizedBox(height: 8.0),
        const Divider(height: 12, thickness: 0.5, indent: 4, endIndent: 4),
        Padding(
          padding: const EdgeInsets.only(top: 2.0),
          child: _buildFooter(context),
        ),
      ],
    );

    return Card(
      elevation: 1.5,
      margin: EdgeInsets.zero,
      clipBehavior: Clip.antiAlias,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12.0),
        side: BorderSide(color: colorScheme.outlineVariant.withOpacity(0.5), width: 0.8),
      ),
      child: InkWell(
        onTap: onCardTap,
        borderRadius: BorderRadius.circular(11.0), // Чуть меньше для эффекта
        child: Container(
          width: 288, // Фиксированная ширина карточки
          padding: const EdgeInsets.all(10.0),
          child: cardContent,
        ),
      ),
    );
  }
}

class PersonalTaskCard extends BaseTaskCard {
  PersonalTaskCard({
    Key? key,
    required Task task,
    required ValueChanged<KanbanColumnStatus> onStatusChanged,
    VoidCallback? onCardTap,
    VoidCallback? onTaskDelete, // <<< ДОБАВЛЕНО
  }) : assert(!task.isTeamTask),
        super(
        key: key,
        task: task,
        onStatusChanged: onStatusChanged,
        onCardTap: onCardTap,
        onTaskDelete: onTaskDelete, // <<< ДОБАВЛЕНО
      );

  @override
  Widget _buildSpecificInfo(BuildContext context) {
    return const SizedBox.shrink();
  }
}

class TeamTaskCard extends BaseTaskCard {
  TeamTaskCard({
    Key? key,
    required Task task,
    required ValueChanged<KanbanColumnStatus> onStatusChanged,
    VoidCallback? onCardTap,
    VoidCallback? onTaskDelete, // <<< ДОБАВЛЕНО
  }) : assert(task.isTeamTask),
        super(
        key: key,
        task: task,
        onStatusChanged: onStatusChanged,
        onCardTap: onCardTap,
        onTaskDelete: onTaskDelete, // <<< ДОБАВЛЕНО
      );

  @override
  Widget _buildSpecificInfo(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (task.teamId == null && task.teamName == null) return const SizedBox.shrink();

    return GestureDetector(
      onTap: task.teamId != null ? () {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Переход к команде ${task.teamName ?? task.teamId} (в разработке)')),
        );
      } : null,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
        margin: const EdgeInsets.only(bottom: 4.0),
        decoration: BoxDecoration(
          color: colorScheme.secondaryContainer.withOpacity(0.4),
          borderRadius: BorderRadius.circular(6),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.group_work_outlined, size: 13, color: colorScheme.onSecondaryContainer),
            const SizedBox(width: 5),
            Flexible(
              child: Text(
                task.teamName ?? 'Команда: ${task.teamId}',
                style: theme.textTheme.labelSmall?.copyWith(
                  color: colorScheme.onSecondaryContainer,
                  fontWeight: FontWeight.w500,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
            if (task.teamId != null)
              Icon(Icons.arrow_forward_ios_rounded, size: 11, color: colorScheme.onSecondaryContainer.withOpacity(0.7)),
          ],
        ),
      ),
    );
  }
}
```

```
// lib/widgets/kanban_board/kanban_column_widget.dart
import 'package:flutter/material.dart';
import '../../models/task_model.dart';
import './task_card_widget.dart';
import 'package:provider/provider.dart';
import '../../core/routing/app_router_delegate.dart';

class KanbanColumnWidget extends StatelessWidget {
  final KanbanColumnStatus status;
  final List<Task> tasks;
  final Function(Task, KanbanColumnStatus) onTaskStatusChanged;
  final ValueChanged<Task>? onTaskTap;
  final ValueChanged<Task>? onTaskDelete;

  const KanbanColumnWidget({
    Key? key,
    required this.status,
    required this.tasks,
    required this.onTaskStatusChanged,
    this.onTaskTap,
    this.onTaskDelete,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // final routerDelegate = Provider.of<AppRouterDelegate>(context, listen: false); // Не используется здесь напрямую

    return DragTarget<Task>(
      builder: (context, candidateData, rejectedData) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12.0),
          ),
          child: tasks.isEmpty
              ? LayoutBuilder(
            builder: (context, constraints) {
              return Center(
                child: Opacity(
                  opacity: 0.6,
                  child: Text(
                    'Нет задач',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
              );
            },
          )
              : ListView.separated(
            padding: EdgeInsets.zero,
            itemCount: tasks.length,
            itemBuilder: (context, index) {
              final task = tasks[index];
              // Создаем инстанс карточки один раз
              final BaseTaskCard taskCardWidget = task.isTeamTask
                  ? TeamTaskCard(
                key: ValueKey(task.taskId),
                task: task,
                onStatusChanged: (newStatus) => onTaskStatusChanged(task, newStatus),
                onCardTap: onTaskTap != null ? () => onTaskTap!(task) : null,
                onTaskDelete: onTaskDelete != null ? () => onTaskDelete!(task) : null,
              )
                  : PersonalTaskCard(
                key: ValueKey(task.taskId),
                task: task,
                onStatusChanged: (newStatus) => onTaskStatusChanged(task, newStatus),
                onCardTap: onTaskTap != null ? () => onTaskTap!(task) : null,
                onTaskDelete: onTaskDelete != null ? () => onTaskDelete!(task) : null,
              );

              return Draggable<Task>(
                data: task,
                feedback: Material(
                  elevation: 4.0,
                  color: Colors.transparent,
                  borderRadius: BorderRadius.circular(12.0),
                  child: ConstrainedBox(
                    // Используем известную ширину карточки из BaseTaskCard (288.0)
                    constraints: const BoxConstraints(maxWidth: 288.0),
                    child: taskCardWidget, // Передаем инстанс, а не результат build()
                  ),
                ),
                childWhenDragging: Opacity(
                  opacity: 0.5,
                  child: taskCardWidget,
                ),
                child: taskCardWidget,
              );
            },
            separatorBuilder: (context, index) => const SizedBox(height: 8.0),
          ),
        );
      },
      onWillAccept: (Task? incomingTask) {
        return incomingTask != null && incomingTask.status != status;
      },
      onAccept: (Task incomingTask) {
        onTaskStatusChanged(incomingTask, status);
      },
    );
  }
}
```

```
// lib/widgets/kanban_board/kanban_board_widget.dart
import 'package:flutter/material.dart';
import '../../models/task_model.dart';
import 'kanban_column_widget.dart';
import 'package:flutter/foundation.dart' show listEquals;

const double _baseColumnWidth = 290.0;
const double _minColumnWidth = 290.0;
const double _fixedSpaceBetweenColumns = 64.0;

class KanbanBoardWidget extends StatefulWidget {
  final List<Task> tasks;
  final Function(Task, KanbanColumnStatus) onTaskStatusChanged;
  final Function(Task) onTaskTap;
  final ValueChanged<Task>? onTaskDelete; // <<< ДОБАВЛЕНО: Коллбэк для удаления

  const KanbanBoardWidget({
    Key? key,
    required this.tasks,
    required this.onTaskStatusChanged,
    required this.onTaskTap,
    this.onTaskDelete, // <<< ДОБАВЛЕНО
  }) : super(key: key);

  @override
  _KanbanBoardWidgetState createState() => _KanbanBoardWidgetState();
}

class _KanbanBoardWidgetState extends State<KanbanBoardWidget> {
  late Map<KanbanColumnStatus, List<Task>> _columnTasks;
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _organizeTasks();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(covariant KanbanBoardWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.tasks.length != widget.tasks.length || !listEquals(oldWidget.tasks, widget.tasks)) {
      _organizeTasks();
    }
  }

  void _organizeTasks() {
    _columnTasks = {
      for (var status in KanbanColumnStatus.values) status: []
    };
    // Фильтруем только не удаленные задачи для отображения на доске
    for (var task in widget.tasks.where((task) => !task.isDeleted)) {
      _columnTasks[task.status]?.add(task);
    }
    _columnTasks.forEach((status, taskList) {
      taskList.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    });
  }

  void _handleLocalTaskStatusChange(Task task, KanbanColumnStatus newStatus) {
    final oldStatus = task.status;
    if (oldStatus == newStatus) return;

    setState(() {
      _columnTasks[oldStatus]?.removeWhere((t) => t.taskId == task.taskId);
      final updatedTask = task.copyWith(status: newStatus, updatedAt: DateTime.now());
      _columnTasks[newStatus]?.add(updatedTask);
      _columnTasks[newStatus]?.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    });
    widget.onTaskStatusChanged(task, newStatus);
  }

  Widget _buildVerticalDivider(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      width: 1.5,
      color: theme.colorScheme.outlineVariant,
    );
  }

  Widget _buildColumnSection(
      BuildContext context,
      KanbanColumnStatus status,
      double columnWidth,
      ) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return SizedBox(
      width: columnWidth,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Container(
            width: columnWidth,
            height: 72,
            alignment: Alignment.center,
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Text(
              status.title.toUpperCase(),
              textAlign: TextAlign.center,
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: colorScheme.onSurfaceVariant,
                letterSpacing: 0.5,
              ),
            ),
          ),
          Expanded(
            child: KanbanColumnWidget(
              status: status,
              tasks: _columnTasks[status] ?? [],
              onTaskStatusChanged: _handleLocalTaskStatusChange,
              onTaskTap: widget.onTaskTap, // Передаем обработчик тапа
              onTaskDelete: widget.onTaskDelete, // <<< ПЕРЕДАЕМ КОЛЛБЭК УДАЛЕНИЯ
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final List<KanbanColumnStatus> statuses = KanbanColumnStatus.values;
    final int numberOfColumns = statuses.length;
    final int numberOfDividers = (numberOfColumns - 1).clamp(0, double.infinity).toInt();

    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainer,
        border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
        borderRadius: BorderRadius.circular(16.0),
        boxShadow: [
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.08),
            blurRadius: 12.0,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      padding: const EdgeInsets.symmetric(
        horizontal: 24.0,
        vertical: 16.0,
      ),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final double availableWidth = constraints.maxWidth;
          double calculatedColumnWidth;
          bool enableScroll = false;

          final double totalDividersWidth = numberOfDividers * _fixedSpaceBetweenColumns;
          final double availableWidthForColumns = availableWidth - totalDividersWidth;
          double idealColumnWidth = (availableWidthForColumns / numberOfColumns).floorToDouble();

          if (idealColumnWidth >= _baseColumnWidth) {
            calculatedColumnWidth = idealColumnWidth;
          } else if (idealColumnWidth >= _minColumnWidth) {
            calculatedColumnWidth = idealColumnWidth;
          } else {
            calculatedColumnWidth = _minColumnWidth;
            enableScroll = true;
          }

          if ((numberOfColumns * _minColumnWidth + totalDividersWidth) > availableWidth) {
            enableScroll = true;
            if (calculatedColumnWidth < _baseColumnWidth) {
              calculatedColumnWidth = _baseColumnWidth;
            }
          }

          List<Widget> rowChildren = [];
          for (int i = 0; i < numberOfColumns; i++) {
            rowChildren.add(
                _buildColumnSection(context, statuses[i], calculatedColumnWidth)
            );
            if (i < numberOfDividers) {
              rowChildren.add(
                  SizedBox(
                    width: _fixedSpaceBetweenColumns,
                    child: Center(child: _buildVerticalDivider(context)),
                  )
              );
            }
          }

          final totalContentWidth = (numberOfColumns * calculatedColumnWidth) + totalDividersWidth;

          return Scrollbar(
            controller: _scrollController,
            thumbVisibility: true,
            thickness: 8.0,
            radius: const Radius.circular(4.0),
            child: SingleChildScrollView(
              controller: _scrollController,
              scrollDirection: Axis.horizontal,
              physics: (enableScroll || totalContentWidth > availableWidth)
                  ? const ClampingScrollPhysics()
                  : const NeverScrollableScrollPhysics(),
              child: ConstrainedBox(
                constraints: BoxConstraints(minHeight: constraints.maxHeight),
                child: IntrinsicHeight(
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: rowChildren,
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}
```

```
// lib/widgets/auth/social_auth_button.dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';

class SocialAuthButton extends StatelessWidget {
  final String assetPath;
  final String providerName;
  final VoidCallback? onPressed; // <<< ИЗМЕНЕНО НА NULLABLE

  const SocialAuthButton({
    super.key,
    required this.assetPath,
    required this.providerName,
    required this.onPressed, // <<< onPressed теперь может быть null
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final bool isDisabled = onPressed == null; // Проверяем, отключена ли кнопка

    return InkWell(
      onTap: onPressed, // Передаем как есть
      borderRadius: BorderRadius.circular(12),
      splashColor: isDisabled ? Colors.transparent : colorScheme.primary.withOpacity(0.1),
      highlightColor: isDisabled ? Colors.transparent : colorScheme.primary.withOpacity(0.05),
      child: Opacity( // Делаем кнопку полупрозрачной, если она отключена
        opacity: isDisabled ? 0.5 : 1.0,
        child: Container(
          width: 56,
          height: 56,
          decoration: BoxDecoration(
            color: colorScheme.surfaceContainerHighest,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: colorScheme.outline.withOpacity(isDisabled ? 0.3 : 0.7)),
          ),
          child: Center(
            child: SvgPicture.asset(
              assetPath,
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(
                isDisabled ? colorScheme.onSurfaceVariant.withOpacity(0.5) : colorScheme.onSurfaceVariant,
                BlendMode.srcIn,
              ),
              semanticsLabel: 'Войти через $providerName',
            ),
          ),
        ),
      ),
    );
  }
}
```

```
// lib/widgets/auth/RegisterForm.dart
import 'package:flutter/material.dart';
import '../CustomInputField.dart';
import '../../core/constants/app_strings.dart';

class RegisterForm extends StatelessWidget {
  final GlobalKey<FormState> formKey;
  final TextEditingController usernameController;
  final TextEditingController emailController;
  final TextEditingController passwordController;
  final TextEditingController confirmPasswordController;
  final VoidCallback onSubmit;
  final AutovalidateMode autovalidateMode;
  // Раскомментируй, если будешь передавать FocusNodes из AuthScreenState
  // final FocusNode? usernameFocusNode;
  // final FocusNode? emailFocusNode;
  // final FocusNode? passwordFocusNode;
  // final FocusNode? confirmPasswordFocusNode;

  const RegisterForm({
    super.key,
    required this.formKey,
    required this.usernameController,
    required this.emailController,
    required this.passwordController,
    required this.confirmPasswordController,
    required this.onSubmit,
    required this.autovalidateMode,
    // this.usernameFocusNode,
    // this.emailFocusNode,
    // this.passwordFocusNode,
    // this.confirmPasswordFocusNode,
  });

  @override
  Widget build(BuildContext context) {
    // Пример с локальными FocusNode, если не передаются извне
    final FocusNode localEmailFocusNode = FocusNode();
    final FocusNode localPasswordFocusNode = FocusNode();
    final FocusNode localConfirmPasswordFocusNode = FocusNode();

    return Form(
      key: formKey,
      autovalidateMode: autovalidateMode,
      child: Column(
        children: [
          CustomInputField(
            label: AppStrings.usernameLabel,
            controller: usernameController,
            // focusNode: usernameFocusNode,
            textInputAction: TextInputAction.next,
            onFieldSubmitted: (_) {
              // FocusScope.of(context).requestFocus(emailFocusNode ?? localEmailFocusNode);
              FocusScope.of(context).requestFocus(localEmailFocusNode);
            },
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return AppStrings.usernameRequiredError;
              }
              if (value.trim().length < 3) {
                return 'Логин должен быть не менее 3 символов';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          CustomInputField(
            label: AppStrings.emailLabel,
            controller: emailController,
            // focusNode: emailFocusNode ?? localEmailFocusNode,
            focusNode: localEmailFocusNode,
            keyboardType: TextInputType.emailAddress, // Используем keyboardType из CustomInputField
            textInputAction: TextInputAction.next,
            onFieldSubmitted: (_) {
              // FocusScope.of(context).requestFocus(passwordFocusNode ?? localPasswordFocusNode);
              FocusScope.of(context).requestFocus(localPasswordFocusNode);
            },
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return AppStrings.emailRequiredError;
              }
              final emailRegExp = RegExp(r"^[a-zA-Z0-9.a-zA-Z0-9.!#$%&'*+-/=?^_`{|}~]+@[a-zA-Z0-9]+\.[a-zA-Z]+");
              if (!emailRegExp.hasMatch(value.trim())) {
                return AppStrings.invalidEmailError;
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          CustomInputField(
            label: AppStrings.passwordLabel,
            controller: passwordController,
            // focusNode: passwordFocusNode ?? localPasswordFocusNode,
            focusNode: localPasswordFocusNode,
            isPassword: true,
            textInputAction: TextInputAction.next,
            onFieldSubmitted: (_) {
              // FocusScope.of(context).requestFocus(confirmPasswordFocusNode ?? localConfirmPasswordFocusNode);
              FocusScope.of(context).requestFocus(localConfirmPasswordFocusNode);
            },
            validator: (value) {
              if (value == null || value.isEmpty) {
                return AppStrings.passwordRequiredError;
              }
              if (value.length < 6) {
                return AppStrings.passwordMinLengthError;
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          CustomInputField(
            label: AppStrings.confirmPasswordLabel,
            controller: confirmPasswordController,
            // focusNode: confirmPasswordFocusNode ?? localConfirmPasswordFocusNode,
            focusNode: localConfirmPasswordFocusNode,
            isPassword: true,
            textInputAction: TextInputAction.done,
            onFieldSubmitted: (_) => onSubmit(),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return AppStrings.confirmPasswordRequiredError;
              }
              if (value != passwordController.text) {
                return AppStrings.passwordsDoNotMatchError;
              }
              return null;
            },
          ),
        ],
      ),
    );
  }
}
```

```
// lib/widgets/auth/LoginForm.dart
import 'package:flutter/material.dart';
import '../CustomInputField.dart';
import '../../core/constants/app_strings.dart';

class LoginForm extends StatelessWidget {
  final GlobalKey<FormState> formKey;
  final TextEditingController emailController;
  final TextEditingController passwordController;
  final VoidCallback onSubmit;
  final AutovalidateMode autovalidateMode;
  // final FocusNode? emailFocusNode; // Раскомментируй, если будешь передавать
  // final FocusNode? passwordFocusNode; // Раскомментируй, если будешь передавать

  const LoginForm({
    super.key,
    required this.formKey,
    required this.emailController,
    required this.passwordController,
    required this.onSubmit,
    required this.autovalidateMode,
    // this.emailFocusNode, // Раскомментируй, если будешь передавать
    // this.passwordFocusNode, // Раскомментируй, если будешь передавать
  });

  @override
  Widget build(BuildContext context) {
    // Если FocusNode не передается, можно создать локальный здесь,
    // но тогда его нужно будет диспозить, что делает StatelessWidget менее подходящим.
    // Лучше передавать из AuthScreenState.
    final FocusNode localPasswordFocusNode = FocusNode(); // Пример локального

    return Form(
      key: formKey,
      autovalidateMode: autovalidateMode,
      child: Column(
        children: [
          CustomInputField(
            label: AppStrings.emailOrLoginLabel,
            controller: emailController,
            // focusNode: emailFocusNode, // Используй переданный, если есть
            keyboardType: TextInputType.emailAddress, // Используем keyboardType из CustomInputField
            textInputAction: TextInputAction.next,
            onFieldSubmitted: (_) {
              // FocusScope.of(context).requestFocus(passwordFocusNode ?? localPasswordFocusNode);
              FocusScope.of(context).requestFocus(localPasswordFocusNode); // Пример с локальным
            },
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Введите email или логин';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),
          CustomInputField(
            label: AppStrings.passwordLabel,
            controller: passwordController,
            // focusNode: passwordFocusNode ?? localPasswordFocusNode, // Используй переданный или локальный
            focusNode: localPasswordFocusNode, // Пример с локальным
            isPassword: true,
            textInputAction: TextInputAction.done,
            onFieldSubmitted: (_) => onSubmit(),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return AppStrings.passwordRequiredError;
              }
              return null;
            },
          ),
        ],
      ),
    );
  }
}
```

```
// lib/widgets/auth/auth_screen_logo.dart
import 'dart:ui'; // Для ImageFilter.blur
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../../core/constants/app_assets.dart'; // Путь к ассетам
import '../../core/utils/responsive_utils.dart'; // Для адаптивности

class AuthScreenLogo extends StatelessWidget {
  const AuthScreenLogo({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Адаптивный размер логотипа
    final double logoSize = ResponsiveUtil.isMobile(context) ? 80.0 : 96.0;
    final double baseExpandedSize = 96.0; // Базовый размер, от которого считаем пропорции

    // Пропорциональный радиус и блюр
    final double borderRadius = 12.0 * (logoSize / baseExpandedSize);
    final double blurSigma = 8.0 * (logoSize / baseExpandedSize); // Блюр тоже можно сделать пропорциональным

    return Stack(
      alignment: Alignment.center,
      children: [
        // Размытый фон
        SizedBox(
          width: logoSize,
          height: logoSize,
          child: ClipRRect(
            borderRadius: BorderRadius.circular(borderRadius),
            child: ImageFiltered(
              imageFilter: ImageFilter.blur(sigmaX: blurSigma, sigmaY: blurSigma),
              child: SvgPicture.asset(
                AppAssets.logo,
                fit: BoxFit.contain,
                colorFilter: ColorFilter.mode(
                  colorScheme.onSurface.withOpacity(0.05), // Цвет для блюра из темы
                  BlendMode.srcATop,
                ),
              ),
            ),
          ),
        ),
        // Основной логотип
        SizedBox(
          width: logoSize,
          height: logoSize,
          child: SvgPicture.asset(
            AppAssets.logo,
            fit: BoxFit.contain,
            // Если SVG монохромный и его цвет должен зависеть от темы:
            // colorFilter: ColorFilter.mode(colorScheme.primary, BlendMode.srcIn),
          ),
        ),
      ],
    );
  }
}
```

```
// lib/widgets/auth/auth_form_container.dart
import 'package:flutter/material.dart';

class AuthFormContainer extends StatelessWidget {
  final Widget child;

  const AuthFormContainer({
    super.key,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final screenWidth = MediaQuery.of(context).size.width;

    // Адаптивная ширина контейнера
    // Порог 700px для переключения на более широкую версию
    final bool isWideScreen = screenWidth > 700;
    final double containerWidth = isWideScreen ? 560.0 : screenWidth * 0.92; // Уменьшил немного макс ширину и увеличил % для мобильных

    // Адаптивные внутренние отступы
    final double horizontalPadding = isWideScreen ? 64.0 : 24.0; // Увеличил для десктопа
    final double verticalPadding = isWideScreen ? 32.0 : 24.0;

    return Container(
      width: containerWidth,
      padding: EdgeInsets.symmetric(
        vertical: verticalPadding,
        horizontal: horizontalPadding,
      ),
      decoration: BoxDecoration(
        // Цвет фона контейнера. surfaceContainerHigh обычно немного светлее/темнее, чем surface
        color: colorScheme.surfaceContainerHigh,
        // Граница контейнера
        border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5)),
        borderRadius: BorderRadius.circular(16), // Стандартный радиус для M3
        boxShadow: [ // Тень для контейнера
          BoxShadow(
            color: theme.shadowColor.withOpacity(colorScheme.brightness == Brightness.dark ? 0.20 : 0.10),
            blurRadius: 16, // Более мягкая тень
            offset: const Offset(0, 6), // Небольшое смещение тени
          ),
        ],
      ),
      child: child,
    );
  }
}
```

```
// client/lib/services/http_client_factory_web.dart
import 'package:http/http.dart' as http;
import 'package:http/browser_client.dart';
import 'package:flutter/foundation.dart' show debugPrint;

http.Client createHttpClient() {
  final client = BrowserClient();
  client.withCredentials = true;
  debugPrint("ApiService: Using BrowserClient with withCredentials=true for web");
  return client;
}
```

```
// client/lib/services/http_client_factory_io.dart
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart' show debugPrint;

http.Client createHttpClient() {
  debugPrint("ApiService: Using default http.Client for non-web platform");
  return http.Client();
}
```

```
// lib/services/api_service.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io' show Platform, SocketException, HttpException;
import '../models/task_model.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:http/http.dart' as http;
import 'http_client_factory_io.dart'
if (dart.library.html) 'http_client_factory_web.dart' as httpClientFactory;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter/foundation.dart' show Uint8List, debugPrint, kIsWeb;

// --- Models ---
class UserProfile {
  final int userId;
  final String login;
  final String email;
  final String? avatarUrl;
  final String? theme;
  final String? accentColor;
  final bool? isSidebarCollapsed;
  // Раскомментируем поля, которые есть в Swagger ответе /profile
  final bool? hasMobileDeviceLinked;
  final bool? notificationsEmailEnabled;
  final bool? notificationsPushTaskAssigned;
  final bool? notificationsPushTaskDeadline;
  final bool? notificationsPushTeamMention;


  UserProfile({
    required this.userId,
    required this.login,
    required this.email,
    this.avatarUrl,
    this.theme,
    this.accentColor,
    this.isSidebarCollapsed,
    this.hasMobileDeviceLinked,
    this.notificationsEmailEnabled,
    this.notificationsPushTaskAssigned,
    this.notificationsPushTaskDeadline,
    this.notificationsPushTeamMention,
  });

  factory UserProfile.fromJson(Map<String, dynamic> json) {
    // Теперь json это содержимое поля "data" из ответа сервера, т.е. непосредственно объект UserProfileResponse
    return UserProfile(
      userId: json['user_id'] as int? ?? 0,
      login: json['login'] as String? ?? '',
      email: json['email'] as String? ?? '',
      avatarUrl: json['avatar_url'] as String?,
      theme: json['theme'] as String?,
      accentColor: json['accent_color'] as String?,
      isSidebarCollapsed: json['is_sidebar_collapsed'] as bool?,
      hasMobileDeviceLinked: json['has_mobile_device_linked'] as bool?,
      notificationsEmailEnabled: json['notifications_email_enabled'] as bool?,
      notificationsPushTaskAssigned: json['notifications_push_task_assigned'] as bool?,
      notificationsPushTaskDeadline: json['notifications_push_task_deadline'] as bool?,
      notificationsPushTeamMention: json['notifications_push_team_mention'] as bool?,
    );
  }
  Map<String, dynamic> toJson() => {
    'user_id': userId,
    'login': login,
    'email': email,
    'avatar_url': avatarUrl,
    'theme': theme,
    'accent_color': accentColor,
    'is_sidebar_collapsed': isSidebarCollapsed,
    'has_mobile_device_linked': hasMobileDeviceLinked,
    'notifications_email_enabled': notificationsEmailEnabled,
    'notifications_push_task_assigned': notificationsPushTaskAssigned,
    'notifications_push_task_deadline': notificationsPushTaskDeadline,
    'notifications_push_team_mention': notificationsPushTeamMention,
  };
}

class AuthResponse {
  final String accessToken;
  final String? refreshToken;

  AuthResponse({required this.accessToken, this.refreshToken});

  factory AuthResponse.fromJson(Map<String, dynamic> json) {
    final data = json['data'] as Map<String, dynamic>?;
    return AuthResponse(
      accessToken: data?['access_token'] as String? ?? '',
      refreshToken: data?['refresh_token'] as String?,
    );
  }
}
// --- End of models ---

// --- Exceptions ---
class ApiException implements Exception {
  final int statusCode;
  final String message;
  ApiException(this.statusCode, this.message);
  @override
  String toString() => 'ApiException: $statusCode, $message';
}

class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);
  @override
  String toString() => 'NetworkException: $message';
}

class EmailNotConfirmedException implements Exception {
  final String message = 'Email не подтвержден. Пожалуйста, проверьте свою почту.';
  EmailNotConfirmedException();
  @override
  String toString() => message;
}

class TokenRefreshedException implements Exception {
  final String message = 'Access token was refreshed. Please retry the request.';
  TokenRefreshedException();
  @override
  String toString() => message;
}
// --- End of Exceptions ---


class ApiService {
  static String _baseUrl = kIsWeb
      ? 'https://localhost:8080/v1'
      : (Platform.isAndroid ? 'https://10.0.2.2:8080/v1' : 'https://localhost:8080/v1');

  static const String _accessTokenKeyPrefs = 'auth_access_token_prefs_v1';
  static const String _refreshTokenKeySecure = 'app_refresh_token_secure_v1';

  String? _cachedAccessToken;
  bool _isRefreshingToken = false;
  Completer<void>? _refreshTokenCompleter;

  final http.Client _httpClient;
  final FlutterSecureStorage _secureStorage = const FlutterSecureStorage();

  ApiService() : _httpClient = httpClientFactory.createHttpClient();

  Future<void> _loadAccessToken() async {
    if (_cachedAccessToken != null) return;
    final prefs = await SharedPreferences.getInstance();
    _cachedAccessToken = prefs.getString(_accessTokenKeyPrefs);
    debugPrint("ApiService (_loadAccessToken): Loaded access token from prefs: ${_cachedAccessToken != null ? 'found' : 'not found'}");
  }

  Future<void> _saveAccessToken(String token) async {
    _cachedAccessToken = token;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_accessTokenKeyPrefs, token);
    debugPrint("ApiService (_saveAccessToken): Access token saved to SharedPreferences.");
  }

  Future<void> clearLocalAccessToken() async {
    _cachedAccessToken = null;
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_accessTokenKeyPrefs);
    debugPrint("ApiService (clearLocalAccessToken): Access token cleared from SharedPreferences.");
  }

  Future<Map<String, String>> _getHeaders({bool includeAuth = true, bool isMultipart = false}) async {
    await _loadAccessToken();
    final headers = {
      if (!isMultipart) 'Content-Type': 'application/json; charset=UTF-8',
      'Accept': 'application/json',
    };
    if (includeAuth && _cachedAccessToken != null) {
      headers['Authorization'] = 'Bearer $_cachedAccessToken';
    }
    return headers;
  }

  Future<T> _handleResponse<T>(
      http.Response response,
      T Function(Map<String, dynamic> json) fromJson, {
        bool isList = false,
        bool directData = false, // Если true, fromJson применяется к responseBody целиком, иначе к responseBody['data']
      }) async {
    final String responseBodyString = utf8.decode(response.bodyBytes);
    Map<String, dynamic> responseBody;

    if (response.statusCode == 204) { // No Content
      if (isList) return fromJson({'items': []});
      return fromJson({});
    }

    try {
      responseBody = json.decode(responseBodyString);
    } catch (e) {
      debugPrint("ApiService (_handleResponse): Failed to decode JSON. Status: ${response.statusCode}, Body: $responseBodyString");
      throw ApiException(response.statusCode, "Ошибка сервера: не удалось обработать ответ. Body: $responseBodyString");
    }

    if (response.statusCode >= 200 && response.statusCode < 300) {
      if (directData) {
        // Если directData=true, значит fromJson ожидает весь responseBody
        if (responseBody is Map<String, dynamic>) {
          return fromJson(responseBody);
        } else {
          debugPrint("ApiService (_handleResponse with directData=true): responseBody is not a Map. Body: $responseBodyString");
          try {
            return fromJson(responseBody); // Попытка, если fromJson может обработать не-Map
          } catch (e) {
            debugPrint("ApiService (_handleResponse with directData=true): fromJson failed for non-map responseBody. Error: $e. Body: $responseBodyString");
            throw ApiException(response.statusCode, "Неверный формат ответа (directData, не Map): $responseBodyString");
          }
        }
      } else {
        // Если directData=false (по умолчанию), ищем поле 'data'
        if (responseBody.containsKey('data')) {
          final dataField = responseBody['data'];
          if (isList) {
            if (dataField is List) {
              return fromJson({'items': dataField});
            } else if (dataField is Map<String, dynamic> && dataField.containsKey('items') && dataField['items'] is List) {
              return fromJson(dataField);
            } else {
              debugPrint("ApiService (_handleResponse): Expected list but 'data' is not a list or does not contain 'items'. Data: $dataField");
              throw ApiException(response.statusCode, "Неверный формат ответа: ожидался список в 'data'.");
            }
          } else if (dataField is Map<String, dynamic>) {
            return fromJson(dataField); // Правильный путь для /profile
          } else if (dataField == null && response.statusCode < 300 ) {
            return fromJson({}); // data is null, e.g. {"status":"success", "data":null}
          }
          else {
            debugPrint("ApiService (_handleResponse): 'data' field is not a Map for non-list response (and not null). Data: $dataField");
            throw ApiException(response.statusCode, "Неверный формат поля 'data' в ответе.");
          }
        } else {
          debugPrint("ApiService (_handleResponse): 'data' field missing in successful non-list response (directData=false). ResponseBody: $responseBodyString");
          throw ApiException(response.statusCode, "Отсутствует поле 'data' в успешном ответе.");
        }
      }
    } else if (response.statusCode == 401) {
      debugPrint("ApiService (_handleResponse): Received 401 for ${response.request?.url}. Attempting token refresh.");
      final Map<String, String?>? newTokens = await _tryRefreshTokenInternal();
      if (newTokens != null && newTokens['access_token'] != null) {
        await _saveAccessToken(newTokens['access_token']!);
        if (!kIsWeb && newTokens['refresh_token'] != null && newTokens['refresh_token']!.isNotEmpty) {
          await _secureStorage.write(key: _refreshTokenKeySecure, value: newTokens['refresh_token']!);
          debugPrint("ApiService (_handleResponse): Native refresh token updated in secure storage.");
        } else if (!kIsWeb && (newTokens['refresh_token'] == null || newTokens['refresh_token']!.isEmpty)) {
          debugPrint("ApiService (_handleResponse): Native access token refreshed, existing refresh token in secure storage remains.");
        }
        debugPrint("ApiService (_handleResponse): Token refresh successful. Throwing TokenRefreshedException.");
        throw TokenRefreshedException();
      }
      debugPrint("ApiService (_handleResponse): Token refresh failed. Clearing local access token for ${response.request?.url}.");
      await clearLocalAccessToken();
      String errorMessage = responseBody['error'] as String? ?? 'Ошибка аутентификации. Пожалуйста, войдите снова.';
      if (response.request?.url.path.endsWith('/auth/refresh-token-native') == true || response.request?.url.path.endsWith('/auth/refresh-token') == true ) {
        errorMessage = responseBody['error'] as String? ?? 'Сессия истекла или недействительна. Пожалуйста, войдите снова.';
      }
      throw ApiException(response.statusCode, errorMessage);
    } else {
      throw ApiException(response.statusCode, responseBody['error'] as String? ?? 'Неизвестная ошибка API');
    }
  }


  Future<Map<String, String?>?> _tryRefreshTokenInternal() async {
    if (_isRefreshingToken) {
      debugPrint("ApiService (_tryRefreshTokenInternal): Refresh already in progress. Awaiting.");
      await _refreshTokenCompleter?.future;
      await _loadAccessToken();
      return _cachedAccessToken != null ? {'access_token': _cachedAccessToken, 'refresh_token': null} : null;
    }

    _isRefreshingToken = true;
    _refreshTokenCompleter = Completer<void>();
    debugPrint("ApiService (_tryRefreshTokenInternal): Starting token refresh process.");

    Map<String, String?>? newTokens;
    try {
      if (kIsWeb) {
        newTokens = await _platformTryRefreshTokenForWeb();
      } else {
        final storedRefreshToken = await _secureStorage.read(key: _refreshTokenKeySecure);
        if (storedRefreshToken != null) {
          debugPrint("ApiService (_tryRefreshTokenInternal): Found native refresh token in secure storage.");
          newTokens = await _platformTryRefreshTokenForNative(storedRefreshToken);
        } else {
          debugPrint("ApiService (_tryRefreshTokenInternal): No native refresh token in secure storage.");
        }
      }
    } catch (e) {
      debugPrint("ApiService (_tryRefreshTokenInternal): Exception during platform refresh call: $e");
    } finally {
      _isRefreshingToken = false;
      if (newTokens != null && newTokens['access_token'] != null) {
        if (!_refreshTokenCompleter!.isCompleted) _refreshTokenCompleter!.complete();
      } else {
        if (!_refreshTokenCompleter!.isCompleted) _refreshTokenCompleter!.completeError(Exception("Refresh token failed in _tryRefreshTokenInternal"));
      }
    }

    if (newTokens == null || newTokens['access_token'] == null) {
      debugPrint("ApiService (_tryRefreshTokenInternal): Refresh failed, clearing local access token.");
      await clearLocalAccessToken();
    }
    return newTokens;
  }

  Future<Map<String, String?>?> _platformTryRefreshTokenForWeb() async {
    debugPrint("ApiService (_platformTryRefreshTokenForWeb): Refreshing for web.");
    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/auth/refresh-token'),
        headers: await _getHeaders(includeAuth: false),
      );
      debugPrint("ApiService (_platformTryRefreshTokenForWeb): Response status: ${response.statusCode}, body: ${response.body}");
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseBody = json.decode(utf8.decode(response.bodyBytes));
        if (responseBody['data']?['access_token'] != null) {
          return {'access_token': responseBody['data']['access_token'], 'refresh_token': null};
        }
      }
    } catch (e) {
      debugPrint("ApiService (_platformTryRefreshTokenForWeb): Error: $e");
    }
    return null;
  }

  Future<Map<String, String?>?> _platformTryRefreshTokenForNative(String currentRefreshToken) async {
    debugPrint("ApiService (_platformTryRefreshTokenForNative): Refreshing for native with token: $currentRefreshToken");
    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/auth/refresh-token-native'),
        headers: await _getHeaders(includeAuth: false),
        body: json.encode({'refresh_token': currentRefreshToken}),
      );
      debugPrint("ApiService (_platformTryRefreshTokenForNative): Response status: ${response.statusCode}, body: ${response.body}");
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseBody = json.decode(utf8.decode(response.bodyBytes));
        final newAccessToken = responseBody['data']?['access_token'] as String?;
        final newRefreshToken = responseBody['data']?['refresh_token'] as String?;
        if (newAccessToken != null) {
          return {'access_token': newAccessToken, 'refresh_token': newRefreshToken};
        }
      }
    } catch (e) {
      debugPrint("ApiService (_platformTryRefreshTokenForNative): Error: $e");
    }
    return null;
  }

  Future<bool> tryRefreshTokenForWeb() async {
    final tokens = await _platformTryRefreshTokenForWeb();
    if (tokens != null && tokens['access_token'] != null) {
      await _saveAccessToken(tokens['access_token']!);
      return true;
    }
    return false;
  }

  Future<Map<String, String?>?> tryRefreshTokenForNative(String currentRefreshToken) async {
    return await _platformTryRefreshTokenForNative(currentRefreshToken);
  }

  Future<void> saveAccessTokenForNative(String accessToken) async {
    await _saveAccessToken(accessToken);
  }

  Future<T> _retryRequest<T>(Future<T> Function() requestFunction) async {
    try {
      return await requestFunction();
    } on TokenRefreshedException {
      debugPrint("ApiService (_retryRequest): Token was refreshed. Retrying original request.");
      return await requestFunction();
    }
  }

  // --- User Profile ---
  Future<UserProfile> getUserProfile() async {
    debugPrint("ApiService (getUserProfile): Attempting to get user profile.");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.get(
          Uri.parse('$_baseUrl/profile'),
          headers: await _getHeaders(),
        );
        debugPrint("ApiService (getUserProfile): Response status: ${response.statusCode}");
        if (response.statusCode != 200) {
          debugPrint("ApiService (getUserProfile): Response body for non-200: ${utf8.decode(response.bodyBytes)}");
        }
        // UserProfile.fromJson ожидает Map данных пользователя, который находится в поле 'data'
        // Передаем directData: false (по умолчанию)
        return _handleResponse(response, UserProfile.fromJson);
      } on SocketException {
        throw NetworkException('Нет подключения к интернету');
      } on HttpException {
        throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException {
        throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (getUserProfile): Unknown error: $e');
        throw Exception('Неизвестная ошибка при получении профиля: $e');
      }
    });
  }

  Future<UserProfile> updateUserProfile({
    String? login, String? theme, String? accentColor, bool? isSidebarCollapsed,
    bool? resetAvatar, Map<String, dynamic>? avatarFile,
    // Добавьте поля для настроек уведомлений, если они здесь обновляются
    bool? notificationsEmailEnabled,
    bool? notificationsPushTaskAssigned,
    bool? notificationsPushTaskDeadline,
    bool? notificationsPushTeamMention,
  }) async {
    debugPrint("ApiService (updateUserProfile): Attempting.");
    return _retryRequest(() async {
      try {
        var request = http.MultipartRequest('PUT', Uri.parse('$_baseUrl/profile'));
        request.headers.addAll(await _getHeaders(isMultipart: true));

        final Map<String, dynamic> jsonData = {};
        if (login != null) jsonData['login'] = login;
        if (theme != null) jsonData['theme'] = theme;
        if (accentColor != null) jsonData['accent_color'] = accentColor;
        if (isSidebarCollapsed != null) jsonData['is_sidebar_collapsed'] = isSidebarCollapsed;

        if (notificationsEmailEnabled != null) jsonData['notifications_email_enabled'] = notificationsEmailEnabled;
        if (notificationsPushTaskAssigned != null) jsonData['notifications_push_task_assigned'] = notificationsPushTaskAssigned;
        if (notificationsPushTaskDeadline != null) jsonData['notifications_push_task_deadline'] = notificationsPushTaskDeadline;
        if (notificationsPushTeamMention != null) jsonData['notifications_push_team_mention'] = notificationsPushTeamMention;

        if (resetAvatar != null) jsonData['reset_avatar'] = resetAvatar;

        request.fields['json_data'] = json.encode(jsonData);

        if (avatarFile != null && avatarFile.containsKey('bytes') && avatarFile.containsKey('filename')) {
          request.files.add(http.MultipartFile.fromBytes(
            'avatar', avatarFile['bytes'] as Uint8List, filename: avatarFile['filename'] as String,
          ));
        }
        final streamedResponse = await _httpClient.send(request);
        final response = await http.Response.fromStream(streamedResponse);
        // UserProfile.fromJson ожидает Map данных пользователя, который находится в поле 'data'
        // Передаем directData: false (по умолчанию)
        return _handleResponse(response, UserProfile.fromJson);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (updateUserProfile): Unknown error: $e');
        throw Exception('Неизвестная ошибка при обновлении профиля: $e');
      }
    });
  }

  Future<void> deleteUserAccount() async {
    debugPrint("ApiService (deleteUserAccount): Attempting.");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.delete( Uri.parse('$_baseUrl/profile'), headers: await _getHeaders());
        if (response.statusCode != 204) {
          String errMsg = 'Ошибка удаления (status: ${response.statusCode})';
          try {errMsg = json.decode(utf8.decode(response.bodyBytes))['error'] ?? errMsg;} catch (_){}
          throw ApiException(response.statusCode, errMsg);
        }
        await clearLocalAccessToken();
        if (!kIsWeb) {
          await _secureStorage.delete(key: _refreshTokenKeySecure);
        }
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (deleteUserAccount): Unknown error: $e');
        throw Exception('Неизвестная ошибка при удалении аккаунта: $e');
      }
    });
  }

  // --- Auth ---
  Future<AuthResponse> signUp({
    required String email, String? login, required String password,
  }) async {
    debugPrint("ApiService (signUp): Attempting for email: $email");
    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/auth/sign-up'),
        headers: await _getHeaders(includeAuth: false),
        body: json.encode({'email': email, if (login != null && login.isNotEmpty) 'login': login, 'password': password}),
      );
      final Map<String, dynamic> responseBody = json.decode(utf8.decode(response.bodyBytes));
      if (response.statusCode == 201) return AuthResponse.fromJson(responseBody); // AuthResponse.fromJson ожидает { "data": ... }
      throw ApiException(response.statusCode, responseBody['error'] as String? ?? 'Ошибка регистрации');
    } on SocketException { throw NetworkException('Нет подключения к интернету');
    } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
    } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
    } catch (e) {
      if (e is ApiException || e is NetworkException) rethrow;
      debugPrint('ApiService (signUp): Unknown error: $e');
      throw Exception('Неизвестная ошибка при регистрации: $e');
    }
  }

  Future<AuthResponse> signIn({
    required String password, String? email, String? login,
  }) async {
    debugPrint("ApiService (signIn): Attempting for email: $email, login: $login");
    if ((email == null || email.isEmpty) && (login == null || login.isEmpty)) {
      throw ArgumentError('Необходимо указать email или login.');
    }
    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/auth/sign-in'),
        headers: await _getHeaders(includeAuth: false),
        body: json.encode({
          if (email != null && email.isNotEmpty) 'email': email,
          if (login != null && login.isNotEmpty) 'login': login,
          'password': password,
        }),
      );
      final Map<String, dynamic> responseBody = json.decode(utf8.decode(response.bodyBytes));
      if (response.statusCode == 200) {
        final authData = AuthResponse.fromJson(responseBody); // AuthResponse.fromJson ожидает { "data": ... }
        await _saveAccessToken(authData.accessToken);
        return authData;
      } else if (response.statusCode == 403 && (responseBody['error'] as String?)?.toLowerCase().contains('email not confirmed') == true) {
        throw EmailNotConfirmedException();
      }
      throw ApiException(response.statusCode, responseBody['error'] as String? ?? 'Ошибка входа');
    } on SocketException { throw NetworkException('Нет подключения к интернету');
    } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
    } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
    } catch (e) {
      if (e is ApiException || e is NetworkException || e is EmailNotConfirmedException) rethrow;
      debugPrint('ApiService (signIn): Unknown error: $e');
      throw Exception('Неизвестная ошибка при входе: $e');
    }
  }

  Future<void> logout() async {
    debugPrint("ApiService (logout): Attempting.");
    try {
      await _httpClient.post( Uri.parse('$_baseUrl/auth/logout'), headers: await _getHeaders());
    } catch (e) {
      debugPrint('ApiService (logout): API call error (ignored): $e');
    } finally {
      await clearLocalAccessToken();
      if (!kIsWeb) {
        await _secureStorage.delete(key: _refreshTokenKeySecure);
        debugPrint("ApiService (logout): Native refresh token cleared.");
      }
    }
  }

  String getOAuthUrl(String provider) => '$_baseUrl/auth/$provider';

  // --- Email Confirmation ---
  Future<void> sendConfirmationEmail(String email) async {
    debugPrint("ApiService (sendConfirmationEmail): Attempting for email: $email");
    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/email/send-code'),
        headers: await _getHeaders(includeAuth: false), body: json.encode({'email': email}),
      );
      if (response.statusCode != 202) {
        final Map<String, dynamic> rb = json.decode(utf8.decode(response.bodyBytes));
        throw ApiException(response.statusCode, rb['error'] as String? ?? 'Ошибка отправки кода');
      }
    } on SocketException { throw NetworkException('Нет подключения к интернету');
    } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
    } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
    } catch (e) {
      if (e is ApiException || e is NetworkException) rethrow;
      debugPrint('ApiService (sendConfirmationEmail): Unknown error: $e');
      throw Exception('Неизвестная ошибка при отправке кода подтверждения: $e');
    }
  }

  Future<void> confirmEmail(String email, String code) async {
    debugPrint("ApiService (confirmEmail): Attempting for email: $email");
    try {
      final response = await _httpClient.put(
        Uri.parse('$_baseUrl/email/confirm'),
        headers: await _getHeaders(includeAuth: false), body: json.encode({'email': email, 'code': code}),
      );
      if (response.statusCode != 200) {
        final Map<String, dynamic> rb = json.decode(utf8.decode(response.bodyBytes));
        throw ApiException(response.statusCode, rb['error'] as String? ?? 'Ошибка подтверждения email');
      }
    } on SocketException { throw NetworkException('Нет подключения к интернету');
    } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
    } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
    } catch (e) {
      if (e is ApiException || e is NetworkException) rethrow;
      debugPrint('ApiService (confirmEmail): Unknown error: $e');
      throw Exception('Неизвестная ошибка при подтверждении email: $e');
    }
  }

  // --- Tasks ---
  Future<Task> createTask(Task taskData) async {
    debugPrint("ApiService (createTask): Attempting for title: ${taskData.title}");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.post(
          Uri.parse('$_baseUrl/tasks'),
          headers: await _getHeaders(),
          body: json.encode(taskData.toJsonForCreate()),
        );
        // Swagger: POST /tasks возвращает TaskResponse напрямую (directData=true)
        return _handleResponse(response, Task.fromJson, directData: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (createTask): Unknown error: $e');
        throw Exception('Неизвестная ошибка при создании задачи: $e');
      }
    });
  }

  Future<List<Task>> getTasks({Map<String, String>? queryParams}) async {
    debugPrint("ApiService (getTasks): Attempting with queryParams: $queryParams");
    return _retryRequest(() async {
      try {
        final uri = Uri.parse('$_baseUrl/tasks').replace(queryParameters: queryParams);
        final response = await _httpClient.get(uri, headers: await _getHeaders());
        // Swagger: GET /tasks возвращает массив TaskResponse в 'data' (isList=true, directData=false)
        return _handleResponse(response, (json) {
          final items = json['items'] as List<dynamic>? ?? [];
          return items.map((item) => Task.fromJson(item as Map<String, dynamic>)).toList();
        }, isList: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (getTasks): Unknown error: $e');
        throw Exception('Неизвестная ошибка при получении задач: $e');
      }
    });
  }

  Future<Task> getTaskById(String taskId) async {
    debugPrint("ApiService (getTaskById): Attempting for ID: $taskId");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.get(
          Uri.parse('$_baseUrl/tasks/$taskId'),
          headers: await _getHeaders(),
        );
        // Swagger: GET /tasks/{taskID} возвращает TaskResponse напрямую (directData=true)
        return _handleResponse(response, Task.fromJson, directData: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (getTaskById): Unknown error: $e');
        throw Exception('Неизвестная ошибка при получении задачи: $e');
      }
    });
  }

  Future<Task> updateTask(String taskId, Task taskData) async {
    debugPrint("ApiService (updateTask - PUT): Attempting for ID: $taskId");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.put(
          Uri.parse('$_baseUrl/tasks/$taskId'),
          headers: await _getHeaders(),
          body: json.encode(taskData.toJsonForUpdate()),
        );
        // Swagger: PUT /tasks/{taskID} возвращает TaskResponse напрямую (directData=true)
        return _handleResponse(response, Task.fromJson, directData: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (updateTask): Unknown error: $e');
        throw Exception('Неизвестная ошибка при обновлении задачи: $e');
      }
    });
  }

  Future<Task> patchTask(String taskId, Map<String, dynamic> patchData) async {
    debugPrint("ApiService (patchTask): Attempting for ID: $taskId with data: $patchData");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.patch(
          Uri.parse('$_baseUrl/tasks/$taskId'),
          headers: await _getHeaders(),
          body: json.encode(patchData),
        );
        // Swagger: PATCH /tasks/{taskID} возвращает TaskResponse напрямую (directData=true)
        return _handleResponse(response, Task.fromJson, directData: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (patchTask): Unknown error: $e');
        throw Exception('Неизвестная ошибка при частичном обновлении задачи: $e');
      }
    });
  }

  Future<void> deleteTask(String taskId) async {
    debugPrint("ApiService (deleteTask): Attempting for ID: $taskId");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.delete(
          Uri.parse('$_baseUrl/tasks/$taskId'),
          headers: await _getHeaders(),
        );
        if (response.statusCode != 204) {
          String errMsg = 'Ошибка удаления задачи (status: ${response.statusCode})';
          try {errMsg = json.decode(utf8.decode(response.bodyBytes))['error'] ?? errMsg;} catch (_){}
          throw ApiException(response.statusCode, errMsg);
        }
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (deleteTask): Unknown error: $e');
        throw Exception('Неизвестная ошибка при удалении задачи: $e');
      }
    });
  }

  // --- User Tags ---
  Future<ApiTag> createUserTag({required String name, String? colorHex}) async {
    debugPrint("ApiService (createUserTag): Attempting for name: $name");
    return _retryRequest(() async {
      try {
        final Map<String, dynamic> body = {'name': name};
        if (colorHex != null) body['color'] = colorHex;

        final response = await _httpClient.post(
          Uri.parse('$_baseUrl/user-tags'),
          headers: await _getHeaders(),
          body: json.encode(body),
        );
        // Swagger: POST /user-tags возвращает TagResponse в 'data' (directData=false)
        return _handleResponse(response, ApiTag.fromJson);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (createUserTag): Unknown error: $e');
        throw Exception('Неизвестная ошибка при создании пользовательского тега: $e');
      }
    });
  }

  Future<List<ApiTag>> getUserTags() async {
    debugPrint("ApiService (getUserTags): Attempting.");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.get(
          Uri.parse('$_baseUrl/user-tags'),
          headers: await _getHeaders(),
        );
        // Swagger: GET /user-tags возвращает массив TagResponse в 'data' (isList=true, directData=false)
        return _handleResponse(response, (json) {
          final items = json['items'] as List<dynamic>? ?? [];
          return items.map((item) => ApiTag.fromJson(item as Map<String, dynamic>)).toList();
        }, isList: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (getUserTags): Unknown error: $e');
        throw Exception('Неизвестная ошибка при получении пользовательских тегов: $e');
      }
    });
  }

  Future<ApiTag> updateUserTag(int tagId, {String? name, String? colorHex}) async {
    debugPrint("ApiService (updateUserTag): Attempting for ID: $tagId");
    if (name == null && colorHex == null) {
      throw ArgumentError("Для обновления тега нужно указать имя или цвет.");
    }
    return _retryRequest(() async {
      try {
        final Map<String, dynamic> body = {};
        if (name != null) body['name'] = name;
        if (colorHex != null) body['color'] = colorHex;

        final response = await _httpClient.put(
          Uri.parse('$_baseUrl/user-tags/$tagId'),
          headers: await _getHeaders(),
          body: json.encode(body),
        );
        // Swagger: PUT /user-tags/{tagID} возвращает TagResponse в 'data' (directData=false)
        return _handleResponse(response, ApiTag.fromJson);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (updateUserTag): Unknown error: $e');
        throw Exception('Неизвестная ошибка при обновлении пользовательского тега: $e');
      }
    });
  }

  Future<void> deleteUserTag(int tagId) async {
    debugPrint("ApiService (deleteUserTag): Attempting for ID: $tagId");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.delete(
          Uri.parse('$_baseUrl/user-tags/$tagId'),
          headers: await _getHeaders(),
        );
        if (response.statusCode != 204) {
          String errMsg = 'Ошибка удаления тега (status: ${response.statusCode})';
          try {errMsg = json.decode(utf8.decode(response.bodyBytes))['error'] ?? errMsg;} catch (_){}
          throw ApiException(response.statusCode, errMsg);
        }
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (deleteUserTag): Unknown error: $e');
        throw Exception('Неизвестная ошибка при удалении пользовательского тега: $e');
      }
    });
  }

  // --- Team Tags ---
  Future<List<ApiTag>> getTeamTags(int teamId) async {
    debugPrint("ApiService (getTeamTags): Attempting for team ID: $teamId");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.get(
          Uri.parse('$_baseUrl/teams/$teamId/tags'),
          headers: await _getHeaders(),
        );
        // Swagger: GET /teams/{teamID}/tags возвращает массив TagResponse в 'data' (isList=true, directData=false)
        return _handleResponse(response, (json) {
          final items = json['items'] as List<dynamic>? ?? [];
          return items.map((item) => ApiTag.fromJson(item as Map<String, dynamic>)).toList();
        }, isList: true);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (getTeamTags): Unknown error: $e');
        throw Exception('Неизвестная ошибка при получении тегов команды: $e');
      }
    });
  }

  Future<ApiTag> createTeamTag(int teamId, {required String name, String? colorHex}) async {
    debugPrint("ApiService (createTeamTag): Attempting for team ID: $teamId, name: $name");
    return _retryRequest(() async {
      try {
        final Map<String, dynamic> body = {'name': name};
        if (colorHex != null) body['color'] = colorHex;

        final response = await _httpClient.post(
          Uri.parse('$_baseUrl/teams/$teamId/tags'),
          headers: await _getHeaders(),
          body: json.encode(body),
        );
        // Swagger: POST /teams/{teamID}/tags возвращает TagResponse в 'data' (directData=false)
        return _handleResponse(response, ApiTag.fromJson);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (createTeamTag): Unknown error: $e');
        throw Exception('Неизвестная ошибка при создании тега команды: $e');
      }
    });
  }

  Future<ApiTag> updateTeamTag(int teamId, int tagId, {String? name, String? colorHex}) async {
    debugPrint("ApiService (updateTeamTag): Attempting for team ID: $teamId, tag ID: $tagId");
    if (name == null && colorHex == null) {
      throw ArgumentError("Для обновления тега команды нужно указать имя или цвет.");
    }
    return _retryRequest(() async {
      try {
        final Map<String, dynamic> body = {};
        if (name != null) body['name'] = name;
        if (colorHex != null) body['color'] = colorHex;

        final response = await _httpClient.put(
          Uri.parse('$_baseUrl/teams/$teamId/tags/$tagId'),
          headers: await _getHeaders(),
          body: json.encode(body),
        );
        // Swagger: PUT /teams/{teamID}/tags/{tagID} возвращает TagResponse в 'data' (directData=false)
        return _handleResponse(response, ApiTag.fromJson);
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (updateTeamTag): Unknown error: $e');
        throw Exception('Неизвестная ошибка при обновлении тега команды: $e');
      }
    });
  }

  Future<void> deleteTeamTag(int teamId, int tagId) async {
    debugPrint("ApiService (deleteTeamTag): Attempting for team ID: $teamId, tag ID: $tagId");
    return _retryRequest(() async {
      try {
        final response = await _httpClient.delete(
          Uri.parse('$_baseUrl/teams/$teamId/tags/$tagId'),
          headers: await _getHeaders(),
        );
        if (response.statusCode != 204) {
          String errMsg = 'Ошибка удаления тега команды (status: ${response.statusCode})';
          try {errMsg = json.decode(utf8.decode(response.bodyBytes))['error'] ?? errMsg;} catch (_){}
          throw ApiException(response.statusCode, errMsg);
        }
      } on SocketException { throw NetworkException('Нет подключения к интернету');
      } on HttpException { throw NetworkException('Ошибка сервера (HTTP)');
      } on FormatException { throw NetworkException('Ошибка формата ответа от сервера');
      } catch (e) {
        if (e is ApiException || e is NetworkException || e is TokenRefreshedException) rethrow;
        debugPrint('ApiService (deleteTeamTag): Unknown error: $e');
        throw Exception('Неизвестная ошибка при удалении тега команды: $e');
      }
    });
  }


  void dispose() {
    _httpClient.close();
    debugPrint("ApiService: HttpClient closed.");
  }
}
```

```
// lib/screens/trash_screen.dart
import 'package:client/core/utils/responsive_utils.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../deleted_tasks_provider.dart';
import '../models/task_model.dart';
import '../widgets/trash/deleted_task_card_widget.dart';

class TrashScreen extends StatelessWidget {
  const TrashScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isMobile = ResponsiveUtil.isMobile(context);

    return Consumer<DeletedTasksProvider>(
      builder: (context, deletedTasksProvider, child) {
        final List<Task> deletedTasks = deletedTasksProvider.deletedTasks;

        if (deletedTasks.isEmpty) {
          return Center(
            child: Opacity(
              opacity: 0.7,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.delete_sweep_outlined, size: isMobile ? 56 : 72, color: colorScheme.onSurfaceVariant),
                  const SizedBox(height: 20),
                  Text(
                    "Корзина пуста",
                    style: theme.textTheme.headlineSmall?.copyWith(color: colorScheme.onSurfaceVariant),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Удаленные задачи будут отображаться здесь.",
                    style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          );
        }

        // Основной контент теперь LayoutBuilder с GridView
        Widget gridContent = LayoutBuilder(
          builder: (context, constraints) {
            int crossAxisCount;
            double childAspectRatio;
            double mainAxisSpacing = 12.0;
            double crossAxisSpacing = 12.0;
            EdgeInsets padding = const EdgeInsets.all(16.0);

            if (constraints.maxWidth > 1200) { // Очень большие экраны
              crossAxisCount = 4;
              childAspectRatio = 1.8; // Карточки будут довольно широкими и невысокими
            } else if (constraints.maxWidth > 900) { // Большие экраны
              crossAxisCount = 3;
              childAspectRatio = 1.7;
            } else if (constraints.maxWidth > 600) { // Планшеты / небольшие десктопы
              crossAxisCount = 2;
              childAspectRatio = 1.6;
            } else { // Мобильные
              crossAxisCount = 1;
              childAspectRatio = 2.2; // Карточки будут выше
              mainAxisSpacing = 16.0;
              padding = const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0);
            }
            // Для DeletedTaskCardWidget может понадобиться свой childAspectRatio,
            // так как у него контент может быть выше, чем у TeamCardWidget.
            // Поиграйся со значениями childAspectRatio, чтобы карточки выглядели хорошо.

            return GridView.builder(
              padding: padding,
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: crossAxisCount,
                crossAxisSpacing: crossAxisSpacing,
                mainAxisSpacing: mainAxisSpacing,
                childAspectRatio: childAspectRatio,
              ),
              itemCount: deletedTasks.length,
              itemBuilder: (context, index) {
                final task = deletedTasks[index];
                return DeletedTaskCardWidget(task: task);
              },
            );
          },
        );

        if (isMobile) {
          return Scaffold(
            backgroundColor: Colors.transparent, // Фон страницы из HomeScreen
            body: gridContent,
          );
        }

        // Для десктопа/планшета - встраиваемый контент с контейнером
        return Container(
          margin: const EdgeInsets.only(top: 16.0, right: 16.0, bottom: 16.0),
          decoration: BoxDecoration(
            color: colorScheme.surfaceContainer,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
            boxShadow: [
              BoxShadow(
                color: theme.shadowColor.withOpacity(0.1),
                blurRadius: 8.0,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          clipBehavior: Clip.antiAlias,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Убрали заголовок "Корзина", если есть задачи
              // Если нужен заголовок всегда, можно вернуть:
              // Padding(
              //   padding: const EdgeInsets.only(bottom: 16.0, left: 24.0, top: 24.0, right: 24.0),
              //   child: Text(
              //     'Корзина',
              //     style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              //   ),
              // ),
              Expanded(child: gridContent),
            ],
          ),
        );
      },
    );
  }
}
```

```
// lib/screens/teams_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
// import 'package:uuid/uuid.dart'; // Больше не нужен для моков
import '../models/team_model.dart';
import '../widgets/team/team_card_widget.dart';
// import '../core/routing/app_router_delegate.dart'; // Пока не используется
import '../widgets/CustomInputField.dart';
import 'package:flutter_colorpicker/flutter_colorpicker.dart';
import '../core/utils/responsive_utils.dart';
// import '../services/api_service.dart'; // TODO: Добавить для загрузки команд
// import '../auth_state.dart'; // TODO: Добавить для userId

// TODO: Создать TeamProvider для управления состоянием команд

class TeamsScreen extends StatefulWidget {
  const TeamsScreen({Key? key}) : super(key: key);

  @override
  State<TeamsScreen> createState() => _TeamsScreenState();
}

class _TeamsScreenState extends State<TeamsScreen> {
  // Список _teams будет загружаться из TeamProvider
  List<TeamModel> _teams = []; // Пока оставим пустым, или можно инициализировать в initState из провайдера
  bool _isLoadingTeams = true; // Флаг для отображения загрузки
  String? _teamsError;       // Для отображения ошибок

  final TextEditingController _teamNameController = TextEditingController();
  final TextEditingController _teamDescriptionController = TextEditingController();
  Color _selectedTeamColor = Colors.blue.shade700;

  @override
  void initState() {
    super.initState();
    _fetchTeams(); // Загружаем команды при инициализации
  }

  Future<void> _fetchTeams() async {
    setState(() {
      _isLoadingTeams = true;
      _teamsError = null;
    });
    // TODO: Заменить на вызов метода из TeamProvider, который вызовет ApiService
    // try {
    //   final teamProvider = Provider.of<TeamProvider>(context, listen: false);
    //   await teamProvider.fetchTeams();
    //   // _teams = teamProvider.teams; // Если TeamProvider будет хранить список
    // } catch (e) {
    //   setState(() {
    //     _teamsError = "Ошибка загрузки команд: $e";
    //   });
    // }
    // ЗАГЛУШКА на время отсутствия TeamProvider
    await Future.delayed(const Duration(seconds: 1)); // Имитация загрузки
    setState(() {
      // _teams = []; // Пока оставляем пустым, чтобы не было ошибки с placeholder.com
      // Если хочешь видеть какие-то данные для UI, можно временно вернуть моки без NetworkImage
      _teams = [
        TeamModel(name: "Демо Команда 1", description: "Описание демо команды 1.", memberCount: 5, color: Colors.blue.shade700, imageUrl: null),
        TeamModel(name: "Демо Команда 2", memberCount: 3, color: Colors.green.shade600, imageUrl: null),
      ];
      _isLoadingTeams = false;
    });
  }


  @override
  void dispose() {
    _teamNameController.dispose();
    _teamDescriptionController.dispose();
    super.dispose();
  }

  // _getMockTeams() больше не нужен

  void _navigateToTeamDetails(TeamModel team) {
    // TODO: Реализовать навигацию на TeamDetailScreen
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Переход к команде: ${team.name} (в разработке)')),
    );
  }

  void _showCreateTeamDialog(BuildContext context) {
    final GlobalKey<FormState> formKey = GlobalKey<FormState>();
    _teamNameController.clear();
    _teamDescriptionController.clear();
    _selectedTeamColor = Colors.primaries[(_teams.length % Colors.primaries.length)];

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
            builder: (stfContext, stfSetState) {
              return AlertDialog(
                title: const Text("Создать новую команду"),
                contentPadding: const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 0.0),
                actionsPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                content: SingleChildScrollView(
                  child: Form(
                    key: formKey,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: <Widget>[
                        CustomInputField(
                          label: "Название команды (макс. 30)",
                          controller: _teamNameController,
                          inputFormatters: [LengthLimitingTextInputFormatter(30)],
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Название команды не может быть пустым';
                            }
                            if (value.trim().length < 3) return 'Минимум 3 символа';
                            return null;
                          },
                          textInputAction: TextInputAction.next,
                        ),
                        const SizedBox(height: 16),
                        CustomInputField(
                          label: "Описание (макс. 100, опционально)",
                          controller: _teamDescriptionController,
                          keyboardType: TextInputType.multiline,
                          textInputAction: TextInputAction.done,
                          inputFormatters: [LengthLimitingTextInputFormatter(100)],
                        ),
                        const SizedBox(height: 20),
                        Text("Цвет команды:", style: theme.textTheme.titleSmall?.copyWith(color: colorScheme.onSurfaceVariant)),
                        const SizedBox(height: 10),
                        InkWell(
                          onTap: () async {
                            Color? pickedColor = await _showColorPickerDialog(context, _selectedTeamColor);
                            if (pickedColor != null) {
                              stfSetState(() { _selectedTeamColor = pickedColor; });
                            }
                          },
                          borderRadius: BorderRadius.circular(8),
                          child: Container(
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                                color: _selectedTeamColor.withOpacity(0.15),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(color: _selectedTeamColor, width: 1.5)
                            ),
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text("Выбрать цвет", style: TextStyle(color: _selectedTeamColor, fontWeight: FontWeight.w500)),
                                Container(width: 24, height: 24, decoration: BoxDecoration(color: _selectedTeamColor, shape: BoxShape.circle)),
                              ],
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                actions: <Widget>[
                  TextButton(
                    child: const Text('Отмена'),
                    onPressed: () => Navigator.of(dialogContext).pop(),
                  ),
                  TextButton(
                    child: Text('Создать', style: TextStyle(fontWeight: FontWeight.bold, color: colorScheme.primary)),
                    onPressed: () async { // Сделаем асинхронным для вызова API
                      if (formKey.currentState!.validate()) {
                        // TODO: Заменить на вызов TeamProvider.createTeam(...)
                        // final teamProvider = Provider.of<TeamProvider>(context, listen: false);
                        // final success = await teamProvider.createTeam(
                        //   name: _teamNameController.text.trim(),
                        //   description: _teamDescriptionController.text.trim().isNotEmpty ? _teamDescriptionController.text.trim() : null,
                        //   colorHex: '#${_selectedTeamColor.value.toRadixString(16).substring(2)}',
                        // );
                        // if (success) {
                        //   Navigator.of(dialogContext).pop();
                        //   ScaffoldMessenger.of(context).showSnackBar(
                        //     SnackBar(content: Text('Команда "${_teamNameController.text.trim()}" создана!')),
                        //   );
                        // } else {
                        //    ScaffoldMessenger.of(context).showSnackBar(
                        //     SnackBar(content: Text('Ошибка создания команды: ${teamProvider.error}'), backgroundColor: Colors.red),
                        //   );
                        // }

                        // Временная заглушка для UI
                        final newTeam = TeamModel(
                          name: _teamNameController.text.trim(),
                          description: _teamDescriptionController.text.trim().isNotEmpty ? _teamDescriptionController.text.trim() : null,
                          memberCount: 1, // Заглушка
                          color: _selectedTeamColor,
                          imageUrl: null, // Изначально без картинки
                        );
                        setState(() { _teams.add(newTeam); });
                        Navigator.of(dialogContext).pop();
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(content: Text('Команда "${newTeam.name}" создана (локально)!')),
                        );
                      }
                    },
                  ),
                ],
              );
            }
        );
      },
    );
  }

  Future<Color?> _showColorPickerDialog(BuildContext context, Color initialColor) {
    Color tempPickedColor = initialColor;
    return showDialog<Color>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Выберите цвет команды'),
          content: SingleChildScrollView(
            child: BlockPicker( // Используем BlockPicker для консистентности
              pickerColor: initialColor,
              onColorChanged: (Color color) {
                tempPickedColor = color;
              },
              availableColors: Colors.primaries.map((e) => e.shade400).toList() // Пример набора цветов
                ..addAll(Colors.accents.map((e) => e.shade200).toList())
                ..addAll([Colors.grey.shade500, Colors.brown.shade400, Colors.black]),
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Отмена'),
              onPressed: () => Navigator.of(context).pop(null),
            ),
            TextButton(
              child: const Text('Выбрать'),
              onPressed: () => Navigator.of(context).pop(tempPickedColor),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    Widget content;

    if (_isLoadingTeams) {
      content = const Center(child: CircularProgressIndicator());
    } else if (_teamsError != null) {
      content = Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text("Ошибка загрузки команд", style: theme.textTheme.titleLarge, textAlign: TextAlign.center),
                const SizedBox(height: 8),
                Text(_teamsError!, style: theme.textTheme.bodyMedium, textAlign: TextAlign.center),
                const SizedBox(height: 20),
                ElevatedButton.icon(
                  icon: const Icon(Icons.refresh),
                  label: const Text("Попробовать снова"),
                  onPressed: _fetchTeams,
                )
              ],
            ),
          )
      );
    } else if (_teams.isEmpty) {
      content = Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              "У вас пока нет команд.",
              style: theme.textTheme.titleMedium?.copyWith(color: colorScheme.onSurfaceVariant),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              icon: const Icon(Icons.add_circle_outline_rounded),
              label: const Text("Создать первую команду"),
              onPressed: () => _showCreateTeamDialog(context),
            )
          ],
        ),
      );
    } else {
      content = LayoutBuilder(
        builder: (context, constraints) {
          int crossAxisCount = 2;
          double childAspectRatio = 1.2;
          double mainAxisSpacing = 12.0;
          double crossAxisSpacing = 12.0;

          if (constraints.maxWidth > 1200) {
            crossAxisCount = 4;
            childAspectRatio = 1.3;
          } else if (constraints.maxWidth > 900) {
            crossAxisCount = 3;
            childAspectRatio = 1.25;
          } else if (constraints.maxWidth > 600) {
            crossAxisCount = 2;
            childAspectRatio = 1.15;
          } else {
            crossAxisCount = 1;
            childAspectRatio = ResponsiveUtil.isMobile(context) ? 2.0 : 1.6; // Немного выше для мобильных карточек команд
            mainAxisSpacing = 16.0;
          }

          return GridView.builder(
            padding: const EdgeInsets.all(16.0),
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: crossAxisCount,
              crossAxisSpacing: crossAxisSpacing,
              mainAxisSpacing: mainAxisSpacing,
              childAspectRatio: childAspectRatio,
            ),
            itemCount: _teams.length,
            itemBuilder: (context, index) {
              final team = _teams[index];
              return TeamCardWidget(
                team: team,
                onTap: () => _navigateToTeamDetails(team),
              );
            },
          );
        },
      );
    }

    return Container(
        margin: const EdgeInsets.only(top: 16.0, right: 16.0, bottom: 16.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainer,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.1),
              blurRadius: 8.0,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        clipBehavior: Clip.antiAlias,
        child: Stack(
          children: [
            content,
            if (!ResponsiveUtil.isMobile(context))
              Positioned(
                bottom: 24,
                right: 24,
                child: FloatingActionButton.extended(
                  onPressed: () => _showCreateTeamDialog(context),
                  label: const Text("Создать команду"),
                  icon: const Icon(Icons.group_add_outlined),
                ),
              )
          ],
        )
    );
  }
}
```

```
// lib/screens/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../auth_state.dart';
import '../services/api_service.dart'; // UserProfile используется AuthState
import '../theme_provider.dart';
import '../tag_provider.dart';
import '../core/utils/responsive_utils.dart';
import '../models/task_model.dart'; // Для ApiTag
import 'package:flutter_colorpicker/flutter_colorpicker.dart';
import '../widgets/settings/profile_settings_tab.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;

  final Map<Color, String> _availableAccentColors = {
    const Color(0xFF5457FF): "Ультрамарин",
    const Color(0xFFFF5454): "Коралл",
    const Color(0xFFE2FF54): "Лайм",
    Colors.green.shade600: "Зеленый",
    Colors.orange.shade700: "Оранжевый",
    Colors.purple.shade400: "Фиолетовый",
    Colors.teal.shade500: "Бирюзовый",
    Colors.pink.shade400: "Розовый",
    Colors.amber.shade700: "Янтарный",
  };

  final Map<ThemeMode, String> _themeOptions = {
    ThemeMode.light: "Светлая",
    ThemeMode.dark: "Тёмная",
    ThemeMode.system: "Системная",
  };

  final List<String> _tabLabels = ["Внешний вид", "Теги", "Уведомления", "Профиль"];
  final List<IconData> _tabIcons = [
    Icons.palette_outlined,
    Icons.label_outline_rounded,
    Icons.notifications_none_outlined,
    Icons.person_outline_rounded
  ];

  final TextEditingController _tagNameController = TextEditingController();
  Color _selectedTagColorForDialog = Colors.blue.shade600;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _tabLabels.length, vsync: this);
    _tabController.addListener(_handleTabSelection);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        final tagProvider = Provider.of<TagProvider>(context, listen: false);
        if (tagProvider.userTags.isEmpty && !tagProvider.isLoadingUserTags && tagProvider.error == null) {
          // tagProvider.fetchUserTags();
        }
      }
    });
  }

  void _handleTabSelection() {
    if (!_tabController.indexIsChanging) {
      if (mounted) {
        setState(() {});
      }
    }
  }

  @override
  void dispose() {
    _tabController.removeListener(_handleTabSelection);
    _tabController.dispose();
    _tagNameController.dispose();
    super.dispose();
  }

  Widget _buildInitialsAvatarForTab(BuildContext context, UserProfile user, double radius) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    String initials = "";
    String nameSource = user.login;

    if (nameSource.isNotEmpty) {
      final names = nameSource.split(RegExp(r'\s+')).where((s) => s.isNotEmpty).toList();
      if (names.isNotEmpty && names[0].isNotEmpty) {
        initials = names[0][0];
        if (names.length > 1 && names[1].isNotEmpty) {
          initials += names[1][0];
        } else if (names[0].length > 1) {
          initials = names[0].substring(0, initials.length == 1 ? 2 : 1).trim();
          if (initials.length > 2) initials = initials.substring(0,2);
        }
      }
    }

    initials = initials.toUpperCase();
    if (initials.isEmpty && user.email.isNotEmpty) {
      initials = user.email[0].toUpperCase();
    }
    if (initials.isEmpty) {
      initials = "?";
    }

    Color avatarBackgroundColor = colorScheme.primaryContainer;
    Color avatarTextColor = colorScheme.onPrimaryContainer;

    if (user.accentColor != null && user.accentColor!.isNotEmpty) {
      try {
        final userAccent = Color(int.parse(user.accentColor!.replaceFirst('#', '0xff')));
        avatarTextColor = ThemeData.estimateBrightnessForColor(userAccent) == Brightness.dark
            ? Colors.white.withOpacity(0.95)
            : Colors.black.withOpacity(0.8);
        avatarBackgroundColor = userAccent;
      } catch (_) { /* Используем дефолтные цвета */ }
    }

    return CircleAvatar(
      radius: radius,
      backgroundColor: avatarBackgroundColor,
      child: Text(
        initials,
        style: TextStyle(
          fontSize: radius * (initials.length == 1 ? 0.8 : 0.6),
          fontWeight: FontWeight.bold,
          color: avatarTextColor,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final bool isMobile = ResponsiveUtil.isMobile(context);

    final authStateForDebug = Provider.of<AuthState>(context, listen: false);
    debugPrint("SettingsScreen build: authState.isLoggedIn = ${authStateForDebug.isLoggedIn}");
    debugPrint("SettingsScreen build: authState.currentUser = ${authStateForDebug.currentUser?.toJson()}");

    return Consumer<AuthState>(
        builder: (context, authState, _) {
          final UserProfile? currentUser = authState.currentUser;

          Widget settingsContent = Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildTopTabBar(context, colorScheme, isMobile, currentUser),
              Expanded(
                child: TabBarView(
                  controller: _tabController,
                  children: [
                    KeyedSubtree(key: const ValueKey<String>('appearance_tab'), child: _buildAppearanceSettings(context, theme, colorScheme, isMobile)),
                    KeyedSubtree(key: const ValueKey<String>('tags_tab'), child: _buildTagsSettings(context, theme, colorScheme, isMobile)),
                    KeyedSubtree(key: const ValueKey<String>('notifications_tab'), child: _buildNotificationsSettings(context, theme, colorScheme, isMobile)),
                    const KeyedSubtree(key: ValueKey<String>('profile_tab'), child: ProfileSettingsTab()),
                  ],
                ),
              ),
            ],
          );

          if (isMobile) {
            return settingsContent;
          }

          return Container(
            margin: const EdgeInsets.only(top: 16.0, right: 16.0, bottom: 16.0),
            padding: const EdgeInsets.fromLTRB(24.0, 16.0, 24.0, 16.0),
            decoration: BoxDecoration(
              color: colorScheme.surfaceContainer,
              border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
              borderRadius: BorderRadius.circular(16),
              boxShadow: [
                BoxShadow(
                  color: theme.shadowColor.withOpacity(0.1),
                  blurRadius: 8.0,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            clipBehavior: Clip.antiAlias,
            child: settingsContent,
          );
        }
    );
  }

  Widget _buildTopTabBar(BuildContext context, ColorScheme colorScheme, bool isMobile, UserProfile? currentUser) {
    const double iconTabContainerSizeMobile = 24.0;
    const double iconItselfSizeMobile = 22.0;
    const double avatarRadiusMobile = iconTabContainerSizeMobile / 2;

    if (isMobile) {
      return Material(
        color: colorScheme.surface,
        elevation: 0,
        child: TabBar(
          controller: _tabController,
          tabs: List.generate(_tabLabels.length, (index) {
            bool isProfileTab = index == _tabLabels.length - 1;
            Widget iconWidget;

            if (isProfileTab) {
              if (currentUser?.avatarUrl != null && currentUser!.avatarUrl!.isNotEmpty) {
                iconWidget = SizedBox( // Обертка для CircleAvatar
                  width: iconTabContainerSizeMobile,
                  height: iconTabContainerSizeMobile,
                  child: CircleAvatar(
                    radius: avatarRadiusMobile,
                    backgroundImage: NetworkImage(currentUser.avatarUrl!),
                    backgroundColor: colorScheme.surfaceVariant,
                    onBackgroundImageError: (_, __) {},
                  ),
                );
              } else if (currentUser != null) {
                iconWidget = SizedBox( // Обертка для CircleAvatar
                  width: iconTabContainerSizeMobile,
                  height: iconTabContainerSizeMobile,
                  child: _buildInitialsAvatarForTab(context, currentUser, avatarRadiusMobile),
                );
              } else {
                iconWidget = SizedBox(
                  width: iconTabContainerSizeMobile,
                  height: iconTabContainerSizeMobile,
                  child: CircleAvatar(
                    radius: avatarRadiusMobile,
                    backgroundColor: colorScheme.surfaceVariant,
                    child: Icon(_tabIcons[index], size: iconItselfSizeMobile * 0.75, color: colorScheme.onSurfaceVariant),
                  ),
                );
              }
            } else {
              iconWidget = SizedBox(
                width: iconTabContainerSizeMobile,
                height: iconTabContainerSizeMobile,
                child: Icon(_tabIcons[index], size: iconItselfSizeMobile),
              );
            }
            return Tab(
              height: 56,
              iconMargin: const EdgeInsets.only(bottom: 4),
              icon: iconWidget,
              child: Text(
                _tabLabels[index],
                style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w500),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            );
          }),
          labelColor: colorScheme.primary,
          unselectedLabelColor: colorScheme.onSurfaceVariant,
          indicatorColor: colorScheme.primary,
          indicatorWeight: 2.5,
          indicatorSize: TabBarIndicatorSize.tab,
          splashBorderRadius: BorderRadius.circular(8),
        ),
      );
    }

    // Десктопный TabBar
    const double desktopIconContainerSize = 28.0;
    const double desktopIconItselfSize = 22.0; // Размер иконки внутри контейнера
    const double desktopAvatarRadius = desktopIconContainerSize / 2.2; // Чуть меньше контейнера для лучшего вида


    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12.0),
      decoration: BoxDecoration(
          border: Border(bottom: BorderSide(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0))
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: List.generate(_tabLabels.length, (index) {
          return Padding(
            padding: EdgeInsets.only(left: index == 0 ? 0 : 32),
            child: _buildDesktopTabItem(
              context: context,
              defaultIconData: _tabIcons[index],
              label: _tabLabels[index],
              index: index,
              isActive: _tabController.index == index,
              isProfile: index == _tabLabels.length - 1,
              currentUserForAvatar: index == _tabLabels.length - 1 ? currentUser : null,
              onTap: () {
                if (_tabController.index != index) {
                  _tabController.animateTo(index);
                }
              },
              iconContainerSize: desktopIconContainerSize,
              iconItselfSize: desktopIconItselfSize,
              avatarRadius: desktopAvatarRadius,
            ),
          );
        }),
      ),
    );
  }

  Widget _buildDesktopTabItem({
    required BuildContext context,
    required IconData defaultIconData,
    required String label,
    required int index,
    required bool isActive,
    required double iconContainerSize,
    required double iconItselfSize,
    required double avatarRadius,
    bool isProfile = false,
    UserProfile? currentUserForAvatar,
    required VoidCallback onTap,
  }) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final Color activeColor = colorScheme.primary;
    final Color inactiveColor = colorScheme.onSurfaceVariant;
    final Color currentColor = isActive ? activeColor : inactiveColor;
    final double fontSize = 14;

    Widget iconDisplay;
    if (isProfile) {
      if (currentUserForAvatar?.avatarUrl != null && currentUserForAvatar!.avatarUrl!.isNotEmpty) {
        iconDisplay = CircleAvatar(
          radius: avatarRadius,
          backgroundImage: NetworkImage(currentUserForAvatar.avatarUrl!),
          backgroundColor: colorScheme.surfaceVariant,
          onBackgroundImageError: (_, __) {},
        );
      } else if (currentUserForAvatar != null) {
        iconDisplay = _buildInitialsAvatarForTab(context, currentUserForAvatar, avatarRadius);
      } else {
        iconDisplay = CircleAvatar(
          radius: avatarRadius,
          backgroundColor: colorScheme.surfaceVariant,
          child: Icon(defaultIconData, size: iconItselfSize * 0.75, color: currentColor),
        );
      }
    } else {
      iconDisplay = Icon(defaultIconData, size: iconItselfSize, color: currentColor);
    }

    // Обертка для выравнивания и фона при активности (для профиля)
    Widget iconContentHolder = SizedBox(
      width: iconContainerSize,
      height: iconContainerSize,
      child: isProfile
          ? CircleAvatar( // Внешний круг для фона активности
        radius: iconContainerSize / 2,
        backgroundColor: isActive && isProfile ? activeColor.withOpacity(0.12) : Colors.transparent,
        child: iconDisplay, // Сам аватар/инициалы
      )
          : Center(child: iconDisplay), // Обычная иконка просто центрируется
    );


    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(10),
      hoverColor: activeColor.withOpacity(0.08),
      splashColor: activeColor.withOpacity(0.12),
      highlightColor: activeColor.withOpacity(0.1),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            iconContentHolder,
            const SizedBox(height: 6),
            Text(
              label,
              style: theme.textTheme.labelLarge?.copyWith(
                fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
                fontSize: fontSize,
                color: currentColor,
              ),
            ),
            const SizedBox(height: 6),
            AnimatedContainer(
              duration: const Duration(milliseconds: 250),
              curve: Curves.easeInOut,
              height: 2.5,
              width: isActive ? (fontSize * label.length * 0.6).clamp(30.0, 60.0) : 0,
              decoration: BoxDecoration(
                  color: isActive ? activeColor : Colors.transparent,
                  borderRadius: BorderRadius.circular(1.5)
              ),
            ),
          ],
        ),
      ),
    );
  }

  // ... (остальные методы _buildAppearanceSettings, _buildThemeControl, _buildAccentColorControl, _showAccentColorDialog)
  Widget _buildAppearanceSettings(BuildContext context, ThemeData theme, ColorScheme colorScheme, bool isMobile) {
    return SingleChildScrollView(
      padding: EdgeInsets.only(
        top: isMobile ? 20 : 28,
        bottom: 16,
        left: isMobile ? 16 : 24,
        right: isMobile ? 16 : 24,
      ),
      child: Column(
        children: [
          _buildSettingRow(
            context: context, theme: theme, isMobile: isMobile,
            title: "Тема оформления",
            description: "Выберите светлую, темную или системную тему.",
            control: _buildThemeControl(context, theme, isMobile),
          ),
          _buildSettingRow(
            context: context, theme: theme, isMobile: isMobile,
            title: "Акцентный цвет",
            description: "Персонализируйте приложение, выбрав основной цвет.",
            control: _buildAccentColorControl(context, theme, isMobile),
            isLast: true,
          ),
        ],
      ),
    );
  }

  Widget _buildThemeControl(BuildContext context, ThemeData theme, bool isMobile) {
    final themeProvider = Provider.of<ThemeProvider>(context);
    final colorScheme = theme.colorScheme;

    if (isMobile) {
      return SegmentedButton<ThemeMode>(
        segments: _themeOptions.entries.map((entry) {
          return ButtonSegment<ThemeMode>(
            value: entry.key,
            label: Text(entry.value),
          );
        }).toList(),
        selected: {themeProvider.themeMode},
        onSelectionChanged: (Set<ThemeMode> newSelection) {
          if (newSelection.isNotEmpty) {
            themeProvider.setThemeMode(newSelection.first);
          }
        },
      );
    }

    return DropdownButtonHideUnderline(
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14.0, vertical: 8.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(10.0),
          border: Border.all(color: colorScheme.outline.withOpacity(0.7), width: 1),
        ),
        child: DropdownButton<ThemeMode>(
          value: themeProvider.themeMode,
          icon: Icon(Icons.keyboard_arrow_down_rounded, size: 20, color: colorScheme.onSurfaceVariant),
          dropdownColor: theme.canvasColor,
          borderRadius: BorderRadius.circular(10),
          items: _themeOptions.entries.map((entry) {
            return DropdownMenuItem<ThemeMode>(
              value: entry.key,
              child: Text(entry.value, style: theme.textTheme.bodyMedium),
            );
          }).toList(),
          onChanged: (ThemeMode? newMode) {
            if (newMode != null) {
              themeProvider.setThemeMode(newMode);
            }
          },
          style: theme.textTheme.bodyMedium,
          isDense: true,
        ),
      ),
    );
  }
  Widget _buildAccentColorControl(BuildContext context, ThemeData theme, bool isMobile) {
    final themeProvider = Provider.of<ThemeProvider>(context);
    final currentColor = themeProvider.accentColor;
    final colorScheme = theme.colorScheme;

    Widget displayContent = Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: isMobile ? 28 : 22,
          height: isMobile ? 28 : 22,
          decoration: BoxDecoration(
            color: currentColor,
            borderRadius: BorderRadius.circular(isMobile ? 8 : 6),
            border: Border.all(
              color: (currentColor.computeLuminance() > 0.85 && colorScheme.brightness == Brightness.light) ||
                  (currentColor.computeLuminance() < 0.15 && colorScheme.brightness == Brightness.dark)
                  ? colorScheme.outline.withOpacity(0.5)
                  : Colors.transparent,
              width: 1.5,
            ),
          ),
        ),
        if (!isMobile) ...[
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              _availableAccentColors[currentColor] ?? "Выбранный цвет",
              style: theme.textTheme.bodyMedium,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: 8),
          Icon(Icons.keyboard_arrow_down_rounded, size: 20, color: colorScheme.onSurfaceVariant),
        ]
      ],
    );

    if (isMobile) {
      return ElevatedButton(
        onPressed: () => _showAccentColorDialog(context, themeProvider, theme, isMobile),
        style: ElevatedButton.styleFrom(
          backgroundColor: colorScheme.surfaceContainerHighest,
          foregroundColor: colorScheme.onSurface,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
              side: BorderSide(color: colorScheme.outline.withOpacity(0.7))
          ),
          elevation: 0,
        ),
        child: displayContent,
      );
    }

    return InkWell(
      onTap: () => _showAccentColorDialog(context, themeProvider, theme, isMobile),
      borderRadius: BorderRadius.circular(10),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14.0, vertical: 8.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(10.0),
          border: Border.all(color: colorScheme.outline.withOpacity(0.7), width: 1),
        ),
        child: displayContent,
      ),
    );
  }
  void _showAccentColorDialog(BuildContext context, ThemeProvider themeProvider, ThemeData currentTheme, bool isMobile) {
    final colorScheme = currentTheme.colorScheme;

    Widget dialogContent = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Padding(
          padding: EdgeInsets.only(
              top: isMobile ? 20 : 20,
              left: 24, right: 24,
              bottom: isMobile ? 16 : 16),
          child: Text(
            'Выберите акцентный цвет',
            style: currentTheme.textTheme.titleLarge?.copyWith(fontSize: isMobile ? 18 : 20),
          ),
        ),
        Flexible(
          child: ListView(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
            shrinkWrap: true,
            children: _availableAccentColors.entries.map((entry) {
              final color = entry.key;
              final name = entry.value;
              final bool isSelected = themeProvider.accentColor.value == color.value;

              return Material(
                color: Colors.transparent,
                child: InkWell(
                  onTap: () {
                    themeProvider.setAccentColor(color);
                    Navigator.of(context).pop();
                  },
                  borderRadius: BorderRadius.circular(8),
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    child: Row(
                      children: [
                        Container(
                          width: 26, height: 26,
                          decoration: BoxDecoration(
                            color: color,
                            shape: BoxShape.circle,
                            border: Border.all(
                              color: (color.computeLuminance() > 0.85 && colorScheme.brightness == Brightness.light) ||
                                  (color.computeLuminance() < 0.15 && colorScheme.brightness == Brightness.dark)
                                  ? colorScheme.outline.withOpacity(0.7)
                                  : colorScheme.outline.withOpacity(0.3),
                              width: 1.5,
                            ),
                          ),
                          child: isSelected
                              ? Icon(Icons.check, size: 16, color: color.computeLuminance() > 0.5 ? Colors.black.withOpacity(0.7) : Colors.white.withOpacity(0.8))
                              : null,
                        ),
                        const SizedBox(width: 16),
                        Expanded(child: Text(name, style: currentTheme.textTheme.bodyLarge?.copyWith(fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal, color: isSelected ? colorScheme.primary : colorScheme.onSurface))),
                        if (isSelected && !isMobile) Icon(Icons.arrow_forward_ios_rounded, color: colorScheme.primary.withOpacity(0.7), size: 16),
                      ],
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ),
        if (isMobile)
          Padding(
            padding: const EdgeInsets.all(16.0).copyWith(top: 8),
            child: TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text("ЗАКРЫТЬ"),
            ),
          )
      ],
    );

    if (isMobile) {
      showModalBottomSheet(
          context: context,
          isScrollControlled: true,
          shape: const RoundedRectangleBorder(
              borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
          builder: (BuildContext dialogContext) {
            return Padding(
              padding: EdgeInsets.only(
                bottom: MediaQuery.of(dialogContext).viewInsets.bottom + 8,
                top: 8,
              ),
              child: dialogContent,
            );
          });
    } else {
      showDialog(
        context: context,
        builder: (BuildContext dialogContext) {
          return Dialog(
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 380, maxHeight: 520),
                child: dialogContent,
              )
          );
        },
      );
    }
  }

  Widget _buildTagsSettings(BuildContext context, ThemeData theme, ColorScheme colorScheme, bool isMobile) {
    final tagProvider = Provider.of<TagProvider>(context);
    final List<ApiTag> currentTags = tagProvider.userTags;

    if (tagProvider.isLoadingUserTags && currentTags.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }
    if (tagProvider.error != null && currentTags.isEmpty) {
      return Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text("Ошибка загрузки тегов", style: theme.textTheme.titleLarge, textAlign: TextAlign.center),
                const SizedBox(height: 8),
                Text(tagProvider.error!, style: theme.textTheme.bodyMedium, textAlign: TextAlign.center),
                const SizedBox(height: 20),
                ElevatedButton.icon(
                  icon: const Icon(Icons.refresh),
                  label: const Text("Попробовать снова"),
                  onPressed: () => tagProvider.fetchUserTags(),
                )
              ],
            ),
          )
      );
    }

    return SingleChildScrollView(
      padding: EdgeInsets.all(isMobile ? 16.0 : 24.0).copyWith(
        top: isMobile ? 24 : 32,
        left: isMobile ? 16 : 8,
        right: isMobile ? 16 : 8,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                "Управление тегами",
                style: theme.textTheme.titleLarge?.copyWith(
                  fontSize: isMobile ? 18 : 20,
                ),
              ),
              ElevatedButton.icon(
                icon: const Icon(Icons.add_rounded, size: 20),
                label: const Text("Добавить тег"),
                onPressed: () {
                  _showTagDialog(context, colorScheme: colorScheme, isMobile: isMobile, tagProvider: tagProvider);
                },
              ),
            ],
          ),
          const SizedBox(height: 24),
          if (currentTags.isEmpty && !tagProvider.isLoadingUserTags)
            Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 32.0),
                child: Text(
                  "У вас пока нет тегов.\nНажмите 'Добавить тег', чтобы создать первый.",
                  textAlign: TextAlign.center,
                  style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant),
                ),
              ),
            )
          else if (currentTags.isNotEmpty)
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: currentTags.length,
              itemBuilder: (context, index) {
                final tag = currentTags[index];
                return _buildTagListItem(context, tag, colorScheme, isMobile, tagProvider);
              },
              separatorBuilder: (context, index) => Divider(
                color: colorScheme.outlineVariant.withOpacity(isMobile ? 0.3 : 0.5),
                height: isMobile ? 20 : 28,
                thickness: 1,
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildTagListItem(BuildContext context, ApiTag tag, ColorScheme colorScheme, bool isMobile, TagProvider tagProvider) {
    final theme = Theme.of(context);
    return ListTile(
      contentPadding: EdgeInsets.symmetric(vertical: isMobile ? 4 : 0, horizontal: isMobile ? 0 : 4),
      leading: Container(
        width: 28, height: 28,
        decoration: BoxDecoration(
            color: tag.displayColor,
            shape: BoxShape.circle,
            border: Border.all(color: tag.textColorPreview.withOpacity(0.5), width: 1.5)
        ),
      ),
      title: Text(
        tag.name,
        style: theme.textTheme.titleMedium?.copyWith(
          fontWeight: FontWeight.w500,
          color: colorScheme.onSurface,
        ),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: Icon(Icons.edit_outlined, color: colorScheme.onSurfaceVariant),
            tooltip: "Редактировать тег",
            splashRadius: 22,
            onPressed: () {
              _showTagDialog(context, tagToEdit: tag, colorScheme: colorScheme, isMobile: isMobile, tagProvider: tagProvider);
            },
          ),
          IconButton(
            icon: Icon(Icons.delete_outline_rounded, color: colorScheme.error),
            tooltip: "Удалить тег",
            splashRadius: 22,
            onPressed: () {
              _confirmDeleteTag(context, tag, colorScheme, tagProvider);
            },
          ),
        ],
      ),
    );
  }

  void _showTagDialog(BuildContext context, {ApiTag? tagToEdit, required ColorScheme colorScheme, required bool isMobile, required TagProvider tagProvider}) {
    bool isEditing = tagToEdit != null;
    final themeProvider = Provider.of<ThemeProvider>(context, listen: false);

    _tagNameController.text = isEditing ? tagToEdit!.name : '';
    _selectedTagColorForDialog = isEditing ? tagToEdit!.displayColor :
    _availableAccentColors.keys.firstWhere(
            (c) => c.value != themeProvider.accentColor.value,
        orElse: () => Colors.grey.shade600);

    final GlobalKey<FormState> formKey = GlobalKey<FormState>();
    final currentDialogTheme = Theme.of(context);
    BuildContext? dialogContextForMessenger;

    final List<Color> pickerColors = [
      ..._availableAccentColors.keys,
      Colors.red.shade400, Colors.pink.shade300, Colors.purple.shade300, Colors.deepPurple.shade300,
      Colors.indigo.shade300, Colors.blue.shade400, Colors.lightBlue.shade300, Colors.cyan.shade400,
      Colors.teal.shade400, Colors.green.shade400, Colors.lightGreen.shade400, Colors.lime.shade500,
      Colors.yellow.shade600, Colors.amber.shade600, Colors.orange.shade600, Colors.deepOrange.shade500,
      Colors.brown.shade400, Colors.grey.shade500, Colors.blueGrey.shade400,
    ].toSet().toList();

    showDialog(
      context: context,
      builder: (BuildContext dialogCtx) {
        dialogContextForMessenger = dialogCtx;
        return StatefulBuilder(
            builder: (stfContext, stfSetState) {
              return AlertDialog(
                title: Text(isEditing ? "Редактировать тег" : "Создать новый тег"),
                contentPadding: const EdgeInsets.all(20).copyWith(top:16),
                content: SingleChildScrollView(
                  child: Form(
                    key: formKey,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: <Widget>[
                        TextFormField(
                          controller: _tagNameController,
                          decoration: const InputDecoration(labelText: "Название тега"),
                          style: TextStyle(color: colorScheme.onSurface),
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Название не может быть пустым';
                            }
                            if (tagProvider.userTags.any((t) => t.type == 'user' && t.name.trim().toLowerCase() == value.trim().toLowerCase() && t.id != tagToEdit?.id)) {
                              return 'Тег с таким именем уже существует';
                            }
                            return null;
                          },
                        ),
                        const SizedBox(height: 24),
                        Text("Цвет тега:", style: currentDialogTheme.textTheme.titleSmall?.copyWith(color: colorScheme.onSurfaceVariant)),
                        const SizedBox(height: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                          decoration: BoxDecoration(
                              color: _selectedTagColorForDialog.withOpacity(0.2),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: _selectedTagColorForDialog)
                          ),
                          child: Text(
                            _tagNameController.text.trim().isNotEmpty ? _tagNameController.text.trim() : "Пример тега",
                            style: TextStyle(color: _selectedTagColorForDialog, fontWeight: FontWeight.bold, fontSize: 14),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          height: isMobile ? 180 : 220,
                          width: double.maxFinite,
                          child: SingleChildScrollView(
                            child: BlockPicker(
                              pickerColor: _selectedTagColorForDialog,
                              onColorChanged: (color) => stfSetState(() => _selectedTagColorForDialog = color),
                              availableColors: pickerColors,
                              layoutBuilder: (pickerContext, colors, child) {
                                return GridView.builder(
                                  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                                    crossAxisCount: isMobile ? 5 : 6,
                                    crossAxisSpacing: 8,
                                    mainAxisSpacing: 8,
                                  ),
                                  itemCount: colors.length,
                                  shrinkWrap: true,
                                  physics: const NeverScrollableScrollPhysics(),
                                  itemBuilder: (itemCtx, index) => child(colors[index]),
                                );
                              },
                              itemBuilder: (color, isCurrentColor, changeColor) {
                                return Tooltip(
                                  message: '#${color.value.toRadixString(16).substring(2).toUpperCase()}',
                                  child: GestureDetector(
                                    onTap: changeColor,
                                    child: Container(
                                      decoration: BoxDecoration(
                                          color: color,
                                          borderRadius: BorderRadius.circular(8),
                                          border: isCurrentColor
                                              ? Border.all(color: colorScheme.brightness == Brightness.dark ? Colors.white70 : Colors.black87, width: 2.5)
                                              : Border.all(color: colorScheme.outline.withOpacity(0.3), width: 1),
                                          boxShadow: [
                                            if(isCurrentColor) BoxShadow(color: color.withOpacity(0.4), blurRadius: 4, spreadRadius: 1)
                                          ]
                                      ),
                                      child: isCurrentColor
                                          ? Icon(Icons.check, color: color.computeLuminance() > 0.5 ? Colors.black54 : Colors.white70, size: 18)
                                          : null,
                                    ),
                                  ),
                                );
                              },
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                actionsPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                actions: <Widget>[
                  TextButton(
                    child: const Text('Отмена'),
                    onPressed: () => Navigator.of(dialogCtx).pop(),
                  ),
                  TextButton(
                    child: Text(isEditing ? 'Сохранить' : 'Создать', style: TextStyle(fontWeight: FontWeight.bold, color: colorScheme.primary)),
                    onPressed: () async {
                      if (formKey.currentState!.validate()) {
                        final tagName = _tagNameController.text.trim();
                        final colorHex = '#${_selectedTagColorForDialog.value.toRadixString(16).padLeft(8,'0').substring(2)}';

                        bool success = false;
                        if (isEditing) {
                          success = await tagProvider.updateUserTag(tagToEdit!.id, name: tagName, colorHex: colorHex);
                        } else {
                          success = await tagProvider.createUserTag(name: tagName, colorHex: colorHex);
                        }

                        final BuildContext currentScaffoldContext = dialogContextForMessenger ?? stfContext;
                        if (!mounted) return;

                        if (success) {
                          Navigator.of(dialogCtx).pop();
                        } else {
                          if (mounted && tagProvider.error != null) {
                            ScaffoldMessenger.of(currentScaffoldContext).showSnackBar(
                              SnackBar(content: Text(tagProvider.error!), backgroundColor: Colors.red),
                            );
                            tagProvider.clearError();
                          }
                        }
                      }
                    },
                  ),
                ],
              );
            }
        );
      },
    );
  }

  void _confirmDeleteTag(BuildContext context, ApiTag tag, ColorScheme colorScheme, TagProvider tagProvider) {
    final theme = Theme.of(context);
    BuildContext? dialogContextForMessenger;
    showDialog(
      context: context,
      builder: (BuildContext dialogCtx) {
        dialogContextForMessenger = dialogCtx;
        return AlertDialog(
          title: const Text('Удалить тег?'),
          content: RichText(
            text: TextSpan(
                style: theme.textTheme.bodyLarge?.copyWith(color: colorScheme.onSurfaceVariant),
                children: [
                  const TextSpan(text: "Вы уверены, что хотите удалить тег \""),
                  TextSpan(
                      text: tag.name,
                      style: TextStyle(fontWeight: FontWeight.bold, color: tag.textColorPreview, backgroundColor: tag.backgroundColorPreview)
                  ),
                  const TextSpan(text: "\"?\nЭто действие нельзя будет отменить."),
                ]
            ),
          ),
          actionsPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
          actions: <Widget>[
            TextButton(
              child: const Text('Отмена'),
              onPressed: () => Navigator.of(dialogCtx).pop(),
            ),
            TextButton(
              child: Text('Удалить', style: TextStyle(color: colorScheme.error, fontWeight: FontWeight.bold)),
              onPressed: () async {
                bool success = await tagProvider.deleteUserTag(tag.id);

                final BuildContext currentScaffoldContext = dialogContextForMessenger ?? context;
                if (!mounted) return;

                Navigator.of(dialogCtx).pop();

                if (success) {
                  ScaffoldMessenger.of(currentScaffoldContext).showSnackBar(
                    SnackBar(content: Text('Тег "${tag.name}" удален.')),
                  );
                } else if (tagProvider.error != null) {
                  ScaffoldMessenger.of(currentScaffoldContext).showSnackBar(
                    SnackBar(content: Text(tagProvider.error!), backgroundColor: Colors.red),
                  );
                  tagProvider.clearError();
                }
              },
            ),
          ],
        );
      },
    );
  }

  Widget _buildNotificationsSettings(BuildContext context, ThemeData theme, ColorScheme colorScheme, bool isMobile) {
    return SingleChildScrollView(
      padding: EdgeInsets.all(isMobile ? 16.0 : 24.0).copyWith(top: isMobile ? 24 : 32),
      child: Center(
        child: Opacity(
          opacity: 0.6,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.notifications_off_outlined, size: isMobile ? 48 : 64, color: colorScheme.onSurfaceVariant),
              const SizedBox(height: 16),
              Text(
                "Настройки уведомлений (в разработке)",
                style: theme.textTheme.titleMedium,
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSettingRow({
    required BuildContext context,
    required ThemeData theme,
    required String title,
    required String description,
    required Widget control,
    required bool isMobile,
    bool isLast = false,
  }) {
    final colorScheme = theme.colorScheme;
    if (isMobile) {
      return Padding(
        padding: const EdgeInsets.only(bottom: 12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.only(bottom: 6.0),
              child: Text(title, style: theme.textTheme.titleMedium?.copyWith(fontSize: 17, fontWeight: FontWeight.w600)),
            ),
            Padding(
              padding: const EdgeInsets.only(bottom: 16.0),
              child: Text(description, style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant, fontSize: 14)),
            ),
            SizedBox(
              width: double.infinity,
              child: control,
            ),
            if (!isLast) ...[
              const SizedBox(height: 20),
              Divider(thickness: 1, color: theme.dividerColor.withOpacity(0.5)),
            ] else ... [
              const SizedBox(height: 8),
            ]
          ],
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            flex: 3,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(title, style: theme.textTheme.titleSmall?.copyWith(fontSize: 16, fontWeight: FontWeight.w500)),
                const SizedBox(height: 6),
                Text(description, style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant, fontSize: 14)),
              ],
            ),
          ),
          const SizedBox(width: 40),
          Expanded(
              flex: 2,
              child: Align(alignment: Alignment.centerRight, child: control)
          ),
        ],
      ),
    );
  }
}
```

```
// lib/screens/personal_tasks_kanban_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/task_model.dart';
import '../task_provider.dart';
import '../auth_state.dart';
import '../widgets/kanban_board/kanban_board_widget.dart';
import '../deleted_tasks_provider.dart';
import '../core/utils/responsive_utils.dart';
import '../widgets/tasks/mobile_task_list_widget.dart';
// import '../services/api_service.dart'; // ApiException и NetworkException не используются напрямую

class PersonalTasksKanbanScreen extends StatefulWidget {
  const PersonalTasksKanbanScreen({Key? key}) : super(key: key);

  @override
  State<PersonalTasksKanbanScreen> createState() => _PersonalTasksKanbanScreenState();
}

class _PersonalTasksKanbanScreenState extends State<PersonalTasksKanbanScreen> {

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) { // Добавлена проверка mounted
        final taskProvider = Provider.of<TaskProvider>(context, listen: false);
        // Используем isLoadingList
        if (taskProvider.personalTasks.isEmpty && !taskProvider.isLoadingList && taskProvider.error == null) {
          // taskProvider.fetchAllTasks(); // Раскомментировать, если нужна принудительная перезагрузка
        }
      }
    });
  }

  void _handleTaskStatusChanged(Task task, KanbanColumnStatus newStatus, TaskProvider taskProvider) {
    taskProvider.locallyUpdateTaskStatus(task.taskId, newStatus);
  }

  void _navigateToTaskDetails(BuildContext context, Task task) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Переход к личной задаче: ${task.title} (ID: ${task.taskId}) (в разработке)'),
      ),
    );
  }

  void _handleTaskDelete(BuildContext context, Task task, TaskProvider taskProvider, DeletedTasksProvider deletedTasksProvider) {
    final authState = Provider.of<AuthState>(context, listen: false);
    taskProvider.deleteTask(task.taskId).then((success) {
      if (success && mounted) {
        deletedTasksProvider.moveToTrash(
          task,
          deletedByUserId: authState.currentUser?.userId.toString(),
        );
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Задача "${task.title}" перемещена в корзину')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Ошибка удаления задачи: ${taskProvider.error ?? "Неизвестная ошибка"}'), backgroundColor: Colors.red),
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final taskProvider = Provider.of<TaskProvider>(context);
    final authState = Provider.of<AuthState>(context, listen: false);
    final deletedTasksProvider = Provider.of<DeletedTasksProvider>(context, listen: false);

    final String? currentUserId = authState.currentUser?.userId.toString();

    // Используем isLoadingList
    if (taskProvider.isLoadingList && taskProvider.personalTasks.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (taskProvider.error != null && taskProvider.personalTasks.isEmpty) {
      return Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text(
                  "Ошибка загрузки личных задач",
                  style: Theme.of(context).textTheme.titleLarge,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  taskProvider.error!,
                  style: Theme.of(context).textTheme.bodyMedium,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton.icon(
                  icon: const Icon(Icons.refresh),
                  label: const Text("Попробовать снова"),
                  onPressed: () => taskProvider.fetchAllTasks(),
                )
              ],
            ),
          )
      );
    }

    final List<Task> displayedPersonalTasks = taskProvider.personalTasks;
    bool isMobile = ResponsiveUtil.isMobile(context);

    return Scaffold(
      backgroundColor: Colors.transparent,
      body: isMobile
          ? MobileTaskListWidget(
        tasks: displayedPersonalTasks,
        onTaskStatusChanged: (task, newStatus) => _handleTaskStatusChanged(task, newStatus, taskProvider),
        onTaskTap: (task) => _navigateToTaskDetails(context, task),
        onTaskDelete: (task) => _handleTaskDelete(context, task, taskProvider, deletedTasksProvider),
        currentUserId: currentUserId ?? '',
      )
          : Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0),
        child: KanbanBoardWidget(
          tasks: displayedPersonalTasks,
          onTaskStatusChanged: (task, newStatus) => _handleTaskStatusChanged(task, newStatus, taskProvider),
          onTaskTap: (task) => _navigateToTaskDetails(context, task),
          onTaskDelete: (task) => _handleTaskDelete(context, task, taskProvider, deletedTasksProvider),
        ),
      ),
    );
  }
}
```

```
// lib/screens/home_screen.dart
import 'package:client/core/utils/responsive_utils.dart';
import 'package:client/widgets/tasks/task_edit_dialog.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../widgets/sidebar/sidebar.dart';
import '../widgets/sidebar/right_sidebar.dart';
import 'settings_screen.dart';
import 'personal_tasks_kanban_screen.dart';
import 'teams_screen.dart';
import 'all_tasks_kanban_screen.dart';
import 'trash_screen.dart';
import 'calendar_screen.dart';
import '../core/routing/app_pages.dart';
import '../core/routing/app_router_delegate.dart';
import '../core/routing/app_route_path.dart';

class HomePage extends StatefulWidget {
  final String initialSubRoute;
  final bool showRightSidebarInitially;

  const HomePage({
    super.key,
    required this.initialSubRoute,
    this.showRightSidebarInitially = true,
  });

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {

  Widget _getCurrentPageContent(String subRouteSegment, BuildContext context) {
    switch (subRouteSegment) {
      case AppRouteSegments.settings:
        return const SettingsScreen();
      case AppRouteSegments.allTasks:
        return const AllTasksKanbanScreen();
      case AppRouteSegments.personalTasks:
        return const PersonalTasksKanbanScreen();
      case AppRouteSegments.teams:
        return const TeamsScreen();
      case AppRouteSegments.trash:
        return const TrashScreen();
      case AppRouteSegments.calendar:
        return const CalendarScreen();
      default:
        return const AllTasksKanbanScreen();
    }
  }

  int _getActiveMenuIndexFromSubRoute(String subRouteSegment) {
    if (subRouteSegment.isEmpty || subRouteSegment == AppRouteSegments.allTasks) return 0;
    if (subRouteSegment == AppRouteSegments.personalTasks) return 1;
    if (subRouteSegment == AppRouteSegments.calendar) return 2;
    if (subRouteSegment == AppRouteSegments.teams) return 3;
    if (subRouteSegment == AppRouteSegments.settings) return 4;
    if (subRouteSegment == AppRouteSegments.trash) return 5;
    return 0;
  }

  String _getPageTitleForAppBar(String subRouteSegment) {
    if (subRouteSegment == AppRouteSegments.settings) return "Настройки";
    if (subRouteSegment.isEmpty || subRouteSegment == AppRouteSegments.allTasks) return "Все задачи";
    if (subRouteSegment == AppRouteSegments.personalTasks) return "Личные задачи";
    if (subRouteSegment == AppRouteSegments.teams) return "Команды";
    if (subRouteSegment == AppRouteSegments.trash) return "Корзина";
    if (subRouteSegment == AppRouteSegments.calendar) return "Календарь";
    return "Мои Задачи";
  }

  int _getActiveBottomNavIndex(String subRouteSegment) {
    if (subRouteSegment.isEmpty || subRouteSegment == AppRouteSegments.allTasks) return 0;
    if (subRouteSegment == AppRouteSegments.personalTasks) return 1;
    if (subRouteSegment == AppRouteSegments.teams) return 2;
    if (subRouteSegment == AppRouteSegments.settings) return 3;
    if (subRouteSegment == AppRouteSegments.trash || subRouteSegment == AppRouteSegments.calendar) return 0;
    return 0;
  }

  List<BottomNavigationBarItem> _buildBottomNavigationBarItems(BuildContext context) {
    return const [
      BottomNavigationBarItem(icon: Icon(Icons.list_alt_rounded), label: "Все задачи"),
      BottomNavigationBarItem(icon: Icon(Icons.person_outline_rounded), label: "Личные"),
      BottomNavigationBarItem(icon: Icon(Icons.group_outlined), label: "Команды"),
      BottomNavigationBarItem(icon: Icon(Icons.settings_outlined), label: "Настройки"),
    ];
  }

  void _onBottomNavItemTapped(int index, AppRouterDelegate routerDelegate) {
    String targetSubRouteSegment;
    bool showRightSidebarForRoute = true;
    switch (index) {
      case 0: targetSubRouteSegment = AppRouteSegments.allTasks; break;
      case 1: targetSubRouteSegment = AppRouteSegments.personalTasks; break;
      case 2: targetSubRouteSegment = AppRouteSegments.teams; break;
      case 3: targetSubRouteSegment = AppRouteSegments.settings; showRightSidebarForRoute = false; break;
      default: targetSubRouteSegment = AppRouteSegments.allTasks;
    }
    routerDelegate.navigateTo(HomeSubPath(targetSubRouteSegment, showRightSidebar: showRightSidebarForRoute));
  }

  List<Widget> _getMobileAppBarActions(BuildContext context, String currentSubRouteSegment) {
    final bool isSettingsPage = currentSubRouteSegment == AppRouteSegments.settings;
    final bool isTeamsPage = currentSubRouteSegment == AppRouteSegments.teams;
    final bool isTrashPage = currentSubRouteSegment == AppRouteSegments.trash;
    final bool isCalendarPage = currentSubRouteSegment == AppRouteSegments.calendar;

    if (isSettingsPage || isTrashPage || isCalendarPage) return [];

    List<Widget> actions = [];
    if (!isTeamsPage) {
      actions.addAll([
        IconButton(icon: const Icon(Icons.filter_list_rounded), tooltip: "Фильтры", onPressed: () {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Фильтры (в разработке)")));
        }),
        IconButton(icon: const Icon(Icons.sort_rounded), tooltip: "Сортировка", onPressed: () {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Сортировка (в разработке)")));
        }),
      ]);
    } else {
      actions.add(IconButton(icon: const Icon(Icons.add_circle_outline_rounded), tooltip: "Создать команду", onPressed: () {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Создание команды (мобильный AppBar)")));
      }));
    }
    return actions;
  }

  void _showCreateTaskDialog(BuildContext context) {
    showDialog<bool>(
      context: context,
      builder: (BuildContext dialogContext) {
        return const TaskEditDialog(); // Для создания новой задачи
      },
    ).then((success) {
      if (success == true && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Задача добавлена!')),
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final routerDelegate = Provider.of<AppRouterDelegate>(context, listen: false);
    final bool isMobile = ResponsiveUtil.isMobile(context);

    final String currentSubRouteSegment = widget.initialSubRoute.isEmpty
        ? AppRouteSegments.allTasks
        : widget.initialSubRoute;

    final Widget currentPageContent = _getCurrentPageContent(currentSubRouteSegment, context);
    final int activeSidebarMenuIndex = _getActiveMenuIndexFromSubRoute(currentSubRouteSegment);

    final bool isSettingsPage = currentSubRouteSegment == AppRouteSegments.settings;
    final bool isTeamsPage = currentSubRouteSegment == AppRouteSegments.teams;
    final bool isTrashPage = currentSubRouteSegment == AppRouteSegments.trash;
    final bool isCalendarPage = currentSubRouteSegment == AppRouteSegments.calendar;

    if (isMobile) {
      Widget? mobileFab;
      if (!isSettingsPage && !isTeamsPage && !isTrashPage && !isCalendarPage) {
        mobileFab = FloatingActionButton(
          onPressed: () => _showCreateTaskDialog(context), // Используем новый метод
          tooltip: "Добавить задачу",
          child: const Icon(Icons.add_task_outlined),
        );
      } else if (isTeamsPage) {
        mobileFab = FloatingActionButton(
          onPressed: () {
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Создание команды (мобильный FAB)")));
          },
          tooltip: "Создать команду",
          child: const Icon(Icons.group_add_outlined),
        );
      }

      return Scaffold(
        appBar: AppBar(
          title: Text(_getPageTitleForAppBar(currentSubRouteSegment)),
          actions: _getMobileAppBarActions(context, currentSubRouteSegment),
        ),
        body: currentPageContent,
        bottomNavigationBar: BottomNavigationBar(
          items: _buildBottomNavigationBarItems(context),
          currentIndex: _getActiveBottomNavIndex(currentSubRouteSegment),
          onTap: (index) => _onBottomNavItemTapped(index, routerDelegate),
        ),
        floatingActionButton: mobileFab,
      );

    } else { // Десктоп/планшет
      bool shouldShowRightSidebar = widget.showRightSidebarInitially;
      final currentPath = routerDelegate.currentConfiguration;
      if (currentPath is HomeSubPath) {
        shouldShowRightSidebar = currentPath.showRightSidebar;
      }
      final bool hideRightSidebarForPage = isSettingsPage || isTeamsPage || isTrashPage || isCalendarPage;

      return Scaffold(
        backgroundColor: theme.colorScheme.surfaceContainerLowest,
        body: Row(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Sidebar(
              activeMenuIndex: activeSidebarMenuIndex,
            ),
            Expanded(
              child: Material(
                color: theme.colorScheme.background,
                child: currentPageContent,
              ),
            ),
            if (shouldShowRightSidebar && !hideRightSidebarForPage) const RightSidebar(),
          ],
        ),
      );
    }
  }
}
```

```
// lib/screens/calendar_screen.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
// import 'package:intl/date_symbol_data_local.dart'; // Больше не нужен здесь, если инициализация в main.dart
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import 'package:table_calendar/table_calendar.dart';
import '../models/task_model.dart';
import '../task_provider.dart';
import '../auth_state.dart';
import '../theme_provider.dart';
// import '../core/routing/app_router_delegate.dart';
// import '../services/api_service.dart'; // Не используется напрямую

class CalendarScreen extends StatefulWidget {
  const CalendarScreen({Key? key}) : super(key: key);

  @override
  State<CalendarScreen> createState() => _CalendarScreenState();
}

class _CalendarScreenState extends State<CalendarScreen> {
  late final ValueNotifier<List<Task>> _selectedEvents;
  CalendarFormat _calendarFormat = CalendarFormat.month;
  RangeSelectionMode _rangeSelectionMode = RangeSelectionMode.toggledOff;
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  DateTime? _rangeStart;
  DateTime? _rangeEnd;

  List<Task> _cachedTasksForEvents = [];

  @override
  void initState() {
    super.initState();
    // initializeDateFormatting('ru_RU', null); // <--- УДАЛЕНО (предполагается, что это сделано в main.dart)

    _selectedDay = _focusedDay;
    _selectedEvents = ValueNotifier([]);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        final taskProvider = Provider.of<TaskProvider>(context, listen: false);
        _cachedTasksForEvents = List.from(taskProvider.allTasks);
        if (_selectedDay != null) {
          try {
            _selectedEvents.value = _getEventsForDay(_selectedDay!, _cachedTasksForEvents);
          } catch (e) {
            debugPrint("Error in CalendarScreen initState while getting events: $e. Locale data might not be ready yet.");
            // Если ошибка все еще возникает, это значит, что initializeDateFormatting в main.dart
            // либо не отработал до этого момента, либо не для нужной локали.
            // Убедитесь, что в main.dart есть `await initializeDateFormatting('ru_RU', null);` ПЕРЕД `runApp()`.
          }
        }
      }
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (mounted) {
      final taskProvider = Provider.of<TaskProvider>(context);

      if (!listEquals(_cachedTasksForEvents, taskProvider.allTasks)) {
        _cachedTasksForEvents = List.from(taskProvider.allTasks);

        if (_selectedDay != null) {
          _selectedEvents.value = _getEventsForDay(_selectedDay!, _cachedTasksForEvents);
        } else if (_rangeStart != null && _rangeEnd != null) {
          _selectedEvents.value = _getEventsForRange(_rangeStart!, _rangeEnd!, _cachedTasksForEvents);
        } else if (_rangeStart != null) {
          _selectedEvents.value = _getEventsForDay(_rangeStart!, _cachedTasksForEvents);
        }
      }
    }
  }

  @override
  void dispose() {
    _selectedEvents.dispose();
    super.dispose();
  }

  List<Task> _getEventsForDay(DateTime day, List<Task> allTasks) {
    return allTasks.where((task) {
      return task.deadline != null && isSameDay(task.deadline!, day) && !task.isDeleted;
    }).toList();
  }

  List<Task> _getEventsForRange(DateTime start, DateTime end, List<Task> allTasks) {
    final days = daysInRange(start, end);
    return [
      for (final d in days) ..._getEventsForDay(d, allTasks),
    ];
  }

  void _onDaySelected(DateTime selectedDay, DateTime focusedDay) {
    if (!isSameDay(_selectedDay, selectedDay)) {
      setState(() {
        _selectedDay = selectedDay;
        _focusedDay = focusedDay;
        _rangeStart = null;
        _rangeEnd = null;
        _rangeSelectionMode = RangeSelectionMode.toggledOff;
      });
      _selectedEvents.value = _getEventsForDay(selectedDay, _cachedTasksForEvents);
    }
  }

  void _onRangeSelected(DateTime? start, DateTime? end, DateTime focusedDay) {
    setState(() {
      _selectedDay = null;
      _focusedDay = focusedDay;
      _rangeStart = start;
      _rangeEnd = end;
      _rangeSelectionMode = RangeSelectionMode.toggledOn;
    });

    if (start != null && end != null) {
      _selectedEvents.value = _getEventsForRange(start, end, _cachedTasksForEvents);
    } else if (start != null) {
      _selectedEvents.value = _getEventsForDay(start, _cachedTasksForEvents);
    } else if (end != null) {
      _selectedEvents.value = _getEventsForDay(end, _cachedTasksForEvents);
    }
  }

  @override
  Widget build(BuildContext context) {
    final themeProvider = Provider.of<ThemeProvider>(context);
    final taskProvider = Provider.of<TaskProvider>(context);
    final theme = themeProvider.currentTheme;
    final colorScheme = theme.colorScheme;

    if (taskProvider.isLoadingList && _cachedTasksForEvents.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (taskProvider.error != null && _cachedTasksForEvents.isEmpty) {
      return Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text(
                  "Ошибка загрузки данных для календаря",
                  style: Theme.of(context).textTheme.titleLarge,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  taskProvider.error!,
                  style: Theme.of(context).textTheme.bodyMedium,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton.icon(
                  icon: const Icon(Icons.refresh),
                  label: const Text("Попробовать снова"),
                  onPressed: () => taskProvider.fetchAllTasks(),
                )
              ],
            ),
          )
      );
    }

    return Scaffold(
      backgroundColor: Colors.transparent,
      body: Container(
        margin: const EdgeInsets.only(top: 16.0, right: 16.0, bottom: 16.0),
        decoration: BoxDecoration(
          color: colorScheme.surfaceContainer,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: colorScheme.outlineVariant.withOpacity(0.5), width: 1.0),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.1),
              blurRadius: 8.0,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        clipBehavior: Clip.antiAlias,
        child: Column(
          children: [
            TableCalendar<Task>(
              locale: 'ru_RU',
              firstDay: DateTime.utc(2020, 1, 1),
              lastDay: DateTime.utc(2030, 12, 31),
              focusedDay: _focusedDay,
              selectedDayPredicate: (day) => isSameDay(_selectedDay, day),
              rangeStartDay: _rangeStart,
              rangeEndDay: _rangeEnd,
              calendarFormat: _calendarFormat,
              rangeSelectionMode: _rangeSelectionMode,
              eventLoader: (day) => _getEventsForDay(day, _cachedTasksForEvents),
              startingDayOfWeek: StartingDayOfWeek.monday,
              daysOfWeekHeight: 28.0,
              calendarStyle: CalendarStyle(
                outsideDaysVisible: false,
                todayDecoration: BoxDecoration(
                  color: colorScheme.primary.withOpacity(0.3),
                  shape: BoxShape.circle,
                ),
                selectedDecoration: BoxDecoration(
                  color: colorScheme.primary,
                  shape: BoxShape.circle,
                ),
                markerDecoration: BoxDecoration(
                  color: colorScheme.secondary,
                  shape: BoxShape.circle,
                ),
                defaultTextStyle: TextStyle(color: colorScheme.onSurface),
                weekendTextStyle: TextStyle(color: colorScheme.onSurface.withOpacity(0.7)),
                outsideTextStyle: TextStyle(color: colorScheme.onSurface.withOpacity(0.3)),
              ),
              headerStyle: HeaderStyle(
                titleTextStyle: theme.textTheme.titleLarge!.copyWith(color: colorScheme.onSurface, fontSize: 18),
                formatButtonTextStyle: TextStyle(color: colorScheme.onPrimary, fontSize: 12),
                formatButtonDecoration: BoxDecoration(
                  color: colorScheme.primary,
                  borderRadius: BorderRadius.circular(8.0),
                ),
                leftChevronIcon: Icon(Icons.chevron_left, color: colorScheme.onSurface),
                rightChevronIcon: Icon(Icons.chevron_right, color: colorScheme.onSurface),
                headerPadding: const EdgeInsets.symmetric(vertical: 8.0),
              ),
              daysOfWeekStyle: DaysOfWeekStyle(
                weekdayStyle: TextStyle(color: colorScheme.onSurfaceVariant, fontWeight: FontWeight.w600, fontSize: 12),
                weekendStyle: TextStyle(color: colorScheme.onSurfaceVariant.withOpacity(0.8), fontWeight: FontWeight.w600, fontSize: 12),
              ),
              onDaySelected: _onDaySelected,
              onRangeSelected: _onRangeSelected,
              onFormatChanged: (format) {
                if (_calendarFormat != format) {
                  setState(() {
                    _calendarFormat = format;
                  });
                }
              },
              onPageChanged: (focusedDay) {
                if(!isSameDay(_focusedDay, focusedDay)){
                  setState(() {
                    _focusedDay = focusedDay;
                  });
                }
              },
            ),
            const SizedBox(height: 8.0),
            Expanded(
              child: ValueListenableBuilder<List<Task>>(
                valueListenable: _selectedEvents,
                builder: (context, value, _) {
                  if (value.isEmpty) {
                    return Center(
                      child: Text(
                        "Нет задач на выбранный день/период",
                        style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.onSurfaceVariant),
                      ),
                    );
                  }
                  return ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0),
                    itemCount: value.length,
                    itemBuilder: (context, index) {
                      final task = value[index];
                      return Card(
                        margin: const EdgeInsets.symmetric(vertical: 4.0),
                        color: task.isTeamTask
                            ? colorScheme.secondaryContainer.withOpacity(0.5)
                            : colorScheme.tertiaryContainer.withOpacity(0.5),
                        child: ListTile(
                          leading: Icon(
                            task.isTeamTask ? Icons.group_work_outlined : Icons.person_outline,
                            color: task.isTeamTask
                                ? colorScheme.onSecondaryContainer
                                : colorScheme.onTertiaryContainer,
                          ),
                          title: Text(
                            task.title,
                            style: TextStyle(
                                color: task.isTeamTask
                                    ? colorScheme.onSecondaryContainer
                                    : colorScheme.onTertiaryContainer,
                                fontWeight: FontWeight.w500
                            ),
                          ),
                          subtitle: task.deadline != null
                              ? Text(
                            'Дедлайн: ${DateFormat('HH:mm dd.MM.yyyy', 'ru_RU').format(task.deadline!)}', // Используем 'ru_RU'
                            style: TextStyle(
                                color: (task.isTeamTask
                                    ? colorScheme.onSecondaryContainer
                                    : colorScheme.onTertiaryContainer).withOpacity(0.8)
                            ),
                          )
                              : null,
                          onTap: () {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(content: Text('Нажата задача: ${task.title}')),
                            );
                          },
                        ),
                      );
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

List<DateTime> daysInRange(DateTime first, DateTime last) {
  final dayCount = last.difference(first).inDays + 1;
  return List.generate(
    dayCount,
        (index) => DateTime.utc(first.year, first.month, first.day + index),
  );
}
```

```
// lib/screens/auth_screen.dart
import 'package:client/core/constants/app_strings.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:url_launcher/url_launcher.dart';
import 'dart:async';
import 'package:flutter/foundation.dart' show kIsWeb;

import '../core/utils/responsive_utils.dart';
import '../widgets/CustomInputField.dart';
import '../widgets/PrimaryButton.dart';
import '../widgets/auth/LoginForm.dart';
import '../widgets/auth/RegisterForm.dart';
import '../widgets/auth/auth_screen_logo.dart';
import '../widgets/auth/social_auth_button.dart';
import '../widgets/auth/auth_form_container.dart';

import '../core/constants/app_assets.dart';
import '../auth_state.dart';

// Виджет для отображения сообщения о необходимости подтверждения email
class EmailConfirmationPrompt extends StatelessWidget {
  final String email;
  final VoidCallback onResendCode;
  final VoidCallback onGoToCodeInput;
  final bool isLoadingResend;

  const EmailConfirmationPrompt({
    super.key,
    required this.email,
    required this.onResendCode,
    required this.onGoToCodeInput,
    this.isLoadingResend = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 24.0, horizontal: 16.0),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.mark_email_unread_outlined, size: 64, color: theme.colorScheme.primary),
          const SizedBox(height: 16),
          Text(
            'Подтвердите ваш Email',
            style: theme.textTheme.headlineSmall,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          Text(
            'Мы отправили письмо с кодом подтверждения на адрес $email. Пожалуйста, проверьте вашу почту.',
            style: theme.textTheme.bodyMedium,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          PrimaryButton(
            text: 'Отправить код повторно',
            onPressed: isLoadingResend ? null : onResendCode,
            isLoading: isLoadingResend,
          ),
          const SizedBox(height: 12),
          TextButton(
            onPressed: isLoadingResend ? null : onGoToCodeInput,
            child: const Text('Ввести код подтверждения'),
          ),
        ],
      ),
    );
  }
}

// Виджет для ввода кода подтверждения
class EmailConfirmationCodeInput extends StatefulWidget {
  final String email;
  final Function(String code) onConfirmCode;
  final VoidCallback onCancel;
  final bool isLoading;

  const EmailConfirmationCodeInput({
    super.key,
    required this.email,
    required this.onConfirmCode,
    required this.onCancel,
    this.isLoading = false,
  });

  @override
  State<EmailConfirmationCodeInput> createState() => _EmailConfirmationCodeInputState();
}

class _EmailConfirmationCodeInputState extends State<EmailConfirmationCodeInput> {
  final _formKey = GlobalKey<FormState>();
  final _codeController = TextEditingController();

  @override
  void dispose() {
    _codeController.dispose();
    super.dispose();
  }

  void _submit() {
    if (_formKey.currentState?.validate() ?? false) {
      widget.onConfirmCode(_codeController.text.trim());
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 24.0, horizontal: 16.0),
      child: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.pin_outlined, size: 64, color: theme.colorScheme.primary),
            const SizedBox(height: 16),
            Text(
              'Введите код подтверждения',
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Text(
              'Код был отправлен на ${widget.email}.',
              style: theme.textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            CustomInputField(
              controller: _codeController,
              label: 'Код подтверждения',
              keyboardType: TextInputType.text,
              textInputAction: TextInputAction.done,
              autofocus: true,
              onFieldSubmitted: (_) => _submit(),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Введите код';
                }
                if (value.trim().length < 4) {
                  return 'Код слишком короткий';
                }
                return null;
              },
            ),
            const SizedBox(height: 24),
            PrimaryButton(
              text: 'Подтвердить Email',
              onPressed: widget.isLoading ? null : _submit,
              isLoading: widget.isLoading,
            ),
            const SizedBox(height: 12),
            TextButton(
              onPressed: widget.isLoading ? null : widget.onCancel,
              child: const Text('Отмена / Отправить код заново'),
            ),
          ],
        ),
      ),
    );
  }
}


class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});

  @override
  _AuthScreenState createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> with SingleTickerProviderStateMixin {
  bool _isLogin = true;
  AutovalidateMode _autovalidateMode = AutovalidateMode.disabled;

  final _loginFormKey = GlobalKey<FormState>();
  final _registerFormKey = GlobalKey<FormState>();

  late TextEditingController _emailController;
  late TextEditingController _passwordController;
  late TextEditingController _usernameController;
  late TextEditingController _confirmPasswordController;

  late FocusNode _loginEmailFocusNode;
  late FocusNode _loginPasswordFocusNode;
  late FocusNode _registerUsernameFocusNode;
  late FocusNode _registerEmailFocusNode;
  late FocusNode _registerPasswordFocusNode;
  late FocusNode _registerConfirmPasswordFocusNode;

  StreamSubscription? _oauthSubscription;
  bool _showCodeInputPrompt = false;

  AuthState? _authStateInstance; // Сохраняем экземпляр AuthState

  @override
  void initState() {
    super.initState();
    _emailController = TextEditingController();
    _passwordController = TextEditingController();
    _usernameController = TextEditingController();
    _confirmPasswordController = TextEditingController();

    _loginEmailFocusNode = FocusNode();
    _loginPasswordFocusNode = FocusNode();
    _registerUsernameFocusNode = FocusNode();
    _registerEmailFocusNode = FocusNode();
    _registerPasswordFocusNode = FocusNode();
    _registerConfirmPasswordFocusNode = FocusNode();

    // Получаем экземпляр AuthState один раз и сохраняем
    _authStateInstance = Provider.of<AuthState>(context, listen: false);
    _oauthSubscription = _authStateInstance!.oauthRedirectStreamWeb.listen((url) {
      if (url != null && url.isNotEmpty) {
        _launchURL(url);
      }
    });

    _authStateInstance!.addListener(_handleAuthStateChanges);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted && _authStateInstance != null) {
        _handleInitialAuthStateError(_authStateInstance!);
      }
    });
  }

  void _handleAuthStateChanges() {
    if (!mounted || _authStateInstance == null) return;
    final authState = _authStateInstance!;

    if (authState.isLoggedIn && _showCodeInputPrompt) {
      setState(() { _showCodeInputPrompt = false; });
      return;
    }

    if ((authState.errorMessage != null && authState.errorMessage!.contains('Email не подтвержден') && !authState.isLoggedIn) ||
        (authState.emailPendingConfirmation != null && !_isLogin && !_showCodeInputPrompt)) {
      if (!_showCodeInputPrompt) {
        final emailForPrompt = _emailController.text.trim().isNotEmpty
            ? _emailController.text.trim()
            : authState.emailPendingConfirmation;

        if (emailForPrompt != null && emailForPrompt.isNotEmpty) {
          if ((_isLogin && authState.errorMessage != null && authState.errorMessage!.contains('Email не подтвержден')) ||
              (!_isLogin && authState.emailPendingConfirmation != null)) {
            setState(() {
              _showCodeInputPrompt = true;
            });
          }
        }
      }
      // Не очищаем ошибку здесь, если показываем промпт,
      // но если ошибка НЕ "Email не подтвержден", то её можно показать через снекбар.
      // Очистка должна быть после того, как ошибка была показана пользователю.
    } else if (_showCodeInputPrompt && authState.emailPendingConfirmation == null && !authState.isLoading) {
      if (!authState.isLoggedIn) {
        setState(() {
          _showCodeInputPrompt = false;
          if (!_isLogin) _isLogin = true;
        });
      }
    }

    if (authState.oauthErrorMessage != null && authState.oauthErrorMessage!.isNotEmpty) {
      _showErrorSnackbar(authState.oauthErrorMessage!);
      authState.clearOAuthError();
    }
  }

  void _handleInitialAuthStateError(AuthState authState) {
    if (mounted && authState.errorMessage != null && !authState.isLoggedIn) {
      if (authState.errorMessage!.contains('Email не подтвержден')) {
        final emailForPrompt = _emailController.text.trim().isNotEmpty
            ? _emailController.text.trim()
            : authState.emailPendingConfirmation;
        if (emailForPrompt != null && emailForPrompt.isNotEmpty) {
          setState(() {
            if (_isLogin) _showCodeInputPrompt = true;
          });
        }
      } else {
        _showErrorSnackbar(authState.errorMessage!);
      }
      authState.clearErrorMessage();
    }
    if (mounted && authState.oauthErrorMessage != null && !authState.isLoggedIn) {
      _showErrorSnackbar(authState.oauthErrorMessage!);
      authState.clearOAuthError();
    }
  }

  @override
  void dispose() {
    // Используем сохраненный _authStateInstance для отписки
    _authStateInstance?.removeListener(_handleAuthStateChanges);
    _emailController.dispose();
    _passwordController.dispose();
    _usernameController.dispose();
    _confirmPasswordController.dispose();
    _loginEmailFocusNode.dispose();
    _loginPasswordFocusNode.dispose();
    _registerUsernameFocusNode.dispose();
    _registerEmailFocusNode.dispose();
    _registerPasswordFocusNode.dispose();
    _registerConfirmPasswordFocusNode.dispose();
    _oauthSubscription?.cancel();
    super.dispose();
  }

  void _showErrorSnackbar(String message) {
    if (mounted && message.isNotEmpty) {
      ScaffoldMessenger.of(context).removeCurrentSnackBar();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Theme.of(context).colorScheme.error, duration: const Duration(seconds: 5)),
      );
    }
  }

  void _showSuccessSnackbar(String message) {
    if (mounted && message.isNotEmpty) {
      ScaffoldMessenger.of(context).removeCurrentSnackBar();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Colors.green.shade600, duration: const Duration(seconds: 3)),
      );
    }
  }

  void _toggleAuthMode() {
    if (_authStateInstance?.isLoading ?? true) return;
    setState(() {
      _isLogin = !_isLogin;
      _autovalidateMode = AutovalidateMode.disabled;
      _showCodeInputPrompt = false;
      _authStateInstance?.clearEmailPendingConfirmation();
      _authStateInstance?.clearErrorMessage();
      _authStateInstance?.clearOAuthError();
      _emailController.clear();
      _passwordController.clear();
      _usernameController.clear();
      _confirmPasswordController.clear();
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _loginFormKey.currentState?.reset();
        _registerFormKey.currentState?.reset();
      });
    });
  }

  Future<void> _submitForm() async {
    final authState = _authStateInstance;
    if (authState == null || authState.isLoading) return;

    setState(() { _autovalidateMode = AutovalidateMode.onUserInteraction; });
    final formKey = _isLogin ? _loginFormKey : _registerFormKey;
    final isValid = formKey.currentState?.validate() ?? false;

    if (!isValid) return;
    authState.clearErrorMessage();
    authState.clearOAuthError();

    bool success = false;
    String submittedEmail = _emailController.text.trim();

    if (_isLogin) {
      success = await authState.signIn(
        emailOrLogin: submittedEmail,
        password: _passwordController.text.trim(),
      );
    } else {
      success = await authState.signUp(
        email: submittedEmail,
        login: _usernameController.text.trim(),
        password: _passwordController.text.trim(),
      );
      if (success && mounted) {
        if (authState.emailPendingConfirmation != null) {
          bool emailSent = await authState.sendConfirmationEmail(authState.emailPendingConfirmation!);
          if (mounted) {
            if (emailSent) {
              _showSuccessSnackbar('Код подтверждения отправлен на ${authState.emailPendingConfirmation}.');
              setState(() { _showCodeInputPrompt = true; });
            } else {
              _showErrorSnackbar(authState.errorMessage ?? 'Не удалось отправить код подтверждения.');
            }
          }
        } else {
          _showErrorSnackbar('Не удалось получить email для отправки кода подтверждения после регистрации.');
        }
        return;
      }
    }

    if (mounted) {
      if (!success && authState.errorMessage != null) {
        if (authState.errorMessage!.contains('Email не подтвержден')) {
          if (authState.emailPendingConfirmation == null && submittedEmail.isNotEmpty && submittedEmail.contains('@')) {
            authState.setEmailPendingConfirmation(submittedEmail);
          }
          setState(() { _showCodeInputPrompt = true; });
        } else {
          _showErrorSnackbar(authState.errorMessage!);
        }
      }
    }
  }

  Future<void> _handleSocialLogin(String provider) async {
    if (_authStateInstance?.isLoading ?? true) return;
    _authStateInstance?.clearErrorMessage();
    _authStateInstance?.clearOAuthError();
    _authStateInstance?.initiateOAuth(provider);
  }

  Future<void> _launchURL(String url) async {
    final uri = Uri.parse(url);
    if (kIsWeb) {
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri, webOnlyWindowName: '_self');
      } else {
        if (mounted) _showErrorSnackbar('Не удалось открыть URL: $url');
      }
    } else {
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri, mode: LaunchMode.externalApplication);
      } else {
        if (mounted) _showErrorSnackbar('Не удалось открыть URL: $url');
      }
    }
  }

  Future<void> _resendConfirmationCode() async {
    if (_authStateInstance == null) return;
    final authState = _authStateInstance!;
    final emailToResend = authState.emailPendingConfirmation ?? _emailController.text.trim();

    if (emailToResend.isEmpty || !emailToResend.contains('@')) {
      _showErrorSnackbar('Введите корректный Email для повторной отправки кода.');
      return;
    }
    if (authState.emailPendingConfirmation == null || authState.emailPendingConfirmation != emailToResend) {
      authState.setEmailPendingConfirmation(emailToResend);
    }

    final success = await authState.sendConfirmationEmail(emailToResend);
    if (mounted) {
      if (success) {
        _showSuccessSnackbar('Новый код подтверждения отправлен на $emailToResend.');
        if (!_showCodeInputPrompt) {
          setState(() { _showCodeInputPrompt = true; });
        }
      } else {
        _showErrorSnackbar(authState.errorMessage ?? 'Не удалось отправить код.');
      }
    }
  }

  Future<void> _handleConfirmCode(String code) async {
    if (_authStateInstance == null) return;
    final authState = _authStateInstance!;
    final emailToConfirm = authState.emailPendingConfirmation ?? _emailController.text.trim();

    if (emailToConfirm.isEmpty || !emailToConfirm.contains('@')) {
      _showErrorSnackbar("Email для подтверждения не найден или некорректен.");
      setState(() {
        _showCodeInputPrompt = false;
        authState.clearEmailPendingConfirmation();
      });
      return;
    }

    final emailUsedForConfirmation = emailToConfirm; // Сохраняем перед возможной очисткой
    final success = await authState.confirmEmail(emailUsedForConfirmation, code);

    if (mounted) {
      if (success) {
        _showSuccessSnackbar('Email успешно подтвержден! Теперь вы можете войти.');
        setState(() {
          _isLogin = true;
          _showCodeInputPrompt = false;
          // authState.clearEmailPendingConfirmation(); // Должно быть сделано в AuthState.confirmEmail
          _emailController.text = emailUsedForConfirmation;
          _passwordController.clear();
          _usernameController.clear();
          _confirmPasswordController.clear();
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) FocusScope.of(context).requestFocus(_loginPasswordFocusNode);
          });
        });
      } else {
        _showErrorSnackbar(authState.errorMessage ?? 'Неверный код или другая ошибка.');
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final authState = Provider.of<AuthState>(context); // Слушаем для isLoading и errorMessage

    Widget currentScreenContent;

    if (_showCodeInputPrompt && authState.emailPendingConfirmation != null) {
      currentScreenContent = AuthFormContainer(
        key: const ValueKey('code_input_prompt'),
        child: EmailConfirmationCodeInput(
          email: authState.emailPendingConfirmation!,
          isLoading: authState.isLoading,
          onConfirmCode: _handleConfirmCode,
          onCancel: () {
            setState(() {
              _showCodeInputPrompt = false;
              // Если отменяем ввод кода после регистрации, и emailPending все еще есть, показываем EmailConfirmationPrompt
              if (!_isLogin && authState.emailPendingConfirmation != null) {
                // Ничего не делаем, build() сам покажет EmailConfirmationPrompt
              } else { // Иначе (были в логине или emailPendingConfirmation уже нет)
                authState.clearEmailPendingConfirmation();
                _isLogin = true;
              }
            });
          },
        ),
      );
    } else if (!_isLogin && authState.emailPendingConfirmation != null) {
      currentScreenContent = AuthFormContainer(
        key: const ValueKey('email_confirm_prompt'),
        child: EmailConfirmationPrompt(
          email: authState.emailPendingConfirmation!,
          isLoadingResend: authState.isLoading,
          onResendCode: _resendConfirmationCode,
          onGoToCodeInput: () {
            setState(() { _showCodeInputPrompt = true; });
          },
        ),
      );
    }
    else {
      Widget formSpecificContent = _isLogin
          ? LoginForm(
        key: const ValueKey('login_form'),
        formKey: _loginFormKey,
        emailController: _emailController,
        passwordController: _passwordController,
        onSubmit: _submitForm,
        autovalidateMode: _autovalidateMode,
      )
          : RegisterForm(
        key: const ValueKey('register_form'),
        formKey: _registerFormKey,
        usernameController: _usernameController,
        emailController: _emailController,
        passwordController: _passwordController,
        confirmPasswordController: _confirmPasswordController,
        onSubmit: _submitForm,
        autovalidateMode: _autovalidateMode,
      );

      currentScreenContent = AuthFormContainer(
        key: ValueKey<bool>(_isLogin),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const AuthScreenLogo(),
            const SizedBox(height: 32),
            AnimatedSwitcher(
              duration: const Duration(milliseconds: 400),
              switchInCurve: Curves.easeInOutCubic,
              switchOutCurve: Curves.easeInCubic,
              transitionBuilder: (Widget child, Animation<double> animation) {
                final bool isLoginFormKey = child.key == const ValueKey('login_form');
                return FadeTransition(
                  opacity: animation,
                  child: SlideTransition(
                    position: Tween<Offset>(
                      begin: Offset(isLoginFormKey ? -0.2 : 0.2, 0.0),
                      end: Offset.zero,
                    ).animate(animation),
                    child: child,
                  ),
                );
              },
              child: formSpecificContent,
            ),
            const SizedBox(height: 24),
            PrimaryButton(
              text: _isLogin ? AppStrings.loginTitle : AppStrings.registerTitle,
              onPressed: authState.isLoading ? null : _submitForm,
              isLoading: authState.isLoading,
            ),
            if (authState.errorMessage != null && authState.oauthErrorMessage == null &&
                !( ( (_showCodeInputPrompt || (!_isLogin && authState.emailPendingConfirmation != null)) &&
                    authState.errorMessage!.contains('Email не подтвержден')) )
            )
              Padding(
                padding: const EdgeInsets.only(top: 12.0),
                child: Text(
                  authState.errorMessage!,
                  style: TextStyle(color: colorScheme.error, fontSize: 13),
                  textAlign: TextAlign.center,
                ),
              ),
            if (authState.oauthErrorMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 12.0),
                child: Text(
                  authState.oauthErrorMessage!,
                  style: TextStyle(color: colorScheme.error, fontSize: 13),
                  textAlign: TextAlign.center,
                ),
              ),
            const SizedBox(height: 24),
            _buildSocialAuthRow(context, authState.isLoading),
            const SizedBox(height: 24),
            _buildToggleModeLink(theme, authState.isLoading),
          ],
        ),
      );
    }

    return Scaffold(
      backgroundColor: colorScheme.background,
      body: Center(
        child: SingleChildScrollView(
          padding: EdgeInsets.symmetric(
            horizontal: ResponsiveUtil.isMobile(context) ? 16.0 : 24.0,
            vertical: 24.0,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 580),
            child: AnimatedSize(
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeInOut,
              child: AnimatedSwitcher(
                duration: const Duration(milliseconds: 500),
                switchInCurve: Curves.easeOutExpo,
                switchOutCurve: Curves.easeInExpo,
                transitionBuilder: (Widget child, Animation<double> animation) {
                  return ScaleTransition(
                    key: child.key,
                    scale: Tween<double>(begin: 0.95, end: 1.0).animate(
                        CurvedAnimation(parent: animation, curve: const ElasticOutCurve(0.7))),
                    child: FadeTransition(
                      opacity: Tween<double>(begin: 0.5, end: 1.0).animate(animation),
                      child: child,
                    ),
                  );
                },
                layoutBuilder: (Widget? currentChild, List<Widget> previousChildren) {
                  return Stack(
                    alignment: Alignment.center,
                    children: <Widget>[
                      ...previousChildren,
                      if (currentChild != null) currentChild,
                    ],
                  );
                },
                child: currentScreenContent,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSocialAuthRow(BuildContext context, bool isLoading) {
    final bool isNarrow = MediaQuery.of(context).size.width < 380;
    return Flex(
      direction: isNarrow ? Axis.vertical : Axis.horizontal,
      mainAxisAlignment: MainAxisAlignment.center,
      mainAxisSize: MainAxisSize.min,
      children: [
        SocialAuthButton(
          assetPath: AppAssets.googleIcon,
          providerName: 'Google',
          onPressed: isLoading ? null : () => _handleSocialLogin('google'),
        ),
        SizedBox(width: isNarrow ? 0 : 16, height: isNarrow ? 12 : 0),
        SocialAuthButton(
          assetPath: AppAssets.yandexIcon,
          providerName: 'Яндекс',
          onPressed: isLoading ? null : () => _handleSocialLogin('yandex'),
        ),
      ],
    );
  }

  Widget _buildToggleModeLink(ThemeData theme, bool isLoading) {
    return TextButton(
      onPressed: isLoading ? null : _toggleAuthMode,
      style: TextButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        foregroundColor: theme.colorScheme.primary,
        textStyle: theme.textTheme.labelLarge?.copyWith(fontWeight: FontWeight.w600),
      ),
      child: Text(
        _isLogin ? AppStrings.createAccountLink : AppStrings.alreadyHaveAccountLink,
        textAlign: TextAlign.center,
      ),
    );
  }
}
```

```
// lib/screens/all_tasks_kanban_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/task_model.dart';
import '../task_provider.dart'; // Используем TaskProvider
import '../auth_state.dart'; // Для получения ID текущего пользователя
import '../widgets/kanban_board/kanban_board_widget.dart';
// import '../core/routing/app_router_delegate.dart'; // Пока не используется напрямую
import '../deleted_tasks_provider.dart';
import '../core/utils/responsive_utils.dart';
import '../widgets/tasks/mobile_task_list_widget.dart';
// import '../services/api_service.dart'; // Для ApiException и NetworkException - уже не нужен напрямую здесь

class AllTasksKanbanScreen extends StatefulWidget {
  const AllTasksKanbanScreen({Key? key}) : super(key: key);

  @override
  State<AllTasksKanbanScreen> createState() => _AllTasksKanbanScreenState();
}

class _AllTasksKanbanScreenState extends State<AllTasksKanbanScreen> {

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final taskProvider = Provider.of<TaskProvider>(context, listen: false);
      // Условие немного изменено: если список всех задач пуст И не идет загрузка списка И нет ошибки
      if (taskProvider.allTasks.isEmpty && !taskProvider.isLoadingList && taskProvider.error == null) {
        // Возможно, стоит вызвать fetch, если пользователь перешел на экран, а данных нет
        // (например, после ошибки и ее очистки, но перед успешной загрузкой)
        // Однако, TaskProvider уже должен загружать при логине.
        // Если вы хотите принудительную перезагрузку при каждом входе на экран (если список пуст),
        // можно раскомментировать:
        // taskProvider.fetchAllTasks();
      }
    });
  }

  void _handleTaskStatusChanged(Task task, KanbanColumnStatus newStatus, TaskProvider taskProvider) {
    taskProvider.locallyUpdateTaskStatus(task.taskId, newStatus);
  }

  void _navigateToTaskDetails(BuildContext context, Task task) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Переход к задаче: ${task.title} (ID: ${task.taskId}) (в разработке)'),
      ),
    );
  }

  void _handleTaskDelete(BuildContext context, Task task, TaskProvider taskProvider, DeletedTasksProvider deletedTasksProvider) {
    final authState = Provider.of<AuthState>(context, listen: false); // Получаем authState для userId
    taskProvider.deleteTask(task.taskId).then((success) {
      if (success && mounted) {
        // Перемещаем в корзину локально ТОЛЬКО ПОСЛЕ успешного удаления с бэкенда
        deletedTasksProvider.moveToTrash(
          task, // Передаем исходный объект задачи
          deletedByUserId: authState.currentUser?.userId.toString(),
        );
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Задача "${task.title}" перемещена в корзину')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Ошибка удаления задачи: ${taskProvider.error ?? "Неизвестная ошибка"}'), backgroundColor: Colors.red),
        );
      }
    });
  }


  @override
  Widget build(BuildContext context) {
    final taskProvider = Provider.of<TaskProvider>(context);
    final authState = Provider.of<AuthState>(context); // listen: true, если currentUserId может меняться динамически и влиять на фильтр
    final deletedTasksProvider = Provider.of<DeletedTasksProvider>(context, listen: false);

    final String? currentUserId = authState.currentUser?.userId.toString();

    // Используем isLoadingList для отображения индикатора загрузки списка
    if (taskProvider.isLoadingList && taskProvider.allTasks.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (taskProvider.error != null && taskProvider.allTasks.isEmpty) {
      return Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text(
                  "Ошибка загрузки задач",
                  style: Theme.of(context).textTheme.titleLarge,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  taskProvider.error!,
                  style: Theme.of(context).textTheme.bodyMedium,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                ElevatedButton.icon(
                  icon: const Icon(Icons.refresh),
                  label: const Text("Попробовать снова"),
                  onPressed: () => taskProvider.fetchAllTasks(),
                )
              ],
            ),
          )
      );
    }

    final displayedTasks = taskProvider.allTasks.where((task) {
      if (currentUserId == null) return false;
      return task.assignedToUserId == currentUserId ||
          task.createdByUserId == currentUserId ||
          task.isTeamTask;
    }).toList();


    bool isMobile = ResponsiveUtil.isMobile(context);

    return Scaffold(
      backgroundColor: Colors.transparent,
      body: isMobile
          ? MobileTaskListWidget(
        tasks: displayedTasks,
        onTaskStatusChanged: (task, newStatus) => _handleTaskStatusChanged(task, newStatus, taskProvider),
        onTaskTap: (task) => _navigateToTaskDetails(context, task),
        onTaskDelete: (task) => _handleTaskDelete(context, task, taskProvider, deletedTasksProvider),
        currentUserId: currentUserId ?? '',
      )
          : Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0),
        child: KanbanBoardWidget(
          tasks: displayedTasks,
          onTaskStatusChanged: (task, newStatus) => _handleTaskStatusChanged(task, newStatus, taskProvider),
          onTaskTap: (task) => _navigateToTaskDetails(context, task),
          onTaskDelete: (task) => _handleTaskDelete(context, task, taskProvider, deletedTasksProvider),
        ),
      ),
    );
  }
}
```

```
// lib/models/team_model.dart
import 'package:flutter/material.dart'; // Для Color
import 'package:uuid/uuid.dart';

class TeamModel {
  final String id;
  final String name;
  final String? description;
  final int memberCount; // Количество участников
  final Color color;      // Цвет для карточки команды (можно генерировать или задавать)
  final String? imageUrl; // URL изображения/аватара команды (опционально)
  final DateTime createdAt;
  // Можно добавить другие поля: created_by_user_id, updated_at и т.д.

  TeamModel({
    String? id,
    required this.name,
    this.description,
    required this.memberCount,
    required this.color,
    this.imageUrl,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
        createdAt = createdAt ?? DateTime.now();

// Для упрощения, пока не будем добавлять copyWith, ==, hashCode,
// но в реальном приложении они могут понадобиться.
}
```

```
// lib/models/task_model.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
// import 'package:uuid/uuid.dart'; // Не используется, taskId приходит как int с бэка

// --- ApiTag (бывший TaskTag, теперь соответствует tag.TagResponse с бэкенда) ---
class ApiTag {
  final int id;
  final String name;
  final String? colorHex;
  final int ownerId;
  final String type;
  final DateTime createdAt;
  final DateTime updatedAt;

  ApiTag({
    required this.id,
    required this.name,
    this.colorHex,
    required this.ownerId,
    required this.type,
    required this.createdAt,
    required this.updatedAt,
  });

  Color get displayColor {
    if (colorHex != null && colorHex!.isNotEmpty) {
      try {
        final buffer = StringBuffer();
        if (colorHex!.length == 6 || colorHex!.length == 7) buffer.write('ff');
        buffer.write(colorHex!.replaceFirst('#', ''));
        return Color(int.parse(buffer.toString(), radix: 16));
      } catch (e) {
        return Colors.grey.shade400;
      }
    }
    return Colors.grey.shade400;
  }

  Color get backgroundColorPreview => displayColor.withOpacity(0.2);
  Color get textColorPreview => displayColor.computeLuminance() > 0.5 ? Colors.black.withOpacity(0.8) : Colors.white.withOpacity(0.9);
  Color get borderColorPreview => displayColor;

  factory ApiTag.fromJson(Map<String, dynamic> json) {
    return ApiTag(
      id: json['id'] as int? ?? 0,
      name: json['name'] as String? ?? 'Unknown Tag',
      colorHex: json['color'] as String?,
      ownerId: json['owner_id'] as int? ?? 0,
      type: json['type'] as String? ?? 'user',
      createdAt: DateTime.tryParse(json['created_at'] as String? ?? '') ?? DateTime.now(),
      updatedAt: DateTime.tryParse(json['updated_at'] as String? ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'color': colorHex,
    'owner_id': ownerId,
    'type': type,
    'created_at': createdAt.toIso8601String(),
    'updated_at': updatedAt.toIso8601String(),
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
          other is ApiTag &&
              runtimeType == other.runtimeType &&
              id == other.id &&
              type == other.type; // Достаточно для уникальности в контексте задачи

  @override
  int get hashCode => id.hashCode ^ type.hashCode;

  ApiTag copyWith({
    int? id,
    String? name,
    String? colorHex,
    int? ownerId,
    String? type,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return ApiTag(
      id: id ?? this.id,
      name: name ?? this.name,
      colorHex: colorHex ?? this.colorHex,
      ownerId: ownerId ?? this.ownerId,
      type: type ?? this.type,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

enum KanbanColumnStatus {
  todo,
  in_progress,
  deferred,
  done,
}

extension KanbanColumnStatusExtension on KanbanColumnStatus {
  String get title {
    switch (this) {
      case KanbanColumnStatus.todo:
        return 'К выполнению';
      case KanbanColumnStatus.in_progress:
        return 'В процессе';
      case KanbanColumnStatus.deferred:
        return 'Отложено';
      case KanbanColumnStatus.done:
        return 'Выполнено';
    }
  }
  String toJson() => name;

  static KanbanColumnStatus fromJson(String? jsonValue) {
    if (jsonValue == null) return KanbanColumnStatus.todo;
    return KanbanColumnStatus.values.firstWhere(
          (e) => e.name == jsonValue,
      orElse: () => KanbanColumnStatus.todo,
    );
  }
}

enum TaskPriority {
  low,
  medium,
  high,
}

extension TaskPriorityExtension on TaskPriority {
  String get name {
    switch (this) {
      case TaskPriority.low:
        return 'Низкий';
      case TaskPriority.medium:
        return 'Средний';
      case TaskPriority.high:
        return 'Высокий';
    }
  }

  IconData get icon {
    switch (this) {
      case TaskPriority.low:
        return Icons.arrow_downward_rounded;
      case TaskPriority.medium:
        return Icons.remove_rounded;
      case TaskPriority.high:
        return Icons.arrow_upward_rounded;
    }
  }

  int toJson() {
    switch (this) {
      case TaskPriority.low: return 1;
      case TaskPriority.medium: return 2;
      case TaskPriority.high: return 3;
    }
  }

  static TaskPriority fromJson(int? jsonValue) {
    if (jsonValue == null) return TaskPriority.low;
    switch (jsonValue) {
      case 1: return TaskPriority.low;
      case 2: return TaskPriority.medium;
      case 3: return TaskPriority.high;
      default: return TaskPriority.low;
    }
  }
}

class Task {
  final String taskId;
  String title;
  String? description;
  KanbanColumnStatus status;
  TaskPriority priority;
  DateTime? deadline;
  final DateTime createdAt;
  DateTime updatedAt;
  DateTime? completedAt;
  DateTime? deletedAt;
  List<ApiTag> tags;
  String? teamId;
  String? teamName;
  String? assignedToUserId;
  String? createdByUserId;
  String? deletedByUserId;

  Task({
    required this.taskId,
    required this.title,
    this.description,
    required this.status,
    required this.priority,
    this.deadline,
    required this.createdAt,
    required this.updatedAt,
    this.completedAt,
    this.deletedAt,
    this.tags = const [],
    this.teamId,
    this.teamName,
    this.assignedToUserId,
    this.createdByUserId,
    this.deletedByUserId,
  });

  bool get isTeamTask => teamId != null && teamId!.isNotEmpty;
  bool get isDeleted => deletedAt != null;

  factory Task.fromJson(Map<String, dynamic> json) {
    return Task(
      taskId: (json['task_id'] as int? ?? 0).toString(),
      title: json['title'] as String? ?? 'Без названия',
      description: json['description'] as String?,
      status: KanbanColumnStatusExtension.fromJson(json['status'] as String?),
      priority: TaskPriorityExtension.fromJson(json['priority'] as int?),
      deadline: json['deadline'] != null ? DateTime.tryParse(json['deadline'] as String)?.toLocal() : null, // Преобразуем в локальное время при получении
      createdAt: (DateTime.tryParse(json['created_at'] as String? ?? '') ?? DateTime.now()).toLocal(),
      updatedAt: (DateTime.tryParse(json['updated_at'] as String? ?? '') ?? DateTime.now()).toLocal(),
      completedAt: json['completed_at'] != null ? DateTime.tryParse(json['completed_at'] as String)?.toLocal() : null,
      deletedAt: json['deleted_at'] != null ? DateTime.tryParse(json['deleted_at'] as String)?.toLocal() : null,
      tags: (json['tags'] as List<dynamic>?)
          ?.map((tagJson) => ApiTag.fromJson(tagJson as Map<String, dynamic>))
          .toList() ??
          [],
      teamId: (json['team_id'] as int?)?.toString(),
      teamName: json['team_name'] as String?,
      assignedToUserId: (json['assigned_to_user_id'] as int?)?.toString(),
      createdByUserId: (json['created_by_user_id'] as int?)?.toString(),
      deletedByUserId: (json['deleted_by_user_id'] as int?)?.toString(),
    );
  }

  Map<String, dynamic> toJsonForCreate() {
    return {
      'title': title,
      if (description != null) 'description': description,
      'status': status.toJson(),
      'priority': priority.toJson(),
      if (deadline != null) 'deadline': deadline!.toUtc().toIso8601String(), // Отправляем в UTC
      if (teamId != null) 'team_id': int.tryParse(teamId!),
      if (assignedToUserId != null) 'assigned_to_user_id': int.tryParse(assignedToUserId!),
      'user_tag_ids': tags.where((t) => t.type == 'user').map((t) => t.id).toList(),
      'team_tag_ids': tags.where((t) => t.type == 'team').map((t) => t.id).toList(),
      // created_by_user_id устанавливается на бэкенде или передается в конструкторе Task при создании на фронте
      // и включается в taskData в TaskProvider перед отправкой
    };
  }

  Map<String, dynamic> toJsonForUpdate() {
    return {
      'title': title,
      'description': description,
      'status': status.toJson(),
      'priority': priority.toJson(),
      'deadline': deadline?.toUtc().toIso8601String(), // Отправляем в UTC
      'assigned_to_user_id': assignedToUserId != null ? int.tryParse(assignedToUserId!) : null,
      'user_tag_ids': tags.where((t) => t.type == 'user').map((t) => t.id).toList(),
      'team_tag_ids': tags.where((t) => t.type == 'team').map((t) => t.id).toList(),
      // completed_at может управляться через status или отдельным полем в PATCH
    };
  }

  Task copyWith({
    String? taskId,
    String? title,
    String? description,
    bool? descriptionIsNull,
    KanbanColumnStatus? status,
    TaskPriority? priority,
    DateTime? deadline,
    bool? deadlineIsNull,
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? completedAt,
    bool? completedAtIsNull,
    DateTime? deletedAt,
    bool? deletedAtIsNull,
    List<ApiTag>? tags,
    String? teamId,
    bool? teamIdIsNull,
    String? teamName,
    bool? teamNameIsNull,
    String? assignedToUserId,
    bool? assignedToUserIdIsNull,
    String? createdByUserId,
    String? deletedByUserId,
    bool? deletedByUserIdIsNull,
  }) {
    return Task(
      taskId: taskId ?? this.taskId,
      title: title ?? this.title,
      description: descriptionIsNull == true ? null : (description ?? this.description),
      status: status ?? this.status,
      priority: priority ?? this.priority,
      deadline: deadlineIsNull == true ? null : (deadline ?? this.deadline),
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      completedAt: completedAtIsNull == true ? null : (completedAt ?? this.completedAt),
      deletedAt: deletedAtIsNull == true ? null : (deletedAt ?? this.deletedAt),
      tags: tags ?? List<ApiTag>.from(this.tags),
      teamId: teamIdIsNull == true ? null : (teamId ?? this.teamId),
      teamName: teamNameIsNull == true ? null : (teamName ?? this.teamName),
      assignedToUserId: assignedToUserIdIsNull == true ? null : (assignedToUserId ?? this.assignedToUserId),
      createdByUserId: createdByUserId ?? this.createdByUserId,
      deletedByUserId: deletedByUserIdIsNull == true ? null : (deletedByUserId ?? this.deletedByUserId),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Task &&
        other.taskId == taskId &&
        other.title == title &&
        other.description == description &&
        other.status == status &&
        other.priority == priority &&
        other.deadline == deadline &&
        other.createdAt == createdAt &&
        other.updatedAt == updatedAt &&
        other.completedAt == completedAt &&
        other.deletedAt == deletedAt &&
        other.teamId == teamId &&
        other.teamName == teamName &&
        other.assignedToUserId == assignedToUserId &&
        other.createdByUserId == createdByUserId &&
        other.deletedByUserId == deletedByUserId &&
        listEquals(other.tags, tags);
  }

  @override
  int get hashCode {
    return Object.hash(
      taskId, title, description, status, priority, deadline,
      createdAt, updatedAt, completedAt, deletedAt,
      teamId, teamName,
      assignedToUserId, createdByUserId, deletedByUserId,
      Object.hashAll(tags),
    );
  }
}
```

```
// lib/core/utils/responsive_utils.dart
import 'package:flutter/material.dart';
// import 'dart:io' show Platform; // Если нужна проверка на конкретную платформу (Android/iOS)

class ResponsiveUtil {
  // Пороги для определения типа устройства (можно настроить)
  static const double _mobileBreakpoint = 650;  // Все что меньше - мобильное
  static const double _tabletBreakpoint = 1024; // От mobileBreakpoint до этого - планшет

  static bool isMobile(BuildContext context) {
    return MediaQuery.of(context).size.width < _mobileBreakpoint;
  }

  static bool isTablet(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return width >= _mobileBreakpoint && width < _tabletBreakpoint;
  }

  static bool isDesktop(BuildContext context) {
    // Все что больше или равно _tabletBreakpoint - считаем десктопом
    // (или можно ввести отдельный _desktopBreakpoint, если нужна трехступенчатая градация)
    return MediaQuery.of(context).size.width >= _tabletBreakpoint;
  }

  // Пример адаптивного значения на основе типа устройства
  static ResponsiveValue<T extends Object>({
    required BuildContext context,
    required T mobile,
    T? tablet, // Планшетное значение может быть опциональным
    required T desktop,
  }) {
    if (isMobile(context)) {
      return mobile;
    } else if (isTablet(context)) {
      return tablet ?? desktop; // Если для планшета не задано, используем десктопное
    } else {
      return desktop;
    }
  }
}
```

```
// lib/core/routing/app_router_delegate.dart
import 'package:flutter/material.dart';
import 'app_route_path.dart';
import 'app_pages.dart';
import '../../auth_state.dart'; // Убедись, что путь корректен к lib/auth_state.dart

class AppRouterDelegate extends RouterDelegate<AppRoutePath>
    with ChangeNotifier, PopNavigatorRouterDelegateMixin<AppRoutePath> {
  @override
  final GlobalKey<NavigatorState> navigatorKey;
  final AuthState authState;

  AppRoutePath _currentPathConfig;

  AppRouterDelegate({required this.authState})
      : navigatorKey = GlobalKey<NavigatorState>(),
        _currentPathConfig = authState.isLoggedIn
            ? const HomeSubPath(AppRouteSegments.personalTasks, showRightSidebar: true)
            : const AuthPath() {
    authState.addListener(_onAuthStateChanged);
  }

  void _onAuthStateChanged() {
    if (!authState.isLoggedIn) {
      _currentPathConfig = const AuthPath();
    } else {
      if (_currentPathConfig is AuthPath ||
          !(_currentPathConfig is HomePath || _currentPathConfig is HomeSubPath)) {
        _currentPathConfig = const HomeSubPath(AppRouteSegments.personalTasks, showRightSidebar: true);
      }
    }
    notifyListeners();
  }

  @override
  AppRoutePath get currentConfiguration => _currentPathConfig;

  @override
  Widget build(BuildContext context) {
    List<Page<dynamic>> pages = buildPagesForPath(_currentPathConfig, authState);

    return Navigator(
      key: navigatorKey,
      pages: pages,
      onPopPage: (route, result) {
        if (!route.didPop(result)) {
          return false;
        }
        // Простая логика для pop. Если у вас более сложная навигация,
        // эту часть нужно будет доработать.
        if (pages.length > 1) {
          // Если есть предыдущие страницы, удаляем текущую
          // Это произойдет, если buildPagesForPath может вернуть >1 страницы для _currentPathConfig
          // (например, для master-detail на больших экранах).
          // В текущей реализации buildPagesForPath обычно возвращает 1 страницу.
          // Если _currentPathConfig изменится так, что buildPagesForPath вернет другой стек,
          // это будет обработано.
        } else if (_currentPathConfig is HomePath || _currentPathConfig is HomeSubPath) {
          // Пользователь нажал "назад" на единственной домашней странице.
          // Можно либо закрыть приложение, либо разлогинить.
          // authState.logout(); // Это приведет к показу AuthScreen
          // return true; // Предотвратить закрытие приложения и показать AuthScreen
        }
        return false; // Позволить системный pop по умолчанию
      },
    );
  }

  @override
  Future<void> setNewRoutePath(AppRoutePath configuration) async {
    _currentPathConfig = configuration;
    // notifyListeners(); // Не всегда нужен здесь, Flutter перестроит
  }

  void navigateTo(AppRoutePath path) {
    bool shouldNotify = true;
    if (_currentPathConfig == path) {
      if (path is HomeSubPath && _currentPathConfig is HomeSubPath) {
        if ((_currentPathConfig as HomeSubPath).subRoute == path.subRoute &&
            (_currentPathConfig as HomeSubPath).showRightSidebar == path.showRightSidebar) {
          shouldNotify = false;
        }
      } else {
        shouldNotify = false;
      }
    }

    if (shouldNotify) {
      _currentPathConfig = path;
      notifyListeners();
    }
  }

  @override
  void dispose() {
    authState.removeListener(_onAuthStateChanged);
    super.dispose();
  }
}
```

```
// lib/core/routing/app_route_path.dart
abstract class AppRoutePath {
  const AppRoutePath();
}

class AuthPath extends AppRoutePath {
  const AuthPath();
}

class HomePath extends AppRoutePath {
  const HomePath();
}

// Для вложенных путей внутри HomePage (например, /home/settings)
class HomeSubPath extends AppRoutePath {
  final String subRoute; // например, 'settings', 'all-tasks'
  final bool showRightSidebar;

  const HomeSubPath(this.subRoute, {this.showRightSidebar = true});
}

class UnknownPath extends AppRoutePath {
  const UnknownPath();
}
```

```
// lib/core/routing/app_route_information_parser.dart
import 'package:flutter/material.dart';
import 'app_route_path.dart';
import 'app_pages.dart'; // Для AppRouteSegments и дефолтных путей

class AppRouteInformationParser extends RouteInformationParser<AppRoutePath> {
  @override
  Future<AppRoutePath> parseRouteInformation(RouteInformation routeInformation) async {
    final uri = Uri.parse(routeInformation.uri.toString());

    if (uri.pathSegments.isEmpty) {
      return const AuthPath();
    }

    final firstSegment = uri.pathSegments.first;

    if (firstSegment == AppRouteSegments.auth) {
      return const AuthPath();
    }

    if (firstSegment == AppRouteSegments.home) {
      if (uri.pathSegments.length == 1) {
        return const HomeSubPath(AppRouteSegments.personalTasks, showRightSidebar: true);
      }
      if (uri.pathSegments.length == 2) {
        final subRouteSegment = uri.pathSegments[1];
        bool showRightSidebar = true;

        // Определяем, для каких страниц не нужен правый сайдбар
        if ([
          AppRouteSegments.settings,
          AppRouteSegments.trash,
          AppRouteSegments.calendar // <<< КАЛЕНДАРЬ ПОКА БЕЗ ПРАВОГО САЙДБАРА (можно изменить)
        ].contains(subRouteSegment)) {
          showRightSidebar = false;
        }

        if ([
          AppRouteSegments.settings,
          AppRouteSegments.allTasks,
          AppRouteSegments.personalTasks,
          AppRouteSegments.teams,
          AppRouteSegments.trash,
          AppRouteSegments.calendar, // <<< ДОБАВЛЕНА ПРОВЕРКА
        ].contains(subRouteSegment)) {
          return HomeSubPath(subRouteSegment, showRightSidebar: showRightSidebar);
        } else {
          return const HomeSubPath(AppRouteSegments.personalTasks, showRightSidebar: true);
        }
      }
      return const HomeSubPath(AppRouteSegments.personalTasks, showRightSidebar: true);
    }

    return const UnknownPath();
  }

  @override
  RouteInformation? restoreRouteInformation(AppRoutePath configuration) {
    if (configuration is AuthPath) {
      return RouteInformation(uri: Uri.parse(AppRoutes.auth));
    }
    if (configuration is HomePath) {
      return RouteInformation(uri: Uri.parse(AppRoutes.personalTasks));
    }
    if (configuration is HomeSubPath) {
      return RouteInformation(uri: Uri.parse('/${AppRouteSegments.home}/${configuration.subRoute}'));
    }
    if (configuration is UnknownPath) {
      return RouteInformation(uri: Uri.parse('/404'));
    }
    return null;
  }
}
```

```
// lib/core/routing/app_pages.dart
import 'package:flutter/material.dart';
import '../../screens/auth_screen.dart';
import '../../screens/home_screen.dart';
import 'app_route_path.dart';
import '../../auth_state.dart'; // Убедись, что путь корректен к lib/auth_state.dart

// Константы для СЕГМЕНТОВ маршрутов
class AppRouteSegments {
  static const String auth = 'auth';
  static const String home = 'home';
  static const String settings = 'settings';
  static const String allTasks = 'all-tasks';
  static const String personalTasks = 'personal-tasks';
  static const String teams = 'teams';
  static const String trash = 'trash';
  static const String calendar = 'calendar'; // <<< НОВЫЙ СЕГМЕНТ
}

// Константы для ПОЛНЫХ ПУТЕЙ
class AppRoutes {
  static const String auth = '/${AppRouteSegments.auth}';
  static const String home = '/${AppRouteSegments.home}';
  static const String settings = '${home}/${AppRouteSegments.settings}';
  static const String allTasks = '${home}/${AppRouteSegments.allTasks}';
  static const String personalTasks = '${home}/${AppRouteSegments.personalTasks}';
  static const String teams = '${home}/${AppRouteSegments.teams}';
  static const String trash = '${home}/${AppRouteSegments.trash}';
  static const String calendar = '${home}/${AppRouteSegments.calendar}'; // <<< НОВЫЙ ПУТЬ
}

List<Page<dynamic>> buildPagesForPath(AppRoutePath path, AuthState authState) {
  final List<Page<dynamic>> pages = [];

  if (!authState.isLoggedIn) {
    pages.add(_createPage(const AuthScreen(), const ValueKey('AuthPage'), AppRoutes.auth));
  } else {
    // Пользователь залогинен
    if (path is HomePath || path is HomeSubPath) {
      String subRoute = AppRouteSegments.personalTasks; // Дефолтный подраздел
      bool showRightSidebar = true;

      if (path is HomeSubPath) {
        subRoute = path.subRoute;
        showRightSidebar = path.showRightSidebar;
      } else if (path is HomePath) { // Явно обрабатываем HomePath
        subRoute = AppRouteSegments.personalTasks; // Дефолтный подраздел для /home
        showRightSidebar = true;
      }

      // Проверка на валидность subRoute
      final validSubRoutes = [
        AppRouteSegments.allTasks,
        AppRouteSegments.personalTasks,
        AppRouteSegments.teams,
        AppRouteSegments.settings,
        AppRouteSegments.trash,
        AppRouteSegments.calendar, // <<< ДОБАВЛЕН ВАЛИДНЫЙ ПОДМАРШРУТ
      ];
      if (!validSubRoutes.contains(subRoute)) {
        subRoute = AppRouteSegments.personalTasks; // Фоллбэк на дефолтный
        showRightSidebar = true; // И соответствующий сайдбар
      }


      pages.add(_createPage(
          HomePage(initialSubRoute: subRoute, showRightSidebarInitially: showRightSidebar),
          ValueKey('HomePage-$subRoute-$showRightSidebar'), // Уникальный ключ
          '/${AppRouteSegments.home}/$subRoute'
      ));
    } else if (path is AuthPath && authState.isLoggedIn) {
      // Если залогинен и пытается перейти на /auth, редирект на home
      pages.add(_createPage(
          const HomePage(initialSubRoute: AppRouteSegments.personalTasks, showRightSidebarInitially: true),
          const ValueKey('HomePage-redirect-from-auth'),
          AppRoutes.personalTasks
      ));
    } else {
      // UnknownPath или другой сценарий для залогиненного пользователя
      pages.add(_createPage(
          const HomePage(initialSubRoute: AppRouteSegments.personalTasks, showRightSidebarInitially: true),
          const ValueKey('HomePage-default-for-unknown'),
          AppRoutes.personalTasks
      ));
    }
  }

  if (pages.isEmpty) {
    // Этот блок не должен вызываться при правильной логике выше
    pages.add(_createPage(
        const Scaffold(body: Center(child: Text('Ошибка маршрутизации'))),
        const ValueKey('ErrorPage'),
        '/error'
    ));
  }
  return pages;
}

MaterialPage _createPage(Widget child, ValueKey key, String name, {Object? arguments}) {
  return MaterialPage(
    child: child,
    key: key,
    name: name,
    arguments: arguments,
  );
}
```

```
// lib/core/constants/app_strings.dart (Пример, можно расширять)
class AppStrings {
  // AuthScreen
  static const String loginTitle = 'Войти';
  static const String registerTitle = 'Зарегистрироваться';
  static const String createAccountLink = 'Создать аккаунт →';
  static const String alreadyHaveAccountLink = 'Уже есть аккаунт? Войти →';
  static const String loginVia = 'Вход через'; // Для SnackBar

  // LoginForm
  static const String emailOrLoginLabel = 'Email или Логин';
  static const String passwordLabel = 'Пароль';
  static const String emailRequiredError = 'Введите email';
  static const String invalidEmailError = 'Некорректный email';
  static const String passwordRequiredError = 'Введите пароль';
  static const String passwordMinLengthError = 'Минимум 6 символов';
  static const String passwordComplexityError = 'Пароль должен содержать буквы и цифры';

  // RegisterForm
  static const String usernameLabel = 'Логин'; // Было 'Логин' в коде, но 'Имя' в validator
  static const String usernameRequiredError = 'Введите логин';
  static const String emailLabel = 'Email';
  static const String confirmPasswordLabel = 'Подтвердите пароль';
  static const String confirmPasswordRequiredError = 'Подтвердите пароль';
  static const String passwordsDoNotMatchError = 'Пароли не совпадают';
}
```

```
// lib/core/constants/app_assets.dart
class AppAssets {
  static const String logo = 'assets/icons/logo.svg';
  static const String googleIcon = 'assets/icons/google.svg';
  static const String yandexIcon = 'assets/icons/yandex.svg';
  static const String avatar = 'assets/images/avatar.webp';
}
```